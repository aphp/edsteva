{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>     EDS-TeVa  </p> <p> </p> <p>Documentation: https://aphp.github.io/edsteva/latest/</p> <p>Source Code: https://github.com/aphp/edsteva</p>"},{"location":"#getting-started","title":"Getting Started","text":"<p>EDS-TeVa provides a set of tools to characterize the temporal variability of data induced by the dynamics of the clinical IT system.</p>"},{"location":"#context","title":"Context","text":"<p>Real world data is subject to important temporal drifts that may be caused by a variety of factors1. In particular, data availability fluctuates with the deployment of clinical softwares and their clinical use. The dynamics of software deployment and adoption is not trivial as it depends on the care site and on the category of data that are considered.</p>"},{"location":"#installation","title":"Installation","text":"<p>Requirements</p> <p>EDS-TeVa stands on the shoulders of Spark 2.4 which runs on Java 8 and Python ~3.7.1, it is essential to:</p> <ul> <li>Install a version of Python \\(\\geq 3.7.1\\) and \\(&lt; 3.8\\).</li> <li> <p>Install OpenJDK 8, an open-source reference implementation of Java 8 wit the following command lines:</p> Linux (Debian, Ubunutu, etc.)MacWindows <p> <pre><code>$ sudo apt-get update\n$ sudo apt-get install openjdk-8-jdk\n---&gt; 100%\n</code></pre> </p> <p>For more details, check this installation guide</p> <p> <pre><code>$ brew tap AdoptOpenJDK/openjdk\n$ brew install --cask adoptopenjdk8\n---&gt; 100%\n</code></pre> </p> <p>For more details, check this installation guide</p> <p>Follow this installation guide</p> </li> </ul> <p>You can install EDS-TeVa through <code>pip</code>:</p> <pre><code>$ pip install edsteva\n---&gt; 100%\ncolor:green Successfully installed edsteva\n</code></pre> <p>We recommend pinning the library version in your projects, or use a strict package manager like Poetry.</p> <pre><code>pip install edsteva==0.2.5\n</code></pre>"},{"location":"#working-example-administrative-records-relative-to-visits","title":"Working example: administrative records relative to visits","text":"<p>Let's consider a basic category of data: administrative records relative to visits. A visit is characterized by a care site, a length of stay, a stay type (full hospitalisation, emergency, consultation, etc.) and other characteristics. In this example, the objective is to estimate the availability of visits records with respect to time, care site and stay type.</p>"},{"location":"#1-load-your-data","title":"1. Load your data","text":"<p>As detailled in the dedicated section, EDS-TeVa is expecting to work with Pandas or Koalas DataFrames.  We provide various connectors to facilitate data fetching, namely a Hive connector, a Postgres connector and a LocalData.</p> Using a Hive DataBaseUsing a Postgres DataBaseUsing a Local DataBase <pre><code>from edsteva.io import HiveData\n\ndb_name = \"my_db\"\ntables_to_load = [\n    \"visit_occurrence\",\n    \"visit_detail\",\n    \"care_site\",\n    \"fact_relationship\",\n]\ndata = HiveData(db_name, tables_to_load=tables_to_load)\ndata.visit_occurrence  # (1)\n</code></pre> <ol> <li>With this connector, <code>visit_occurrence</code> will be a Koalas DataFrame</li> </ol> <pre><code>from edsteva.io import PostgresData\n\ndb_name = \"my_db\"\nschema = \"my_schema\"\nuser = \"my_username\"\ndata = PostgresData(db_name, schema=schema, user=user)  # (1)\ndata.visit_occurrence  # (2)\n</code></pre> <ol> <li>This connector expects a <code>.pgpass</code> file storing the connection parameters</li> <li>With this connector, <code>visit_occurrence</code> will be a Pandas DataFrame</li> </ol> <pre><code>import os\nfrom edsteva.io import LocalData\n\nfolder = os.path.abspath(MY_FOLDER_PATH)\n\ndata = LocalData(folder)  # (1)\ndata.visit_occurrence  # (2)\n</code></pre> <ol> <li>This connector expects a <code>folder</code> with a file per table to load.</li> <li>With this connector, <code>visit_occurrence</code> will be a Pandas DataFrame</li> </ol>"},{"location":"#2-choose-a-probe-or-create-a-new-probe","title":"2. Choose a Probe or create a new Probe","text":"<p>Probe</p> <p>A Probe is a python class designed to compute a completeness predictor \\(c(t)\\) that characterizes data availability of a target variable over time \\(t\\).</p> <p>In this example, \\(c(t)\\) predicts the availability of administrative records relative to visits. It is defined for each characteristic (care site, stay type, age range, length of stay, etc.) as the number of visits \\(n_{visit}(t)\\) per month \\(t\\), normalized by the maximum number of records per month \\(n_{max} = \\max_{t}(n_{visit}(t))\\) computed over the entire study period:</p> \\[ c(t) = \\frac{n_{visit}(t)}{n_{max}} \\] <p>If the maximum number of records per month \\(n_{max}\\) is equal to 0, we consider that the completeness predictor \\(c(t)\\) is also equal to 0.</p> <p>The VisitProbe is already available by default in the library:</p>"},{"location":"#21-compute-your-probe","title":"2.1 Compute your Probe","text":"<p>The <code>compute()</code> method takes a Data object as input and stores the computed completeness predictor \\(c(t)\\) in the <code>predictor</code> attribute of a <code>Probe</code>:</p> <pre><code>from edsteva.probes import VisitProbe\n\nprobe_path = \"my_path/visit.pkl\"\n\nvisit = VisitProbe()\nvisit.compute(\n    data,\n    care_site_levels=[\"Hospital\", \"Pole\", \"UF\"],  # (1)\n    stay_types={\n        \"All\": \".*\",\n        \"Urg_Hospit\": \"urgence|hospitalis\u00e9s\",  # (2)\n    },\n    care_site_specialties=None,  # (3)\n    stay_sources=None,  # (4)\n    length_of_stays=None,  # (5)\n    provenance_sources=None,  # (6)\n    age_ranges=None,  # (7)\n)\nvisit.save(path=probe_path)  # (8)\nvisit.predictor.head()\n</code></pre> <ol> <li>The care sites are articulated into levels (cf. AP-HP's reference structure). Here, as an example, we are only interested in those three levels.</li> <li>The <code>stay_types</code> argument expects a python dictionary with labels as keys and regex as values.</li> <li>In this example we want to ignore the care site specialty (e.g., Cardiology, Pediatrics).</li> <li>In this example we want to ignore the stay source (e.g., MCO, SSR, PSY).</li> <li>In this example we want to ignore the length of stay (e.g., \\(&gt;=\\) 7 days, \\(&lt;=\\) 2 days).</li> <li>In this example we want to ignore the provenance source (e.g., service d'urgence, d'une unit\u00e9 de soins de courte dur\u00e9e).</li> <li>In this example we want to ignore the age range (e.g., 0-18 years, 18-25 years, 25-30 years).</li> <li>Saving the Probe after computation saves you from having to compute it again. You just use <code>VisitProbe.load(path=probe_path)</code>.</li> </ol> <p><code>Saved to /my_path/visit.pkl</code></p> care_site_level care_site_id care_site_short_name stay_type date n_visit c Unit\u00e9 Fonctionnelle (UF) 8312056386 Care site 1 'Urg_Hospit' 2019-05-01 233.0 0.841 Unit\u00e9 Fonctionnelle (UF) 8312056386 Care site 1 'All' 2021-04-01 393.0 0.640 P\u00f4le/DMU 8312027648 Care site 2 'Urg_Hospit' 2017-03-01 204.0 0.497 P\u00f4le/DMU 8312027648 Care site 2 'All' 2018-08-01 22.0 0.274 H\u00f4pital 8312022130 Care site 3 'Urg_Hospit' 2022-02-01 9746.0 0.769"},{"location":"#22-filter-your-probe","title":"2.2 Filter your Probe","text":"<p>In this example, we are interested in three hospitals. We consequently filter data before any further analysis.</p> <pre><code>from edsteva.probes import VisitProbe\n\ncare_site_short_name = [\"H\u00f4pital-1\", \"H\u00f4pital-2\", \"H\u00f4pital-3\"]\n\nfiltered_visit = VisitProbe()\nfiltered_visit.load(path=probe_path)\nfiltered_visit.filter_care_site(care_site_short_names=care_site_short_name)  # (1)\n</code></pre> <ol> <li>To filter care sites there is a dedicated method that also includes all upper and lower levels care sites related to the selected care sites.</li> </ol>"},{"location":"#23-visualize-your-probe","title":"2.3 Visualize your Probe","text":""},{"location":"#interactive-dashboard","title":"Interactive dashboard","text":"<p>Interactive dashboards can be used to visualize the average completeness predictor \\(c(t)\\) of the selected care sites and stay types.</p> <p><pre><code>from edsteva.viz.dashboards import probe_dashboard\n\nprobe_dashboard(\n    probe=filtered_visit,\n)\n</code></pre> Interactive dashboard is available here</p>"},{"location":"#static-plot","title":"Static plot","text":"<p>If you need a static plot for a report, a paper or anything else, you can use the <code>probe_plot()</code> function. It returns the top plot of the dashboard without the interactive filters. Consequently, you have to specify the filters in the inputs of the function.</p> <pre><code>from edsteva.viz.plots import probe_plot\n\nplot_path = \"my_path/visit.html\"\nstay_type = \"All\"\n\nprobe_plot(\n    probe=filtered_visit,\n    care_site_level=\"Hospital\",\n    stay_type=stay_type,\n    save_path=plot_path,  # (1)\n)\n</code></pre> <ol> <li>If a <code>save_path</code> is specified, it'll save your plot in the specified path.</li> </ol> <p>{   \"schema-url\": \"assets/charts/visit.json\" }</p>"},{"location":"#3-choose-a-model-or-create-a-new-model","title":"3. Choose a Model or create a new Model","text":"<p>Model</p> <p>A Model is a python class designed to fit a function \\(f_\\Theta(t)\\) to each completeness predictor \\(c(t)\\) of a Probe. The fit process estimates the coefficients \\(\\Theta\\) with metrics to characterize the temporal variability of data availability.</p> <p>In this example, the model fits a step function \\(f_{t_0, c_0}(t)\\) to the completeness predictor \\(c(t)\\) with coefficients \\(\\Theta = (t_0, c_0)\\):</p> \\[ f_{t_0, c_0}(t) = c_0 \\ \\mathbb{1}_{t \\geq t_0}(t) \\] <ul> <li>the characteristic time \\(t_0\\) estimates the time after which the data is available.</li> <li>the characteristic value \\(c_0\\) estimates the stabilized routine completeness.</li> </ul> <p>It also computes the following \\(error\\) metric that estimates the stability of the data after \\(t_0\\):</p> \\[ \\begin{aligned} error &amp; = \\frac{\\sum_{t_0 \\leq  t \\leq t_{max}} \\epsilon(t)^2}{t_{max} - t_0} \\\\ \\epsilon(t) &amp; = f_{t_0, c_0}(t) - c(t) \\end{aligned} \\] <p>This step function Model is available in the library.</p>"},{"location":"#31-fit-your-model","title":"3.1 Fit your Model","text":"<p>The <code>fit</code> method takes a Probe as input, it estimates the coefficients, for example by minimizing a quadratic loss function and computes the metrics. Finally, it stores the estimated coefficients and the computed metrics in the <code>estimates</code> attribute of the <code>Model</code>.</p> <pre><code>from edsteva.models.step_function import StepFunction\n\nmodel_path = \"my_path/fitted_visit.pkl\"\n\nstep_function_model = StepFunction()\nstep_function_model.fit(probe=filtered_visit)\nstep_function_model.save(model_path)  # (1)\nstep_function_model.estimates.head()\n</code></pre> <ol> <li>Saving the Model after fitting saves you from having to fit it again. You just use <code>StepFunction.load(path=model_path)</code>.</li> </ol> <p><code>Saved to /my_path/fitted_visit.pkl</code></p> care_site_level care_site_id stay_type t_0 c_0 error P\u00f4le/DMU 8312056386 'Urg_Hospit' 2019-05-01 0.397 0.040 P\u00f4le/DMU 8312056386 'All' 2017-04-01 0.583 0.028 P\u00f4le/DMU 8312027648 'Urg_Hospit' 2021-03-01 0.677 0.022 P\u00f4le/DMU 8312027648 'All' 2018-08-01 0.764 0.014 P\u00f4le/DMU 8312022130 'Urg_Hospit' 2022-02-01 0.652 0.027"},{"location":"#32-visualize-your-fitted-probe","title":"3.2 Visualize your fitted Probe","text":""},{"location":"#interactive-dashboard_1","title":"Interactive dashboard","text":"<p>Interactive dashboards can be used to visualize the average completeness predictor \\(c(t)\\) along with the fitted step function of the selected care sites and stay types.</p> <p><pre><code>from edsteva.viz.dashboards import probe_dashboard\n\nprobe_dashboard(\n    probe=filtered_visit,\n    fitted_model=step_function_model,\n)\n</code></pre> Interactive dashboard is available here.</p>"},{"location":"#static-plot_1","title":"Static plot","text":"<p>If you need a static plot for a report, a paper or anything else, you can use the <code>probe_plot()</code> function. It returns the top plot of the dashboard without the interactive filters. Consequently, you have to specify the filters in the inputs of the function.</p> <p><pre><code>from edsteva.viz.plots import probe_plot\n\nplot_path = \"my_path/fitted_visit.html\"\nstay_type = \"All\"\n\nprobe_plot(\n    probe=filtered_visit,\n    fitted_model=step_function_model,\n    care_site_level=\"Hospital\",\n    stay_type=stay_type,\n    save_path=plot_path,  # (1)\n)\n</code></pre> 1. If a <code>save_path</code> is specified, it'll save your plot in the specified path.</p> <p>{   \"schema-url\": \"assets/charts/fitted_visit.json\" }</p>"},{"location":"#4-set-the-thresholds-to-fix-the-deployment-bias","title":"4. Set the thresholds to fix the deployment bias","text":"<p>Now, that we have estimated \\(t_0\\), \\(c_0\\) and \\(error\\) for each care site and each stay type, one can set a threshold for each estimate in order to select only the care sites where the visits are available over the period of interest.</p>"},{"location":"#41-visualize-estimates-distributions","title":"4.1 Visualize estimates distributions","text":"<p>Visualizing the density plots and the medians of the estimates can help you setting the thresholds' values.</p> <p><pre><code>from edsteva.viz.plots import estimates_densities_plot\n\nestimates_densities_plot(\n    probe=filtered_visit,\n    fitted_model=step_function_model,\n)\n</code></pre> {   \"schema-url\": \"assets/charts/estimates_densities.json\" }</p>"},{"location":"#42-set-the-thresholds","title":"4.2 Set the thresholds","text":"<p>The estimates dashboard provides a representation of the overall deviation from the Model on the top and interactive sliders on the bottom that allows you to vary the thresholds. The idea is to set the thresholds that keep the most care sites while having an acceptable overall deviation.</p> <pre><code>from edsteva.viz.dashboards import estimates_dashboard\n\nestimates_dashboard(\n    probe=filtered_visit,\n    fitted_model=step_function_model,\n)\n</code></pre> <p>The threshold dashboard is available here.</p>"},{"location":"#43-fix-the-deployment-bias","title":"4.3 Fix the deployment bias","text":"<p>Once you set the thresholds, you can extract for each stay type the care sites for which data availability is estimated to be stable over the entire study period.</p> <pre><code>t_0_max = \"2020-01-01\"  # (1)\nc_0_min = 0.6  # (2)\nerror_max = 0.05  # (3)\n\nestimates = step_function_model.estimates\nselected_care_site = estimates[\n    (estimates[\"t_0\"] &lt;= t_0_max)\n    &amp; (estimates[\"c_0\"] &gt;= c_0_min)\n    &amp; (estimates[\"error\"] &lt;= error_max)\n]\nprint(selected_care_site[\"care_site_id\"].unique())\n</code></pre> <ol> <li>In this example the study period starts on January 1, 2020.</li> <li>The characteristic value \\(c_0\\) estimates the stabilized routine completeness. As we want the selected care sites to have a good completeness after \\(t_0\\), one can for example set the threshold around the median (cf. distribution) to keep half of the care sites with the highest completeness after \\(t_0\\).</li> <li>\\(error\\) estimates the stability of the data after \\(t_0\\). As we want the selected care sites to be stable after \\(t_0\\), one can set the threshold around the median (cf. distribution) to keep half of the care sites with the lowest error after \\(t_0\\).</li> </ol> <pre><code>[8312056386, 8457691845, 8745619784, 8314578956, 8314548764, 8542137845]\n</code></pre> <p>In this example, \\(c_0\\) and \\(error\\) thresholds have been set around the median (cf. distribution). However, this method is arbitrary and you have to find the appropriate method for your study with the help of the estimate dashboard.</p> <p>Limitations</p> <p>EDS-TeVa provides modelling tools to characterize the temporal variability of your data, it does not intend to provide direct methods to fix the deployment bias. As an open-source library, EDS-TeVa is also here to host a discussion in order to facilitate collective methodological convergence on flexible solutions. The default methods proposed in this example is intended to be reviewed and challenged by the user community.</p>"},{"location":"#make-it-your-own","title":"Make it your own","text":"<p>The working example above describes the canonical usage workflow. However, you would probably need different Probes, Models, Visualizations and methods to set the thresholds for your projects. The components already available in the library are listed below but if it doesn't meet your requirements, you are encouraged to create your own.</p> <p>Contribution</p> <p>If you managed to implement your own component, or even if you just thought about a new component do not hesitate to share it with the community by following the contribution guidelines. Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given.</p>"},{"location":"#available-components","title":"Available components","text":"ProbeModelVisualization VisitProbeNoteProbeConditionProbeBiologyProbe <p>The <code>VisitProbe</code> computes \\(c_{visit}(t)\\) the availability of administrative stays:</p> per_visit_default \\[ c(t) = \\frac{n_{visit}(t)}{n_{max}} \\] <p>Where \\(n_{visit}(t)\\) is the number of administrative stays, \\(t\\) is the month and \\(n_{max} = \\max_{t}(n_{visit}(t))\\).</p> <p>If the maximum number of records per month \\(n_{max}\\) is equal to 0, we consider that the completeness predictor \\(c(t)\\) is also equal to 0.</p> <pre><code>from edsteva.probes import VisitProbe\n\nvisit = VisitProbe()\nvisit.compute(\n    data,\n    stay_types={\n        \"Urg\": \"urgence\",\n        \"Hospit\": \"hospitalis\u00e9s\",\n        \"Urg_Hospit\": \"urgence|hospitalis\u00e9s\",\n    },\n)\nvisit.predictor.head()\n</code></pre> care_site_level care_site_id care_site_short_name stay_type date n_visit c Unit\u00e9 Fonctionnelle (UF) 8312056386 Care site 1 'Urg' 2019-05-01 233.0 0.841 Unit\u00e9 Fonctionnelle (UF) 8312056386 Care site 1 'Urg' 2021-04-01 393.0 0.640 P\u00f4le/DMU 8312027648 Care site 2 'Hospit' 2017-03-01 204.0 0.497 P\u00f4le/DMU 8312027648 Care site 2 'Urg' 2018-08-01 22.0 0.274 H\u00f4pital 8312022130 Care site 3 'Urg_Hospit' 2022-02-01 9746.0 0.769 <p>The <code>NoteProbe</code> computes \\(c_{note}(t)\\) the availability of clinical documents:</p> per_visit_defaultper_note_default <p>The <code>per_visit_default</code> algorithm computes \\(c_(t)\\) the availability of clinical documents linked to patients' administrative stays:</p> \\[ c(t) = \\frac{n_{with\\,doc}(t)}{n_{visit}(t)} \\] <p>Where \\(n_{visit}(t)\\) is the number of administrative stays, \\(n_{with\\,doc}\\) the number of visits having at least one document and \\(t\\) is the month.</p> <p>If the number of visits \\(n_{visit}(t)\\) is equal to 0, we consider that the completeness predictor \\(c(t)\\) is also equal to 0.</p> <pre><code>from edsteva.probes import NoteProbe\n\nnote = Note(completeness_predictor=\"per_visit_default\")\nnote.compute(\n    data,\n    stay_types={\n        \"Urg\": \"urgence\",\n        \"Hospit\": \"hospitalis\u00e9s\",\n        \"Urg_Hospit\": \"urgence|hospitalis\u00e9s\",\n    },\n    note_types={\n        \"All\": \".*\",\n        \"CRH\": \"crh\",\n        \"Ordonnance\": \"ordo\",\n        \"CR Passage Urgences\": \"urge\",\n    },\n)\nnote.predictor.head()\n</code></pre> care_site_level care_site_id care_site_short_name stay_type note_type date n_visit n_visit_with_note c Unit\u00e9 Fonctionnelle (UF) 8312056386 Care site 1 'Urg' 'All' 2019-05-01 233.0 196.0 0.841 Unit\u00e9 Fonctionnelle (UF) 8653815660 Care site 1 'Hospit' 'CRH' 2017-04-01 393.0 252.0 0.640 P\u00f4le/DMU 8312027648 Care site 2 'Hospit' 'CRH' 2021-03-01 204.0 101.0 0.497 P\u00f4le/DMU 8312056379 Care site 2 'Urg' 'Ordonnance' 2018-08-01 22.0 6.0 0.274 H\u00f4pital 8312022130 Care site 3 'Urg_Hospit' 'CR Passage Urgences' 2022-02-01 9746.0 7495.0 0.769 <p>The <code>per_note_default</code> algorithm computes \\(c_(t)\\) the availability of clinical documents as follow:</p> \\[ c(t) = \\frac{n_{note}(t)}{n_{max}} \\] <p>Where \\(n_{note}(t)\\) is the number of clinical documents, \\(t\\) is the month and \\(n_{max} = \\max_{t}(n_{note}(t))\\).</p> <p>If the maximum number of recorded notes per month \\(n_{max}\\) is equal to 0, we consider that the completeness predictor \\(c(t)\\) is also equal to 0.</p> <pre><code>from edsteva.probes import NoteProbe\n\nnote = Note(completeness_predictor=\"per_note_default\")\nnote.compute(\n    data,\n    stay_types={\n        \"Urg\": \"urgence\",\n        \"Hospit\": \"hospitalis\u00e9s\",\n        \"Urg_Hospit\": \"urgence|hospitalis\u00e9s\",\n    },\n    note_types={\n        \"All\": \".*\",\n        \"CRH\": \"crh\",\n        \"Ordonnance\": \"ordo\",\n        \"CR Passage Urgences\": \"urge\",\n    },\n)\nnote.predictor.head()\n</code></pre> care_site_level care_site_id care_site_short_name stay_type note_type date n_note c Unit\u00e9 Fonctionnelle (UF) 8312056386 Care site 1 'Urg' 'All' 2019-05-01 233.0 0.841 Unit\u00e9 Fonctionnelle (UF) 8653815660 Care site 1 'Hospit' 'CRH' 2017-04-01 393.0 0.640 P\u00f4le/DMU 8312027648 Care site 2 'Hospit' 'CRH' 2021-03-01 204.0 0.497 P\u00f4le/DMU 8312056379 Care site 2 'Urg' 'Ordonnance' 2018-08-01 22.0 0.274 H\u00f4pital 8312022130 Care site 3 'Urg_Hospit' 'CR Passage Urgences' 2022-02-01 9746.0 0.769 <p>The <code>ConditionProbe</code> computes \\(c_{condition}(t)\\) the availability of claim data:</p> per_visit_defaultper_condition_default <p>The <code>per_visit_default</code> algorithm computes \\(c_(t)\\) the availability of claim data linked to patients' administrative stays:</p> \\[ c(t) = \\frac{n_{with\\,condition}(t)}{n_{visit}(t)} \\] <p>Where \\(n_{visit}(t)\\) is the number of administrative stays, \\(n_{with\\,condition}\\) the number of stays having at least one claim code (e.g. ICD-10) recorded and \\(t\\) is the month.</p> <p>If the number of visits \\(n_{visit}(t)\\) is equal to 0, we consider that the completeness predictor \\(c(t)\\) is also equal to 0.</p> <p>Care site level</p> <p>AREM claim data are only available at hospital level.</p> <pre><code>from edsteva.probes import ConditionProbe\n\ncondition = ConditionProbe(completeness_predictor=\"per_visit_default\")\ncondition.compute(\n    data,\n    stay_types={\n        \"Hospit\": \"hospitalis\u00e9s\",\n    },\n    diag_types={\n        \"All\": \".*\",\n        \"DP/DR\": \"DP|DR\",\n    },\n    condition_types={\n        \"All\": \".*\",\n        \"Pulmonary_embolism\": \"I26\",\n    },\n    source_systems=[\"AREM\", \"ORBIS\"],\n)\ncondition.predictor.head()\n</code></pre> care_site_level care_site_id care_site_short_name stay_type diag_type condition_type source_systems date n_visit n_visit_with_condition c H\u00f4pital 8312057527 Care site 1 'Hospit' 'All' 'Pulmonary_embolism' AREM 2019-05-01 233.0 196.0 0.841 H\u00f4pital 8312057527 Care site 1 'Hospit' 'DP/DR' 'Pulmonary_embolism' AREM 2021-04-01 393.0 252.0 0.640 H\u00f4pital 8312027648 Care site 2 'Hospit' 'All' 'Pulmonary_embolism' AREM 2017-03-01 204.0 101.0 0.497 Unit\u00e9 Fonctionnelle (UF) 8312027648 Care site 2 'Hospit' 'All' 'All' ORBIS 2018-08-01 22.0 6.0 0.274 P\u00f4le/DMU 8312022130 Care site 3 'Hospit' 'DP/DR' 'Pulmonary_embolism' ORBIS 2022-02-01 9746.0 7495.0 0.769 <p>The <code>per_condition_default</code> algorithm computes \\(c_(t)\\) the availability of claim data as follow:</p> \\[ c(t) = \\frac{n_{condition}(t)}{n_{max}} \\] <p>Where \\(n_{condition}(t)\\) is the number of claim codes (e.g. ICD-10) recorded, \\(t\\) is the month and \\(n_{max} = \\max_{t}(n_{condition}(t))\\).</p> <p>If the maximum number of recorded diagnosis per month \\(n_{max}\\) is equal to 0, we consider that the completeness predictor \\(c(t)\\) is also equal to 0.</p> <pre><code>from edsteva.probes import ConditionProbe\n\ncondition = ConditionProbe(completeness_predictor=\"per_condition_default\")\ncondition.compute(\n    data,\n    stay_types={\n        \"All\": \".*\",\n        \"Hospit\": \"hospitalis\u00e9s\",\n    },\n    diag_types={\n        \"All\": \".*\",\n        \"DP/DR\": \"DP|DR\",\n    },\n    condition_types={\n        \"All\": \".*\",\n        \"Pulmonary_embolism\": \"I26\",\n    },\n    source_systems=[\"AREM\", \"ORBIS\"],\n)\ncondition.predictor.head()\n</code></pre> care_site_level care_site_id care_site_short_name stay_type diag_type condition_type source_systems date n_condition c H\u00f4pital 8312057527 Care site 1 'Hospit' 'All' 'Pulmonary_embolism' AREM 2019-05-01 233.0 0.841 H\u00f4pital 8312057527 Care site 1 'Hospit' 'DP/DR' 'Pulmonary_embolism' AREM 2021-04-01 393.0 0.640 H\u00f4pital 8312027648 Care site 2 'Hospit' 'All' 'Pulmonary_embolism' AREM 2017-03-01 204.0 0.497 Unit\u00e9 Fonctionnelle (UF) 8312027648 Care site 2 'Hospit' 'All' 'All' ORBIS 2018-08-01 22.0 0.274 P\u00f4le/DMU 8312022130 Care site 3 'Hospit' 'DP/DR' 'Pulmonary_embolism' ORBIS 2022-02-01 9746.0 0.769 <p>The <code>BiologyProbe</code> computes \\(c_(t)\\) the availability of laboratory data:</p> per_visit_defaultper_measurement_default <p>The <code>per_visit_default</code> algorithm computes \\(c_(t)\\) the availability of laboratory data linked to patients' administrative stays:</p> \\[ c(t) = \\frac{n_{with\\,biology}(t)}{n_{visit}(t)} \\] <p>Where \\(n_{visit}(t)\\) is the number of administrative stays, \\(n_{with\\,biology}\\) the number of stays having at least one biological measurement recorded and \\(t\\) is the month.</p> <p>If the number of visits \\(n_{visit}(t)\\) is equal to 0, we consider that the completeness predictor \\(c(t)\\) is also equal to 0.</p> <p>Care site level</p> <p>Laboratory data are only available at hospital level.</p> <pre><code>from edsteva.probes import BiologyProbe\n\nbiology = BiologyProbe(completeness_predictor=\"per_visit_default\")\nbiology.compute(\n    data,\n    stay_types={\n        \"Hospit\": \"hospitalis\u00e9s\",\n    },\n    concepts_sets={\n        \"Cr\u00e9atinine\": \"E3180|G1974|J1002|A7813|A0094|G1975|J1172|G7834|F9409|F9410|C0697|H4038|F2621\",\n        \"Leucocytes\": \"A0174|K3232|H6740|E4358|C9784|C8824|E6953\",\n    },\n)\nbiology.predictor.head()\n</code></pre> care_site_level care_site_id care_site_short_name stay_type concepts_sets date n_visit n_visit_with_measurement c H\u00f4pital 8312057527 Care site 1 'Hospit' 'Cr\u00e9atinine' 2019-05-01 233.0 196.0 0.841 H\u00f4pital 8312057527 Care site 1 'Hospit' 'Leucocytes' 2021-04-01 393.0 252.0 0.640 H\u00f4pital 8312027648 Care site 2 'Hospit' 'Cr\u00e9atinine' 2017-03-01 204.0 101.0 0.497 H\u00f4pital 8312027648 Care site 2 'Hospit' 'Leucocytes' 2018-08-01 22.0 6.0 0.274 H\u00f4pital 8312022130 Care site 3 'Hospit' 'Leucocytes' 2022-02-01 9746.0 7495.0 0.769 <p>The <code>per_measurement_default</code> algorithm computes \\(c_(t)\\) the availability of biological measurements:</p> \\[ c(t) = \\frac{n_{biology}(t)}{n_{max}} \\] <p>Where \\(n_{biology}(t)\\) is the number of biological measurements, \\(t\\) is the month and \\(n_{max} = \\max_{t}(n_{biology}(t))\\).</p> <p>If the maximum number of recorded biological measurements per month \\(n_{max}\\) is equal to 0, we consider that the completeness predictor \\(c(t)\\) is also equal to 0.</p> <p>Care site level</p> <p>Laboratory data are only available at hospital level.</p> <pre><code>from edsteva.probes import BiologyProbe\n\nbiology = BiologyProbe(completeness_predictor=\"per_measurement_default\")\nbiology.compute(\n    data,\n    stay_types={\n        \"Hospit\": \"hospitalis\u00e9s\",\n    },\n    concepts_sets={\n        \"Cr\u00e9atinine\": \"E3180|G1974|J1002|A7813|A0094|G1975|J1172|G7834|F9409|F9410|C0697|H4038|F2621\",\n        \"Leucocytes\": \"A0174|K3232|H6740|E4358|C9784|C8824|E6953\",\n    },\n)\nbiology.predictor.head()\n</code></pre> care_site_level care_site_id care_site_short_name stay_type concepts_sets date n_measurement c H\u00f4pital 8312057527 Care site 1 'Hospit' 'Cr\u00e9atinine' 2019-05-01 233.0 0.841 H\u00f4pital 8312057527 Care site 1 'Hospit' 'Leucocytes' 2021-04-01 393.0 0.640 H\u00f4pital 8312027648 Care site 2 'Hospit' 'Cr\u00e9atinine' 2017-03-01 204.0 0.497 Unit\u00e9 Fonctionnelle (UF) 8312027648 Care site 2 'Hospit' 'Leucocytes' 2018-08-01 22.0 0.274 P\u00f4le/DMU 8312022130 Care site 3 'Hospit' 'Leucocytes' 2022-02-01 9746.0 0.769 StepFunctionRectangleFunction CoefficientsMetricsAlgosExample <p>The <code>StepFunction</code> fits a step function \\(f_{t_0, c_0}(t)\\) with coefficients \\(\\Theta = (t_0, c_0)\\) on a completeness predictor \\(c(t)\\):</p> \\[ \\begin{aligned} f_{t_0, c_0}(t) &amp; = c_0 \\ \\mathbb{1}_{t \\geq t_0}(t) \\\\ c(t) &amp; = f_{t_0, c_0}(t) + \\epsilon(t) \\end{aligned} \\] <ul> <li>the characteristic time \\(t_0\\) estimates the time after which the data is available.</li> <li>the characteristic value \\(c_0\\) estimates the stabilized routine completeness.</li> </ul> <p>The default metric computed is the mean squared error after \\(t_0\\):</p> \\[ error = \\frac{\\sum_{t_0 \\leq  t \\leq t_{max}} \\epsilon(t)^2}{t_{max} - t_0} \\] <ul> <li>\\(error\\) estimates the stability of the data after \\(t_0\\).</li> </ul> <p>Custom metric<p>You can define your own metric if this one doesn't meet your requirements.</p> </p> <p>The available algorithms used to fit the step function are listed below:</p> <p>Custom algo<p>You can define your own algorithm if they don't meet your requirements.</p> </p> Loss minimizationQuantile <p>This algorithm computes the estimated coefficients \\(\\hat{t_0}\\) and \\(\\hat{c_0}\\) by minimizing the loss function \\(\\mathcal{L}(t_0, c_0)\\):</p> \\[ \\begin{aligned} \\mathcal{L}(t_0, c_0) &amp; = \\frac{\\sum_{t = t_{min}}^{t_{max}} \\mathcal{l}(c(t), f_{t_0, c_0}(t))}{t_{max} - t_{min}} \\\\ (\\hat{t_0}, \\hat{c_0}) &amp; = \\underset{t_0, c_0}{\\mathrm{argmin}}(\\mathcal{L}(t_0, c_0)) \\\\ \\end{aligned} \\] <p>Default loss function \\(\\mathcal{l}\\)</p> <p>The loss function is \\(l_2\\) by default: $$ \\mathcal{l}(c(t), f_{t_0, c_0}(t)) = |c(t) - f_{t_0, c_0}(t)|^2 $$</p> <p>Optimal estimates</p> <p>For complexity purposes, this algorithm has been implemented with a dependency relation between \\(c_0\\) and \\(t_0\\) derived from the optimal estimates using the \\(l_2\\) loss function. For more informations, you can have a look on the source code.</p> <p>In this algorithm, \\(\\hat{c_0}\\) is directly estimated as the \\(x^{th}\\) quantile of the completeness predictor \\(c(t)\\), where \\(x\\) is a number between 0 and 1. Then, \\(\\hat{t_0}\\) is the first time \\(c(t)\\) reaches \\(\\hat{c_0}\\).</p> \\[ \\begin{aligned} \\hat{c_0} &amp; = x^{th} \\text{ quantile of } c(t) \\\\ \\hat{t_0} &amp; = \\underset{t}{\\mathrm{argmin}}(c(t) \\geq \\hat{c_0}) \\end{aligned} \\] <p>Default quantile \\(x\\)</p> <p>The default quantile is \\(x = 0.8\\).</p> <pre><code>from edsteva.models.step_function import StepFunction\n\nstep_function_model = StepFunction()\nstep_function_model.fit(probe)\nstep_function_model.estimates.head()\n</code></pre> care_site_level care_site_id stay_type t_0 c_0 error Unit\u00e9 Fonctionnelle (UF) 8312056386 'Urg' 2019-05-01 0.397 0.040 Unit\u00e9 Fonctionnelle (UF) 8312056386 'All' 2017-04-01 0.583 0.028 P\u00f4le/DMU 8312027648 'Hospit' 2021-03-01 0.677 0.022 P\u00f4le/DMU 8312027648 'All' 2018-08-01 0.764 0.014 H\u00f4pital 8312022130 'Hospit' 2022-02-01 0.652 0.027 CoefficientsMetricsAlgosExample <p>The <code>RectangleFunction</code> fits a step function \\(f_{t_0, c_0, t_1}(t)\\) with coefficients \\(\\Theta = (t_0, c_0, t_1)\\) on a completeness predictor \\(c(t)\\):</p> \\[ \\begin{aligned} f_{t_0, c_0, t_1}(t) &amp; = c_0 \\ \\mathbb{1}_{t_0 \\leq t \\leq t_1}(t) \\\\ c(t) &amp; = f_{t_0, c_0, t_1}(t) + \\epsilon(t) \\end{aligned} \\] <ul> <li>the characteristic time \\(t_0\\) estimates the time after which the data is available.</li> <li>the characteristic time \\(t_1\\) estimates the time after which the data is not available anymore.</li> <li>the characteristic value \\(c_0\\) estimates the completeness between \\(t_0\\) and \\(t_1\\).</li> </ul> <p>The default metric computed is the mean squared error between \\(t_0\\) and \\(t_1\\):</p> \\[ error = \\frac{\\sum_{t_0 \\leq  t \\leq t_1} \\epsilon(t)^2}{t_1 - t_0} \\] <ul> <li>\\(error\\) estimates the stability of the data between \\(t_0\\) and \\(t_1\\).</li> </ul> <p>Custom metric<p>You can define your own metric if this one doesn't meet your requirements.</p> </p> <p>The available algorithms used to fit the step function are listed below:</p> <p>Custom algo<p>You can define your own algorithm if they don't meet your requirements.</p> </p> Loss minimization <p>This algorithm computes the estimated coefficients \\(\\hat{t_0}\\), \\(\\hat{c_0}\\) and \\(\\hat{t_1}\\) by minimizing the loss function \\(\\mathcal{L}(t_0, c_0, t_1)\\):</p> \\[ \\begin{aligned} \\mathcal{L}(t_0, c_0, t_1) &amp; = \\frac{\\sum_{t = t_{min}}^{t_{max}} \\mathcal{l}(c(t), f_{t_0, c_0, t_1}(t))}{t_{max} - t_{min}} \\\\ (\\hat{t_0}, \\hat{t_1}, \\hat{c_0}) &amp; = \\underset{t_0, c_0, t_1}{\\mathrm{argmin}}(\\mathcal{L}(t_0, c_0, t_1)) \\\\ \\end{aligned} \\] <p>Default loss function \\(\\mathcal{l}\\)</p> <p>The loss function is \\(l_2\\) by default: $$ \\mathcal{l}(c(t), f_{t_0, c_0, t_1}(t)) = |c(t) - f_{t_0, c_0, t_1}(t)|^2 $$</p> <p>Optimal estimates</p> <p>For complexity purposes, this algorithm has been implemented with a dependency relation between \\(c_0\\) and \\(t_0\\) derived from the optimal estimates using the \\(l_2\\) loss function. For more informations, you can have a look on the source code.</p> <pre><code>from edsteva.models.rectangle_function import RectangleFunction\n\nrectangle_function_model = RectangleFunction()\nrectangle_function_model.fit(probe)\nrectangle_function_model.estimates.head()\n</code></pre> care_site_level care_site_id stay_type t_0 c_0 t_1 error Unit\u00e9 Fonctionnelle (UF) 8312056386 'Urg' 2019-05-01 0.397 2020-05-01 0.040 Unit\u00e9 Fonctionnelle (UF) 8312056386 'All' 2017-04-01 0.583 2013-04-01 0.028 P\u00f4le/DMU 8312027648 'Hospit' 2021-03-01 0.677 2022-03-01 0.022 P\u00f4le/DMU 8312027648 'All' 2018-08-01 0.764 2019-08-01 0.014 H\u00f4pital 8312022130 'Hospit' 2022-02-01 0.652 2022-08-01 0.027 DashboardPlot <p>The library provides interactive dashboards that let you set any combination of care sites, stay types and other columns if included in the Probe. You can only export a dashboard in HTML format.</p> probe_dashboard()normalized_probe_dashboard() <p>The <code>probe_dashboard()</code> returns:</p> <ul> <li>On the top, the aggregated variable is the average completeness predictor \\(c(t)\\) over time \\(t\\) with the prediction \\(\\hat{c}(t)\\) if the fitted Model is specified.</li> <li>On the bottom, the interactive filters are all the columns included in the Probe (such as time, care site, number of visits...etc.).</li> </ul> <p><pre><code>from edsteva.viz.dashboards import probe_dashboard\n\nprobe_dashboard(\n    probe=probe,\n    fitted_model=step_function_model,\n    care_site_level=care_site_level,\n)\n</code></pre> An example is available here.</p> <p>The <code>normalized_probe_dashboard()</code> returns a representation of the overall deviation from the Model:</p> <ul> <li>On the top, the aggregated variable is a normalized completeness predictor \\(\\frac{c(t)}{c_0}\\) over normalized time \\(t - t_0\\).</li> <li>On the bottom, the interactive filters are all the columns included in the Probe (such as time, care site, number of visits...etc.) with all the Model coefficients and metrics included in the Model.</li> </ul> <pre><code>from edsteva.viz.dashboards import normalized_probe_dashboard\n\nnormalized_probe_dashboard(\n    probe=probe,\n    fitted_model=step_function_model,\n    care_site_level=care_site_level,\n)\n</code></pre> <p>An example is available here.</p> <p>The library provides static plots that you can export in png or svg. As it is less interactive, you may specify the filters in the inputs of the functions.</p> probe_plot()normalized_probe_plot()estimates_densities_plot() <p>The <code>probe_plot()</code> returns the top plot of the <code>probe_dashboard()</code>: the normalized completeness predictor \\(\\frac{c(t)}{c_0}\\) over normalized time \\(t - t_0\\).</p> <pre><code>from edsteva.viz.plots import probe_plot\n\nprobe_plot(\n    probe=probe,\n    fitted_model=step_function_model,\n    care_site_level=care_site_level,\n    stay_type=stay_type,\n    save_path=plot_path,\n)\n</code></pre> <p>{ \"schema-url\": \"assets/charts/fitted_visit.json\" }</p> <p>The <code>normalized_probe_plot()</code> returns the top plot of the <code>normalized_probe_dashboard()</code>. Consequently, you have to specify the filters in the inputs of the function.</p> <p><pre><code>from edsteva.viz.plots import normalized_probe_plot\n\nnormalized_probe_plot(\n    probe=probe,\n    fitted_model=step_function_model,\n    t_min=-15,\n    t_max=15,\n    save_path=plot_path,\n)\n</code></pre> { \"schema-url\": \"assets/charts/normalized_probe.json\" }</p> <p>The <code>estimates_densities_plot()</code> returns the density plot and the median of each estimate. It can help you to set the thresholds.</p> <p><pre><code>from edsteva.viz.plots import estimates_densities_plot\n\nestimates_densities_plot(\n    fitted_model=step_function_model,\n)\n</code></pre> { \"schema-url\": \"assets/charts/estimates_densities.json\" }</p> <ol> <li> <p>Samuel G Finlayson, Adarsh Subbaswamy, Karandeep Singh, John Bowers, Annabel Kupke, Jonathan Zittrain, Isaac S Kohane, and Suchi Saria. The clinician and dataset shift in artificial intelligence. The New England journal of medicine, 385(3):283, 2021.\u00a0\u21a9</p> </li> </ol>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#v025-10-08-2023","title":"v0.2.5 - 10-08-2023","text":"<ul> <li>New Probe parameters:</li> <li>Age range: Age of patient at visit</li> <li>Provenance source: Where the patient came from before the visit (emergency, consultation, etc.)</li> <li>stay source: Type of care (MCO, PSY, SSY)</li> <li>Refacto the params type to make it more uniform.</li> </ul>"},{"location":"changelog/#v024-28-07-2023","title":"v0.2.4 - 28-07-2023","text":"<ul> <li>Viz: Simplify normalized probe plot</li> </ul>"},{"location":"changelog/#v023-04-07-2023","title":"v0.2.3 - 04-07-2023","text":"<ul> <li>Viz: Fix dashboards</li> </ul>"},{"location":"changelog/#v022-03-07-2023","title":"v0.2.2 - 03-07-2023","text":"<ul> <li>Viz: Fix normalized probe</li> </ul>"},{"location":"changelog/#v021-03-07-2023","title":"v0.2.1 - 03-07-2023","text":"<ul> <li>Linting: Improve code style with ruff.</li> </ul>"},{"location":"changelog/#v020-30-06-2023","title":"v0.2.0 - 30-06-2023","text":"<ul> <li>BiologyProbe: Create a brand new probe for biology data.</li> <li>Registry: Introduce registry for completeness predictor and visualization.</li> <li>Altair: Upgrade to v5.</li> <li>Tests: Improve coverage to 99%.</li> </ul>"},{"location":"changelog/#v014-02-02-2023","title":"v0.1.4 - 02-02-2023","text":"<ul> <li>ConditionProbe: Take UF and Pole into account for ORBIS source system.</li> <li>Binder: Presentation available.</li> </ul>"},{"location":"changelog/#v013-22-12-2022","title":"v0.1.3 - 22-12-2022","text":"<ul> <li>ConditionProbe: Update, computed as a proportion of number of visit.</li> </ul>"},{"location":"changelog/#v012-14-12-2022","title":"v0.1.2 - 14-12-2022","text":"<ul> <li>ConditionProbe computes the availability of administrative data related to visits with at least one ICD-10 code recorded.</li> </ul>"},{"location":"changelog/#v011-03-12-2022","title":"v0.1.1 - 03-12-2022","text":"<ul> <li>Binder Demo available</li> </ul>"},{"location":"changelog/#v010-29-11-2022","title":"v0.1.0 - 29-11-2022","text":"<ul> <li>Initial release</li> </ul>"},{"location":"contributing/","title":"Contributing","text":"<p>We welcome contributions ! There are many ways to help. For example, you can:</p> <ul> <li>Help us track bugs by filing issues.</li> <li>Suggest and help prioritize new functionalities.</li> <li>Develop a new Probe or a new Model ! Fork the project and propose a new functionality through a pull request.</li> <li>Help us make the library as straightforward as possible, by simply asking questions on whatever does not seem clear to you.</li> </ul>"},{"location":"contributing/#guidelines","title":"Guidelines","text":""},{"location":"contributing/#1-development-installation","title":"1. Development installation","text":"<p>Ready to contribute? Here's how to set up <code>edsteva</code> for local development.</p> <ul> <li>Fork the <code>edsteva</code> repo.</li> <li> <p>Clone your fork locally:</p> <pre><code>$ git clone git@github.com:your_name_here/edsteva.git\n---&gt; 100%\n</code></pre> </li> <li> <p>Optional, create a virtual environment:</p> <pre><code>$ cd edsteva\n$ python -m venv .venv\n$ source .venv/bin/activate\n</code></pre> </li> <li> <p>Install Poetry (a tool for dependency management and packaging in Python):</p> Linux, macOS, Windows (WSL)Windows (Powershell) <p> <pre><code>$ curl -sSL https://install.python-poetry.org | python3 -\n---&gt; 100%\n</code></pre> </p> <p> <pre><code>$ (Invoke-WebRequest -Uri https://install.python-poetry.org -UseBasicParsing).Content | py -\n---&gt; 100%\n</code></pre> </p> <p>For more details, check the installation guide</p> </li> <li> <p>Install dependencies:</p> <pre><code>$ poetry install --only docs\n$ poetry config experimental.new-installer false\n$ poetry install\n\ncolor:lightblue Updating dependencies\ncolor:lightblue Resolving dependencies... (25.3s)\n\ncolor:lightblue Writing lock file\n\nPackage operations: 126 installs, 0 updates, 0 removals\n\n\u2022 Installing ....\n\u2022 Installing ....\n</code></pre> </li> <li> <p>Create a branch for local development:</p> <pre><code>$ git checkout -b name-of-your-bugfix-or-feature\n</code></pre> </li> </ul>"},{"location":"contributing/#2-style-guide","title":"2. Style guide","text":"<p>We use Black to reformat the code. While other formatter only enforce PEP8 compliance, Black also makes the code uniform.</p> <p>Tip</p> <p>Black reformats entire files in place. It is not configurable.</p> <p>Moreover, the CI/CD pipeline enforces a number of checks on the \"quality\" of the code. To wit, non black-formatted code will make the test pipeline fail. To make sure the pipeline will not fail because of formatting errors, we added pre-commit hooks using the <code>pre-commit</code> Python library. To use it, simply install it:</p> <pre><code>$ pre-commit install\n</code></pre> <p>The pre-commit hooks defined in the configuration will automatically run when you commit your changes, letting you know if something went wrong.</p> <p>The hooks only run on staged changes. To force-run it on all files, run:</p> <pre><code>$ pre-commit run --all-files\n---&gt; 100%\nAll good !\n</code></pre>"},{"location":"contributing/#3-testing-your-code","title":"3. Testing your code","text":"<p>We use the Pytest test suite. Writing your own tests is encouraged !</p> <p>The following command will run the test suite:</p> <pre><code>$ poetry run pytest tests --cov edsteva --junitxml=report.xml\ncollected X items\n\ntests/test_a.py\ntests/test_b.py\ntests/test_your_bug.py\n---&gt; 100%\n</code></pre> <p>Should your contribution propose a bug fix, we require the bug be thoroughly tested.</p>"},{"location":"contributing/#4-documentation","title":"4. Documentation","text":"<p>Make sure to document your improvements, both within the code with comprehensive docstrings, as well as in the documentation itself if need be.</p> <p>We use <code>MkDocs</code> for EDS-TeVa's documentation. You can checkout the changes you make with:</p> <pre><code>$ mkdocs serve\n</code></pre> <p>Go to <code>localhost:8000</code> to see your changes. MkDocs watches for changes in the documentation folder and automatically reloads the page.</p>"},{"location":"contributing/#5-proposing-a-merge-request","title":"5. Proposing a merge request","text":"<p>At the very least, if your changes are well-documented, pass every tests, and follow the style guide, you can:</p> <ul> <li> <p>Commit your changes and push your branch:</p> <pre><code>$ git add *\n$ git commit -m \"Your detailed description of your changes.\"\n$ git push origin name-of-your-bugfix-or-feature\n</code></pre> </li> <li> <p>Submit a pull request.</p> </li> </ul>"},{"location":"components/loading_data/","title":"Loading data","text":"<p>Here is a tutorial for loading your data which is the first step in the EDS-TeVa usage workflow.</p> <pre><code>import os\nfrom datetime import datetime\n</code></pre> <p>3 classes are available to facilitate data access:</p> <ul> <li><code>HiveData</code>: Getting data from a Hive cluster, returning <code>Koalas</code> DataFrames.</li> <li><code>LocalData</code>: Getting data from tables saved on disk, returning <code>Pandas</code> DataFrames.</li> <li><code>PostgresData</code>: Getting data from a PostGreSQL DB, returning <code>Pandas</code> DataFrames.</li> </ul> <pre><code>from edsteva.io import HiveData, LocalData, PostgresData\n</code></pre> <p>Using Spark kernels</p> <p>All kernels designed to use Spark are configured to expose 3 variables at startup:  </p> <ul> <li><code>spark</code>, the current SparkSession</li> <li><code>sc</code>, the current SparkContext</li> <li><code>sql</code>, a function to execute SQL code on the Hive Database.  </li> </ul> <p>In this case you can just provide the <code>spark</code> variable to <code>HiveData</code> !</p> <p>If needed, the following snippet allows to create the necessary variables:</p> <pre><code>from pyspark import SparkConf, SparkContext\nfrom pyspark.sql.session import SparkSession\n\nconf = SparkConf()\nsc = SparkContext(conf=conf)\nspark = SparkSession.builder \\\n                    .enableHiveSupport() \\\n                    .getOrCreate()\nsql = spark.sql\n</code></pre> <p>Alternatively, we propose an all-in-one function that creates the necessary variables adequately configured to use Koalas.</p> <pre><code>from edsteva import improve_performances\n\nspark, sc, sql = improve_performances()\n</code></pre> <p>The class <code>HiveData</code> provides a convenient interface to OMOP data stored in Hive. The OMOP tables can be accessed as attribute and they are represented as Koalas DataFrames. You simply need to mention your Hive database name.</p> <pre><code>db_name = \"my_db\"\ndata = HiveData(\n    database_name=db_name,\n    spark_session=spark\n    )\n</code></pre> <p>By default, only a subset of tables are added as attributes:</p> <pre><code>data.available_tables\n</code></pre> <pre>\n<code>['care_site',\n 'concept',\n 'condition_occurrence',\n 'person',\n 'procedure_occurrence',\n 'visit_detail',\n 'visit_occurrence']</code>\n</pre> <p><code>Koalas</code> DataFrames, like <code>Spark</code> DataFrames, rely on a lazy execution plan: As long as no data needs to be specifically collected, saved or displayed, no code is executed. It is simply saved for a later execution. The main interest of Koalas DataFrames is that you can use (most of) the Pandas API:</p> <pre><code>person = data.person\nperson.drop(columns = ['person_id']).head()\n</code></pre> location_id year_of_birth month_of_birth day_of_birth birth_datetime death_datetime gender_source_value gender_source_concept_id cdm_source 0 3347087777 1949 8 2 1949-08-02 NaT f 2008119903 ORBIS 1 9818741928 1975 7 6 1975-07-06 NaT m 2008119900 ORBIS 2 3345464435 1990 9 7 1990-09-07 NaT f 2008119903 ORBIS 3 3346060919 1964 5 18 1964-05-18 NaT f 2008119903 ORBIS 4 3347197472 1990 2 2 1990-02-02 NaT m 2008119900 ORBIS <pre><code>person['is_over_50'] = (person['birth_datetime'] &gt;= datetime(1971,1,1))\n\nstats = (\n    person\n    .groupby('is_over_50')\n    .person_id\n    .count()\n)\n</code></pre> <p>Once data has been sufficiently aggregated, it can be converted back to Pandas, e.g. for plotting.</p> <pre><code>stats_pd = stats.to_pandas()\n</code></pre> <p>Similarily, if you want to work on the <code>Spark</code> DataFrame instead, a similar method is available:</p> <pre><code>person_spark = person.to_spark()\n</code></pre> <p>Careful with cohort size</p> <p>Do not save it if your cohort is big: This saves all available tables on disk.</p> <p>For instance, let us define a dummy subset of 1000 patients:</p> <pre><code>visits = data.visit_occurrence\n\nselected_visits = (\n    visits\n    .loc[visits[\"stay_source_value\"] == \"MCO\"]\n)\n\nsample_patients = (\n    selected_visits[\"person_id\"]\n    .drop_duplicates()\n    .head(1000)\n    .to_list()\n)\n</code></pre> <p>And save every table restricted to this small cohort as a <code>parquet</code> file:</p> <pre><code>folder= os.path.abspath(MY_FOLDER_PATH)\nos.makedirs(folder, exist_ok=True)\n\ntables_to_save = [\"person\", \"visit_detail\", \"visit_occurrence\"]\n\ndata.persist_tables_to_folder(folder, \n                              tables=tables_to_save,\n                              person_ids=sample_patients)\n</code></pre> <p>Once you saved some data to disk, a dedicated class can be used to access it: The class <code>LocalData</code> can be used to load OMOP data from a folder containing several parquet files. The tables are accessed as attributes and are returned as Pandas DataFrame.</p> <p>Warning</p> <p>In this case, the whole table will be loaded into memory on a single jupyter server. Consequently it is advised to only use this for small datasets.</p> <pre><code>data = LocalData(folder)\n</code></pre> <pre><code>data.available_tables\n</code></pre> <pre>\n<code>['visit_occurrence', 'visit_detail', 'person']</code>\n</pre> <pre><code>person = data.person\nprint(f\"type: {type(person)}\")\nprint(f\"shape: {person.shape}\")\n</code></pre> <pre>\n<code>type: &lt;class 'pandas.core.frame.DataFrame'&gt;\nshape: (1000, 10)\n</code>\n</pre> <pre><code>data = PostgresData(dbname=DB, \n                    schema=\"omop\", \n                    user=USER)\ndata.read_sql(\"select count(*) from person\")\n</code></pre> count 0 12688670"},{"location":"components/loading_data/#loading-data","title":"Loading Data","text":""},{"location":"components/loading_data/#loading-from-hive-hivedata","title":"Loading from Hive: <code>HiveData</code>","text":"<p>The <code>HiveData</code> class expects two parameters:  </p> <ul> <li>A <code>SparkSession</code> variable</li> <li>The name of the Database to connect to</li> </ul>"},{"location":"components/loading_data/#persistingreading-a-sample-tofrom-disk-localdata","title":"Persisting/Reading a sample to/from disk: <code>LocalData</code>","text":"<p>Working with Pandas DataFrame is, when possible, more convenient. You have the possibility to save your database or at least a subset of it. Doing so allows you to work on it later without having to go through <code>Spark</code> again.  </p>"},{"location":"components/loading_data/#loading-from-postgres-postgresdata","title":"Loading from PostGres: <code>PostgresData</code>","text":"<p>OMOP data can be stored in a PostreSQL database. The <code>PostgresData</code> class provides a convinient interface to it.</p> <p>Note</p> <p>This class relies on the file <code>~/.pgpass</code> that contains your identifiers for several databases.</p>"},{"location":"components/model/","title":"Model","text":"<p>Choosing or customizing a Model is the third step in the EDS-TeVa usage workflow.</p>"},{"location":"components/model/#definition","title":"Definition","text":"<p>A Model is a python class designed to characterize the temporal variability of data availability. It estimates the coefficients \\(\\Theta\\) and the metrics from a Probe.</p> <p> </p> Model class diagram"},{"location":"components/model/#input","title":"Input","text":"<p>The Model class is expecting a <code>Probe</code> object in order to estimate the Model coefficients \\(\\Theta\\) and some metrics if desired.</p>"},{"location":"components/model/#attributes","title":"Attributes","text":"<ul> <li><code>estimates</code> is a <code>Pandas.DataFrame</code> computed by the <code>fit()</code> method. It contains the estimated coefficients \\(\\Theta\\) and metrics for each column given by the <code>Probe._index</code> (e.g. care site, stay type, etc.).</li> <li><code>_coefs</code> is the list of the Model coefficients \\(\\Theta\\) that are estimated by the <code>fit()</code> method.</li> </ul>"},{"location":"components/model/#methods","title":"Methods","text":"<ul> <li><code>fit()</code> method calls the <code>fit_process()</code> method to compute the estimated coefficients \\(\\Theta\\) and metrics and store them in the <code>estimates</code> attribute.</li> <li><code>fit_process()</code> method computes the estimated coefficients \\(\\Theta\\) and metrics from a <code>Probe.predictor</code> DataFrame.</li> <li><code>predict()</code> method applies the <code>predict_process()</code> on a <code>Probe.predictor</code> DataFrame and returns a <code>Pandas.DataFrame</code> of the estimated prediction \\(\\hat{c}(t)\\) for each columns given by <code>Probe._index</code>.</li> <li><code>predict_process()</code> method computes the estimated completeness predictor \\(\\hat{c}(t)\\) for each column given by <code>Probe._index</code>.</li> <li><code>save()</code> method saves the <code>Model</code> in the desired path. By default it is saved in the cache directory (~/.cache/edsteva/models).</li> <li><code>load()</code> method loads the <code>Model</code> from the desired path. By default it is loaded from the cache directory (~/.cache/edsteva/models).</li> </ul> <p>Prediction</p> <p><code>predict()</code> method must be called on a fitted Model.</p>"},{"location":"components/model/#estimates-schema","title":"Estimates schema","text":"<p>Data stored in the <code>estimates</code> attribute follows a specific schema:</p>"},{"location":"components/model/#indexes","title":"Indexes","text":"<p>The estimates are computed for each column given by the <code>Probe._index</code>. For example, if you fit your Model on the <code>VisitProbe</code>, the estimates will be computed for each:</p> <ul> <li><code>care_site_level</code>: care site hierarchic level (<code>uf</code>, <code>pole</code>, <code>hospital</code>).</li> <li><code>care_site_id</code>: care site unique identifier.</li> <li><code>stay_type</code>: type of stay (<code>hospitalis\u00e9s</code>, <code>urgence</code>, <code>hospitalisation incompl\u00e8te</code>, <code>consultation externe</code>).</li> </ul>"},{"location":"components/model/#model-coefficients","title":"Model coefficients","text":"<p>It depends on the Model used, for instance the step function Model has 2 coefficients:</p> <ul> <li>\\(t_0\\) the characteristic time that estimates the time the after which the data is available.</li> <li>\\(c_0\\) the characteristic completeness that estimates the stabilized routine completeness after \\(t_0\\).</li> </ul>"},{"location":"components/model/#metrics","title":"Metrics","text":"<p>It depends on the metrics you specify in the <code>fit()</code> method. For instance, you can specify an \\(error\\) metric:</p> \\[ error = \\frac{\\sum_{t_0 \\leq  t \\leq t_{max}} \\epsilon(t)^2}{t_{max} - t_0} \\] <ul> <li>\\(error\\) estimates the stability of the data after \\(t_0\\).</li> </ul>"},{"location":"components/model/#example","title":"Example","text":"<p>When considering the <code>StepFunction.estimates</code> fitted on a <code>VisitProbe</code>, it may for instance look like this:</p> care_site_level care_site_id stay_type t_0 c_0 error Unit\u00e9 Fonctionnelle (UF) 8312056386 'Urg' 2019-05-01 0.397 0.040 P\u00f4le/DMU 8653815660 'All' 2011-04-01 0.583 0.028 Unit\u00e9 Fonctionnelle (UF) 8312027648 'Hospit' 2021-03-01 0.677 0.022 Unit\u00e9 Fonctionnelle (UF) 8312056379 'All' 2018-08-01 0.764 0.014 H\u00f4pital 8312022130 'Hospit' 2022-02-01 0.652 0.027"},{"location":"components/model/#saving-and-loading-a-fitted-model","title":"Saving and loading a fitted Model","text":"<p>In order to ease the future loading of a Model that has been fitted with the <code>fit()</code> method, one can pickle it using the <code>save()</code> method. This enables a rapid loading of the Model from local disk using the <code>load()</code> method.</p> <pre><code>from edsteva.models import StepFunction\n\nmodel = StepFunction()\n\nmodel.fit(probe)  # (1)\nmodel.save()  # (2)\n\nmodel_2 = StepFunction()\nmodel_2.load()  # (3)\n</code></pre> <ol> <li>Computation of the estimates (long).</li> <li>Saving of the fitted Model on the local disk.</li> <li>Rapid loading of the fitted Model fom the local disk.</li> </ol>"},{"location":"components/model/#defining-a-custom-model","title":"Defining a custom Model","text":"<p>If none of the available Models meets your requirements, you may want to create your own. To define a custom Model class <code>CustomModel</code> that inherits from the abstract class <code>BaseModel</code> you'll have to implement the <code>fit_process()</code> and <code>predict_process()</code> methods (these methods are respectively called by the <code>fit()</code> method and the <code>predict()</code> method inherited by the <code>BaseModel</code>  class). You'll also have to define the <code>_coefs</code> attribute which is the list of the Model coefficients.</p> <p><pre><code>from edsteva.models import BaseModel\nfrom edsteva.probes import BaseProbe\n\n\n# Definition of a new Model class\nclass CustomProbe(BaseModel):\n    _coefs = [\"my_model_coefficient_1\", \"my_model_coefficient_2\"]\n\n    def fit_process(self, probe: BaseProbe):\n        # fit process\n        return custom_predictor\n\n    def predict_process(self, probe: BaseProbe):\n        # predict process\n        return custom_predictor\n</code></pre> <code>fit_process()</code> and <code>predict_process()</code> methods take a Probe as the first argument. All other parameters must be keyword arguments. For a detailed example of the implementation of a Model, please have a look on the implemented <code>StepFunction</code> Model.</p> <p>Contributions</p> <p>If you managed to create your own Model do not hesitate to share it with the community by following the contribution guidelines. Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given.</p>"},{"location":"components/model/#available-models","title":"Available Models","text":"<p>We detail hereafter the step function Model that has already been implemented in the library.</p> StepFunctionRectangleFunction CoefficientsMetricsAlgosExample <p>The <code>StepFunction</code> fits a step function \\(f_{t_0, c_0}(t)\\) with coefficients \\(\\Theta = (t_0, c_0)\\) on a completeness predictor \\(c(t)\\):</p> \\[ \\begin{aligned} f_{t_0, c_0}(t) &amp; = c_0 \\ \\mathbb{1}_{t \\geq t_0}(t) \\\\ c(t) &amp; = f_{t_0, c_0}(t) + \\epsilon(t) \\end{aligned} \\] <ul> <li>the characteristic time \\(t_0\\) estimates the time after which the data is available.</li> <li>the characteristic value \\(c_0\\) estimates the stabilized routine completeness.</li> </ul> <p>The default metric computed is the mean squared error after \\(t_0\\):</p> \\[ error = \\frac{\\sum_{t_0 \\leq  t \\leq t_{max}} \\epsilon(t)^2}{t_{max} - t_0} \\] <ul> <li>\\(error\\) estimates the stability of the data after \\(t_0\\).</li> </ul> <p>Custom metric<p>You can define your own metric if this one doesn't meet your requirements.</p> </p> <p>The available algorithms used to fit the step function are listed below:</p> <p>Custom algo<p>You can define your own algo if they don't meet your requirements.</p> </p> Loss minimizationQuantile <p>This algorithm computes the estimated coefficients \\(\\hat{t_0}\\) and \\(\\hat{c_0}\\) by minimizing the loss function \\(\\mathcal{L}(t_0, c_0)\\):</p> \\[ \\begin{aligned} \\mathcal{L}(t_0, c_0) &amp; = \\frac{\\sum_{t = t_{min}}^{t_{max}} \\mathcal{l}(c(t), f_{t_0, c_0}(t))}{t_{max} - t_{min}} \\\\ (\\hat{t_0}, \\hat{c_0}) &amp; = \\underset{t_0, c_0}{\\mathrm{argmin}}(\\mathcal{L}(t_0, c_0)) \\\\ \\end{aligned} \\] <p>Default loss function \\(\\mathcal{l}\\)</p> <p>The loss function is \\(l_2\\) by default: $$ \\mathcal{l}(c(t), f_{t_0, c_0}(t)) = |c(t) - f_{t_0, c_0}(t)|^2 $$</p> <p>Optimal estimates</p> <p>For complexity purposes, this algorithm has been implemented to compute the optimal estimates only with the \\(l_2\\) loss function. For more informations, you can have a look on the source code.</p> <p>In this algorithm, \\(\\hat{c_0}\\) is directly estimated as the \\(x^{th}\\) quantile of the completeness predictor \\(c(t)\\), where \\(x\\) is a number between 0 and 1. Then, \\(\\hat{t_0}\\) is the first time \\(c(t)\\) reaches \\(\\hat{c_0}\\).</p> \\[ \\begin{aligned} \\hat{c_0} &amp; = x^{th} \\text{ quantile of } c(t) \\\\ \\hat{t_0} &amp; = \\underset{t}{\\mathrm{argmin}}(c(t) \\geq \\hat{c_0}) \\end{aligned} \\] <p>Default quantile \\(x\\)</p> <p>The default quantile is \\(x = 0.8\\).</p> <pre><code>from edsteva.models.step_function import StepFunction\n\nstep_function_model = StepFunction()\nstep_function_model.fit(probe)\nstep_function_model.estimates.head()\n</code></pre> care_site_level care_site_id stay_type t_0 c_0 error Unit\u00e9 Fonctionnelle (UF) 8312056386 'Urg' 2019-05-01 0.397 0.040 Unit\u00e9 Fonctionnelle (UF) 8312056386 'All' 2011-04-01 0.583 0.028 P\u00f4le/DMU 8312027648 'Hospit' 2021-03-01 0.677 0.022 P\u00f4le/DMU 8312027648 'All' 2018-08-01 0.764 0.014 H\u00f4pital 8312022130 'Hospit' 2022-02-01 0.652 0.027 CoefficientsMetricsAlgosExample <p>The <code>RectangleFunction</code> fits a step function \\(f_{t_0, c_0, t_1}(t)\\) with coefficients \\(\\Theta = (t_0, c_0, t_1)\\) on a completeness predictor \\(c(t)\\):</p> \\[ \\begin{aligned} f_{t_0, c_0, t_1}(t) &amp; = c_0 \\ \\mathbb{1}_{t_0 \\leq t \\leq t_1}(t) \\\\ c(t) &amp; = f_{t_0, c_0, t_1}(t) + \\epsilon(t) \\end{aligned} \\] <ul> <li>the characteristic time \\(t_0\\) estimates the time after which the data is available.</li> <li>the characteristic time \\(t_1\\) estimates the time after which the data is not available anymore.</li> <li>the characteristic value \\(c_0\\) estimates the completeness between \\(t_0\\) and \\(t_1\\).</li> </ul> <p>The default metric computed is the mean squared error between \\(t_0\\) and \\(t_1\\):</p> \\[ error = \\frac{\\sum_{t_0 \\leq  t \\leq t_1} \\epsilon(t)^2}{t_1 - t_0} \\] <ul> <li>\\(error\\) estimates the stability of the data between \\(t_0\\) and \\(t_1\\).</li> </ul> <p>Custom metric<p>You can define your own metric if this one doesn't meet your requirements.</p> </p> <p>The available algorithms used to fit the step function are listed below:</p> <p>Custom algo<p>You can define your own algorithm if they don't meet your requirements.</p> </p> Loss minimization <p>This algorithm computes the estimated coefficients \\(\\hat{t_0}\\), \\(\\hat{c_0}\\) and \\(\\hat{t_1}\\) by minimizing the loss function \\(\\mathcal{L}(t_0, c_0, t_1)\\):</p> \\[ \\begin{aligned} \\mathcal{L}(t_0, c_0, t_1) &amp; = \\frac{\\sum_{t = t_{min}}^{t_{max}} \\mathcal{l}(c(t), f_{t_0, c_0, t_1}(t))}{t_{max} - t_{min}} \\\\ (\\hat{t_0}, \\hat{t_1}, \\hat{c_0}) &amp; = \\underset{t_0, c_0, t_1}{\\mathrm{argmin}}(\\mathcal{L}(t_0, c_0, t_1)) \\\\ \\end{aligned} \\] <p>Default loss function \\(\\mathcal{l}\\)</p> <p>The loss function is \\(l_2\\) by default: $$ \\mathcal{l}(c(t), f_{t_0, c_0, t_1}(t)) = |c(t) - f_{t_0, c_0, t_1}(t)|^2 $$</p> <p>Optimal estimates</p> <p>For complexity purposes, this algorithm has been implemented with a dependency relation between \\(c_0\\) and \\(t_0\\) derived from the optimal estimates using the \\(l_2\\) loss function. For more informations, you can have a look on the source code.</p> <pre><code>from edsteva.models.rectangle_function import RectangleFunction\n\nrectangle_function_model = RectangleFunction()\nrectangle_function_model.fit(probe)\nrectangle_function_model.estimates.head()\n</code></pre> care_site_level care_site_id stay_type t_0 c_0 t_1 error Unit\u00e9 Fonctionnelle (UF) 8312056386 'Urg' 2019-05-01 0.397 2020-05-01 0.040 Unit\u00e9 Fonctionnelle (UF) 8312056386 'All' 2011-04-01 0.583 2013-04-01 0.028 P\u00f4le/DMU 8312027648 'Hospit' 2021-03-01 0.677 2022-03-01 0.022 P\u00f4le/DMU 8312027648 'All' 2018-08-01 0.764 2019-08-01 0.014 H\u00f4pital 8312022130 'Hospit' 2022-02-01 0.652 2022-08-01 0.027"},{"location":"components/probe/","title":"Probe","text":"<p>Choosing or customizing a Probe is the second step in the EDS-TeVa usage workflow.</p>"},{"location":"components/probe/#definition","title":"Definition","text":"<p>A Probe is a python class designed to characterize data availability of a target variable over time \\(t\\). It aggregates the loaded data to obtain a completeness predictor \\(c(t)\\).</p> <p> </p> Probe class diagram"},{"location":"components/probe/#input","title":"Input","text":"<p>As detailled in the dedicated section, the Probe class is expecting a <code>Data</code> object with Pandas or Koalas DataFrames.  We provide various connectors to facilitate data fetching, namely a Hive connector, a Postgres connector and a LocalData.</p>"},{"location":"components/probe/#attributes","title":"Attributes","text":"<ul> <li><code>predictor</code> is a <code>Pandas.DataFrame</code> computed by the <code>compute()</code> method. It contains the desired completeness predictor \\(c(t)\\) for each column in the <code>_index</code> attribute (care site, stay type and any other needed column).</li> <li><code>_index</code> is the list of columns that are used to aggregate the data in the <code>compute()</code> method.</li> </ul>"},{"location":"components/probe/#methods","title":"Methods","text":"<ul> <li><code>compute()</code> method calls the <code>compute_process()</code> method to compute the completeness predictors \\(c(t)\\) and store them in the <code>predictor</code> attribute.</li> <li><code>compute_process()</code>  method aggregates the input data to compute the completeness predictors \\(c(t)\\).</li> <li><code>filter_care_site()</code> method filters <code>predictor</code> attribute on the selected care sites including upper and lower levels care sites.</li> <li><code>save()</code> method saves the <code>Probe</code> in the desired path. By default it is saved in the the cache directory (~/.cache/edsteva/probes).</li> <li><code>load()</code> method loads the <code>Probe</code> from the desired path.  By default it is loaded from the the cache directory (~/.cache/edsteva/probes).</li> </ul>"},{"location":"components/probe/#predictor-schema","title":"Predictor schema","text":"<p>Data stored in <code>predictor</code> attribute follows a specific schema:</p>"},{"location":"components/probe/#predictors","title":"Predictors","text":"<p>It must include a completeness predictor \\(c(t)\\):</p> <ul> <li><code>c</code>: value of the completeness predictor \\(c(t)\\).</li> </ul> <p>Then, it can have any other extra predictor you find useful such as:</p> <ul> <li><code>n_visit</code>: the number of visits.</li> </ul> <p>Extra predictor</p> <p>The extra predictors must be additive to be aggregated properly in the dashboards. For instance, the number of visits is additive but the \\(99^{th}\\) percentile is not.</p>"},{"location":"components/probe/#indexes","title":"Indexes","text":"<p>It must include one and only one time related column:</p> <ul> <li><code>date</code>: date of the event associated with the target variable (by default, the dates are truncated to the month in which the event occurs).</li> </ul> <p>Then, it can have any other string type column such as:</p> <ul> <li><code>care_site_level</code>: care site hierarchic level (<code>uf</code>, <code>pole</code>, <code>hospital</code>).</li> <li><code>care_site_id</code>: care site unique identifier.</li> <li><code>stay_type</code>: type of stay (<code>hospitalis\u00e9s</code>, <code>urgence</code>, <code>hospitalisation incompl\u00e8te</code>, <code>consultation externe</code>).</li> <li><code>note_type</code>: type of note (<code>CRH</code>, <code>Ordonnance</code>, <code>CR Passage Urgences</code>).</li> </ul>"},{"location":"components/probe/#example","title":"Example","text":"<p>When considering the availability of clinical notes, a <code>NoteProbe.predictor</code> may for instance look like this:</p> care_site_level care_site_id care_site_short_name stay_type note_type date n_visit c Unit\u00e9 Fonctionnelle (UF) 8312056386 Care site 1 'Urg_Hospit' 'All' 2019-05-01 233.0 '0.841 Unit\u00e9 Fonctionnelle (UF) 8653815660 Care site 1 'All' 'CRH' 2011-04-01 393.0 0.640 P\u00f4le/DMU 8312027648 Care site 2 'Urg_Hospit' 'CRH' 2021-03-01 204.0 0.497 P\u00f4le/DMU 8312056379 Care site 2 'All' 'Ordonnance' 2018-08-01 22.0 0.274 H\u00f4pital 8312022130 Care site 3 'Urg_Hospit' 'CR Passage Urgences' 2022-02-01 9746.0 0.769"},{"location":"components/probe/#saving-and-loading-a-computed-probe","title":"Saving and loading a computed Probe","text":"<p>In order to ease the future loading of a Probe that has been computed with the <code>compute()</code> method, one can pickle it using the <code>save()</code> method. This enables a rapid loading of the Probe from local disk using the <code>load()</code> method.</p> <pre><code>from edsteva.probes import NoteProbe\n\nnote = NoteProbe()\n\nnote.compute(data)  # (1)\nnote.save()  # (2)\n\nnote_2 = NoteProbe()\nnote_2.load()  # (3)\n</code></pre> <ol> <li>Computation of the Probe querying the database (long).</li> <li>Saving of the Probe on the local disk.</li> <li>Rapid loading of the Probe fom the local disk.</li> </ol>"},{"location":"components/probe/#defining-a-custom-probe","title":"Defining a custom Probe","text":"<p>If none of the available Probes meets your requirements, you may want to create your own. To define a custom Probe class <code>CustomProbe</code> that inherits from the abstract class <code>BaseProbe</code> you'll have to implement the <code>compute_process()</code> method (this method is natively called by the <code>compute()</code> method inherited by the <code>BaseProbe</code> class). You'll also have to define the <code>_index</code> attribute which is the list of columns that are used to aggregate the data in the <code>compute_process()</code> method.</p> <pre><code>from edsteva.probes import BaseProbe\n\n\n# Definition of a new Probe class\nclass CustomProbe(BaseProbe):\n    def __init__(\n        self,\n    ):\n        self._index = [\"my_custom_column_1\", \"my_custom_column_2\"]\n        super().__init__(\n            index=self._index,\n        )\n\n    def compute_process(\n        self,\n        data: Data,\n        **kwargs,\n    ):\n        # query using Pandas API\n        return custom_predictor\n</code></pre> <p><code>compute_process()</code> can take as much as argument as you need but it must include a <code>data</code> argument and must return a <code>Pandas.DataFrame</code> which contains at least the columns of the standard schema of a predictor. For a detailed example of the implementation of a Probe, please have a look on the implemented Probes such as <code>VisitProbe</code> or <code>NoteProbe</code>.</p> <p>Contributions</p> <p>If you managed to create your own Probe do not hesitate to share it with the community by following the contribution guidelines. Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given.</p>"},{"location":"components/probe/#available-probes","title":"Available Probes","text":"<p>We list hereafter the Probes that have already been implemented in the library.</p> VisitProbeNoteProbeConditionProbeBiologyProbe <p>The <code>VisitProbe</code> computes \\(c_{visit}(t)\\) the availability of administrative stays:</p> per_visit_default \\[ c(t) = \\frac{n_{visit}(t)}{n_{max}} \\] <p>Where \\(n_{visit}(t)\\) is the number of administrative stays, \\(t\\) is the month and \\(n_{max} = \\max_{t}(n_{visit}(t))\\).</p> <p>If the maximum number of records per month \\(n_{max}\\) is equal to 0, we consider that the completeness predictor \\(c(t)\\) is also equal to 0.</p> <pre><code>from edsteva.probes import VisitProbe\n\nvisit = VisitProbe()\nvisit.compute(\n    data,\n    stay_types={\n        \"Urg\": \"urgence\",\n        \"Hospit\": \"hospitalis\u00e9s\",\n        \"Urg_Hospit\": \"urgence|hospitalis\u00e9s\",\n    },\n)\nvisit.predictor.head()\n</code></pre> care_site_level care_site_id care_site_short_name stay_type date n_visit c Unit\u00e9 Fonctionnelle (UF) 8312056386 Care site 1 'Urg' 2019-05-01 233.0 0.841 Unit\u00e9 Fonctionnelle (UF) 8312056386 Care site 1 'Urg' 2021-04-01 393.0 0.640 P\u00f4le/DMU 8312027648 Care site 2 'Hospit' 2011-03-01 204.0 0.497 P\u00f4le/DMU 8312027648 Care site 2 'Urg' 2018-08-01 22.0 0.274 H\u00f4pital 8312022130 Care site 3 'Urg_Hospit' 2022-02-01 9746.0 0.769 <p>The <code>NoteProbe</code> computes \\(c_{note}(t)\\) the availability of clinical documents:</p> per_visit_defaultper_note_default <p>The <code>per_visit_default</code> algorithm computes \\(c_(t)\\) the availability of clinical documents linked to patients' administrative stays:</p> \\[ c(t) = \\frac{n_{with\\,doc}(t)}{n_{visit}(t)} \\] <p>Where \\(n_{visit}(t)\\) is the number of administrative stays, \\(n_{with\\,doc}\\) the number of visits having at least one document and \\(t\\) is the month.</p> <p>If the number of visits \\(n_{visit}(t)\\) is equal to 0, we consider that the completeness predictor \\(c(t)\\) is also equal to 0.</p> <pre><code>from edsteva.probes import NoteProbe\n\nnote = Note(completeness_predictor=\"per_visit_default\")\nnote.compute(\n    data,\n    stay_types={\n        \"Urg\": \"urgence\",\n        \"Hospit\": \"hospitalis\u00e9s\",\n        \"Urg_Hospit\": \"urgence|hospitalis\u00e9s\",\n    },\n    note_types={\n        \"All\": \".*\",\n        \"CRH\": \"crh\",\n        \"Ordonnance\": \"ordo\",\n        \"CR Passage Urgences\": \"urge\",\n    },\n)\nnote.predictor.head()\n</code></pre> care_site_level care_site_id care_site_short_name stay_type note_type date n_visit n_visit_with_note c Unit\u00e9 Fonctionnelle (UF) 8312056386 Care site 1 'Urg' 'All' 2019-05-01 233.0 196.0 0.841 Unit\u00e9 Fonctionnelle (UF) 8653815660 Care site 1 'Hospit' 'CRH' 2011-04-01 393.0 252.0 0.640 P\u00f4le/DMU 8312027648 Care site 2 'Hospit' 'CRH' 2021-03-01 204.0 101.0 0.497 P\u00f4le/DMU 8312056379 Care site 2 'Urg' 'Ordonnance' 2018-08-01 22.0 6.0 0.274 H\u00f4pital 8312022130 Care site 3 'Urg_Hospit' 'CR Passage Urgences' 2022-02-01 9746.0 7495.0 0.769 <p>The <code>per_note_default</code> algorithm computes \\(c_(t)\\) the availability of clinical documents as follow:</p> \\[ c(t) = \\frac{n_{note}(t)}{n_{max}} \\] <p>Where \\(n_{note}(t)\\) is the number of clinical documents, \\(t\\) is the month and \\(n_{max} = \\max_{t}(n_{note}(t))\\).</p> <p>If the maximum number of recorded notes per month \\(n_{max}\\) is equal to 0, we consider that the completeness predictor \\(c(t)\\) is also equal to 0.</p> <pre><code>from edsteva.probes import NoteProbe\n\nnote = Note(completeness_predictor=\"per_note_default\")\nnote.compute(\n    data,\n    stay_types={\n        \"Urg\": \"urgence\",\n        \"Hospit\": \"hospitalis\u00e9s\",\n        \"Urg_Hospit\": \"urgence|hospitalis\u00e9s\",\n    },\n    note_types={\n        \"All\": \".*\",\n        \"CRH\": \"crh\",\n        \"Ordonnance\": \"ordo\",\n        \"CR Passage Urgences\": \"urge\",\n    },\n)\nnote.predictor.head()\n</code></pre> care_site_level care_site_id care_site_short_name stay_type note_type date n_note c Unit\u00e9 Fonctionnelle (UF) 8312056386 Care site 1 'Urg' 'All' 2019-05-01 233.0 0.841 Unit\u00e9 Fonctionnelle (UF) 8653815660 Care site 1 'Hospit' 'CRH' 2011-04-01 393.0 0.640 P\u00f4le/DMU 8312027648 Care site 2 'Hospit' 'CRH' 2021-03-01 204.0 0.497 P\u00f4le/DMU 8312056379 Care site 2 'Urg' 'Ordonnance' 2018-08-01 22.0 0.274 H\u00f4pital 8312022130 Care site 3 'Urg_Hospit' 'CR Passage Urgences' 2022-02-01 9746.0 0.769 <p>The <code>ConditionProbe</code> computes \\(c_{condition}(t)\\) the availability of claim data:</p> per_visit_defaultper_condition_default <p>The <code>per_visit_default</code> algorithm computes \\(c_(t)\\) the availability of claim data linked to patients' administrative stays:</p> \\[ c(t) = \\frac{n_{with\\,condition}(t)}{n_{visit}(t)} \\] <p>Where \\(n_{visit}(t)\\) is the number of administrative stays, \\(n_{with\\,condition}\\) the number of stays having at least one claim code (e.g. ICD-10) recorded and \\(t\\) is the month.</p> <p>If the number of visits \\(n_{visit}(t)\\) is equal to 0, we consider that the completeness predictor \\(c(t)\\) is also equal to 0.</p> <p>Care site level</p> <p>AREM claim data are only available at hospital level.</p> <pre><code>from edsteva.probes import ConditionProbe\n\ncondition = ConditionProbe(completeness_predictor=\"per_visit_default\")\ncondition.compute(\n    data,\n    stay_types={\n        \"Hospit\": \"hospitalis\u00e9s\",\n    },\n    diag_types={\n        \"All\": \".*\",\n        \"DP/DR\": \"DP|DR\",\n    },\n    condition_types={\n        \"All\": \".*\",\n        \"Pulmonary_embolism\": \"I26\",\n    },\n    source_systems=[\"AREM\", \"ORBIS\"],\n)\ncondition.predictor.head()\n</code></pre> care_site_level care_site_id care_site_short_name stay_type diag_type condition_type source_systems date n_visit n_visit_with_condition c H\u00f4pital 8312057527 Care site 1 'Hospit' 'All' 'Pulmonary_embolism' AREM 2019-05-01 233.0 196.0 0.841 H\u00f4pital 8312057527 Care site 1 'Hospit' 'DP/DR' 'Pulmonary_embolism' AREM 2021-04-01 393.0 252.0 0.640 H\u00f4pital 8312027648 Care site 2 'Hospit' 'All' 'Pulmonary_embolism' AREM 2011-03-01 204.0 101.0 0.497 Unit\u00e9 Fonctionnelle (UF) 8312027648 Care site 2 'Hospit' 'All' 'All' ORBIS 2018-08-01 22.0 6.0 0.274 P\u00f4le/DMU 8312022130 Care site 3 'Hospit' 'DP/DR' 'Pulmonary_embolism' ORBIS 2022-02-01 9746.0 7495.0 0.769 <p>The <code>per_condition_default</code> algorithm computes \\(c_(t)\\) the availability of claim data as follow:</p> \\[ c(t) = \\frac{n_{condition}(t)}{n_{max}} \\] <p>Where \\(n_{condition}(t)\\) is the number of claim codes (e.g. ICD-10) recorded, \\(t\\) is the month and \\(n_{max} = \\max_{t}(n_{condition}(t))\\).</p> <p>If the maximum number of recorded diagnosis per month \\(n_{max}\\) is equal to 0, we consider that the completeness predictor \\(c(t)\\) is also equal to 0.</p> <pre><code>from edsteva.probes import ConditionProbe\n\ncondition = ConditionProbe(completeness_predictor=\"per_condition_default\")\ncondition.compute(\n    data,\n    stay_types={\n        \"All\": \".*\",\n        \"Hospit\": \"hospitalis\u00e9s\",\n    },\n    diag_types={\n        \"All\": \".*\",\n        \"DP/DR\": \"DP|DR\",\n    },\n    condition_types={\n        \"All\": \".*\",\n        \"Pulmonary_embolism\": \"I26\",\n    },\n    source_systems=[\"AREM\", \"ORBIS\"],\n)\ncondition.predictor.head()\n</code></pre> care_site_level care_site_id care_site_short_name stay_type diag_type condition_type source_systems date n_condition c H\u00f4pital 8312057527 Care site 1 'Hospit' 'All' 'Pulmonary_embolism' AREM 2019-05-01 233.0 0.841 H\u00f4pital 8312057527 Care site 1 'Hospit' 'DP/DR' 'Pulmonary_embolism' AREM 2021-04-01 393.0 0.640 H\u00f4pital 8312027648 Care site 2 'Hospit' 'All' 'Pulmonary_embolism' AREM 2011-03-01 204.0 0.497 Unit\u00e9 Fonctionnelle (UF) 8312027648 Care site 2 'Hospit' 'All' 'All' ORBIS 2018-08-01 22.0 0.274 P\u00f4le/DMU 8312022130 Care site 3 'Hospit' 'DP/DR' 'Pulmonary_embolism' ORBIS 2022-02-01 9746.0 0.769 <p>The <code>BiologyProbe</code> computes \\(c_(t)\\) the availability of laboratory data:</p> per_visit_defaultper_measurement_default <p>The <code>per_visit_default</code> algorithm computes \\(c_(t)\\) the availability of laboratory data linked to patients' administrative stays:</p> \\[ c(t) = \\frac{n_{with\\,biology}(t)}{n_{visit}(t)} \\] <p>Where \\(n_{visit}(t)\\) is the number of administrative stays, \\(n_{with\\,biology}\\) the number of stays having at least one biological measurement recorded and \\(t\\) is the month.</p> <p>If the number of visits \\(n_{visit}(t)\\) is equal to 0, we consider that the completeness predictor \\(c(t)\\) is also equal to 0.</p> <p>Care site level</p> <p>Laboratory data are only available at hospital level.</p> <pre><code>from edsteva.probes import BiologyProbe\n\nbiology = BiologyProbe(completeness_predictor=\"per_visit_default\")\nbiology.compute(\n    data,\n    stay_types={\n        \"Hospit\": \"hospitalis\u00e9s\",\n    },\n    concepts_sets={\n        \"Cr\u00e9atinine\": \"E3180|G1974|J1002|A7813|A0094|G1975|J1172|G7834|F9409|F9410|C0697|H4038|F2621\",\n        \"Leucocytes\": \"A0174|K3232|H6740|E4358|C9784|C8824|E6953\",\n    },\n)\nbiology.predictor.head()\n</code></pre> care_site_level care_site_id care_site_short_name stay_type concepts_sets date n_visit n_visit_with_measurement c H\u00f4pital 8312057527 Care site 1 'Hospit' 'Cr\u00e9atinine' 2019-05-01 233.0 196.0 0.841 H\u00f4pital 8312057527 Care site 1 'Hospit' 'Leucocytes' 2021-04-01 393.0 252.0 0.640 H\u00f4pital 8312027648 Care site 2 'Hospit' 'Cr\u00e9atinine' 2011-03-01 204.0 101.0 0.497 H\u00f4pital 8312027648 Care site 2 'Hospit' 'Leucocytes' 2018-08-01 22.0 6.0 0.274 H\u00f4pital 8312022130 Care site 3 'Hospit' 'Leucocytes' 2022-02-01 9746.0 7495.0 0.769 <p>The <code>per_measurement_default</code> algorithm computes \\(c_(t)\\) the availability of biological measurements:</p> \\[ c(t) = \\frac{n_{biology}(t)}{n_{max}} \\] <p>Where \\(n_{biology}(t)\\) is the number of biological measurements, \\(t\\) is the month and \\(n_{max} = \\max_{t}(n_{biology}(t))\\).</p> <p>If the maximum number of recorded biological measurements per month \\(n_{max}\\) is equal to 0, we consider that the completeness predictor \\(c(t)\\) is also equal to 0.</p> <p>Care site level</p> <p>Laboratory data are only available at hospital level.</p> <pre><code>from edsteva.probes import BiologyProbe\n\nbiology = BiologyProbe(completeness_predictor=\"per_measurement_default\")\nbiology.compute(\n    data,\n    stay_types={\n        \"Hospit\": \"hospitalis\u00e9s\",\n    },\n    concepts_sets={\n        \"Cr\u00e9atinine\": \"E3180|G1974|J1002|A7813|A0094|G1975|J1172|G7834|F9409|F9410|C0697|H4038|F2621\",\n        \"Leucocytes\": \"A0174|K3232|H6740|E4358|C9784|C8824|E6953\",\n    },\n)\nbiology.predictor.head()\n</code></pre> care_site_level care_site_id care_site_short_name stay_type concepts_sets date n_measurement c H\u00f4pital 8312057527 Care site 1 'Hospit' 'Cr\u00e9atinine' 2019-05-01 233.0 0.841 H\u00f4pital 8312057527 Care site 1 'Hospit' 'Leucocytes' 2021-04-01 393.0 0.640 H\u00f4pital 8312027648 Care site 2 'Hospit' 'Cr\u00e9atinine' 2011-03-01 204.0 0.497 Unit\u00e9 Fonctionnelle (UF) 8312027648 Care site 2 'Hospit' 'Leucocytes' 2018-08-01 22.0 0.274 P\u00f4le/DMU 8312022130 Care site 3 'Hospit' 'Leucocytes' 2022-02-01 9746.0 0.769"},{"location":"components/visualization/","title":"Visualization","text":"<p>The fourth (and last) step in the EDS-TeVa usage workflow is setting the thresholds associated with the coefficients and the metrics of the Model fitted on the Probes.</p>"},{"location":"components/visualization/#definition","title":"Definition","text":"<p>The EDS-TeVa library provides dashboards and plots to visualize the temporal evolution of Probes along with fitted Models. Visualization functionalities can be used to explore the database and set thresholds relative to selection criteria.</p> <p> </p> Visualization diagram"},{"location":"components/visualization/#dashboard","title":"Dashboard","text":"<p>A Dashboard is an interactive Altair chart that lets you visualize variables aggregated by any combination of columns included in the Probe. In the library, the dashboards are divided into two parts:</p> <ul> <li>On the top, there is the plot of the aggregated variable of interest.</li> <li>On the bottom, there are interactive filters to set. Only the selected data is aggregated to produce the plot on the top.</li> </ul>"},{"location":"components/visualization/#plot","title":"Plot","text":"<p>A Plot is exportable in png or svg format and easy to integrate into a report. However, as it is less interactive it is preferred to specify the filters in the inputs of the functions.</p>"},{"location":"components/visualization/#available-visualizations","title":"Available Visualizations","text":"DashboardPlot <p>The library provides interactive dashboards that let you set any combination of care sites, stay types and other columns if included in the Probe. You can only export a dashboard in HTML format.</p> probe_dashboard()normalized_probe_dashboard() <p>The <code>probe_dashboard()</code> returns:</p> <ul> <li>On the top, the aggregated variable is the average completeness predictor \\(c(t)\\) over time \\(t\\) with the prediction \\(\\hat{c}(t)\\) if the fitted Model is specified.</li> <li>On the bottom, the interactive filters are all the columns included in the Probe (such as time, care site, number of visits...etc.).</li> </ul> <p><pre><code>from edsteva.viz.dashboards import probe_dashboard\n\nprobe_dashboard(\n    probe=probe,\n    fitted_model=step_function_model,\n    care_site_level=care_site_level,\n)\n</code></pre> An example is available here.</p> <p>The <code>normalized_probe_dashboard()</code> returns a representation of the overall deviation from the Model:</p> <ul> <li>On the top, the aggregated variable is a normalized completeness predictor \\(\\frac{c(t)}{c_0}\\) over normalized time \\(t - t_0\\).</li> <li>On the bottom, the interactive filters are all the columns included in the Probe (such as time, care site, number of visits...etc.) with all the Model coefficients and metrics included in the Model.</li> </ul> <pre><code>from edsteva.viz.dashboards import normalized_probe_dashboard\n\nnormalized_probe_dashboard(\n    probe=probe,\n    fitted_model=step_function_model,\n    care_site_level=care_site_level,\n)\n</code></pre> <p>An example is available here.</p> <p>The library provides static plots that you can export in png or svg. As it is less interactive, you may specify the filters in the inputs of the functions.</p> probe_plot()normalized_probe_plot()estimates_densities_plot() <p>The <code>probe_plot()</code> returns the top plot of the <code>probe_dashboard()</code>: the normalized completeness predictor \\(\\frac{c(t)}{c_0}\\) over normalized time \\(t - t_0\\).</p> <pre><code>from edsteva.viz.plots import probe_plot\n\nprobe_plot(\n    probe=probe,\n    fitted_model=step_function_model,\n    care_site_level=care_site_level,\n    stay_type=stay_type,\n    save_path=plot_path,\n)\n</code></pre> <p>{ \"schema-url\": \"../../assets/charts/fitted_visit.json\" }</p> <p>The <code>normalized_probe_plot()</code> returns the top plot of the <code>normalized_probe_dashboard()</code>. Consequently, you have to specify the filters in the inputs of the function.</p> <p><pre><code>from edsteva.viz.plots import normalized_probe_plot\n\nnormalized_probe_plot(\n    probe=probe,\n    fitted_model=step_function_model,\n    t_min=-15,\n    t_max=15,\n    save_path=plot_path,\n)\n</code></pre> { \"schema-url\": \"../../assets/charts/normalized_probe.json\" }</p> <p>The <code>estimates_densities_plot()</code> returns the density plot and the median of each estimate. It can help you to set the thresholds.</p> <p><pre><code>from edsteva.viz.plots import estimates_densities_plot\n\nestimates_densities_plot(\n    fitted_model=step_function_model,\n)\n</code></pre> { \"schema-url\": \"../../assets/charts/estimates_densities.json\" }</p>"},{"location":"mkdocs_theme/announce_bar/","title":"Announce bar","text":"<p>New features:  Check out the new BiologyProbe !</p>"},{"location":"reference/","title":"<code>edsteva</code>","text":""},{"location":"reference/#edsteva.koalas_options","title":"koalas_options","text":"<pre><code>koalas_options() -&gt; None\n</code></pre> <p>Set necessary options to optimise Koalas</p> Source code in <code>edsteva/__init__.py</code> <pre><code>def koalas_options() -&gt; None:\n\"\"\"\n    Set necessary options to optimise Koalas\n    \"\"\"\n\n    # Reloading Koalas to use the new configuration\n    ks = sys.modules.get(\"databricks.koalas\", None)\n\n    if ks is not None:\n        importlib.reload(ks)\n\n    else:  # pragma: no cover\n        import databricks.koalas as ks\n\n    ks.set_option(\"compute.default_index_type\", \"distributed\")\n    ks.set_option(\"compute.ops_on_diff_frames\", True)\n</code></pre>"},{"location":"reference/#edsteva.improve_performances","title":"improve_performances","text":"<pre><code>improve_performances(\n    to_add_conf: List[Tuple[str, str]] = None,\n    quiet_spark: bool = True,\n) -&gt; Tuple[SparkSession, SparkContext, SparkSession.sql]\n</code></pre> <p>(Re)defines various Spark variable with some configuration changes to improve performances by enabling Arrow This has to be done - Before launching a SparkCOntext - Before importing Koalas Those two points are being taken care on this function. If a SparkSession already exists, it will copy its configuration before creating a new one</p> RETURNS DESCRIPTION <code>Tuple of</code> <code>- A SparkSession</code> <code>- The associated SparkContext</code> <code>- The associated ``sql`` object to run SQL queries</code> Source code in <code>edsteva/__init__.py</code> <pre><code>def improve_performances(\n    to_add_conf: List[Tuple[str, str]] = None,\n    quiet_spark: bool = True,\n) -&gt; Tuple[SparkSession, SparkContext, SparkSession.sql]:\n\"\"\"\n    (Re)defines various Spark variable with some configuration changes\n    to improve performances by enabling Arrow\n    This has to be done\n    - Before launching a SparkCOntext\n    - Before importing Koalas\n    Those two points are being taken care on this function.\n    If a SparkSession already exists, it will copy its configuration before\n    creating a new one\n\n    Returns\n    -------\n    Tuple of\n    - A SparkSession\n    - The associated SparkContext\n    - The associated ``sql`` object to run SQL queries\n    \"\"\"\n\n    # Check if a spark Session is up\n    global spark, sc, sql\n\n    spark = SparkSession.builder.getOrCreate()\n    sc = spark.sparkContext\n\n    if quiet_spark:\n        sc.setLogLevel(\"ERROR\")\n\n    conf = sc.getConf()\n\n    # Synchronizing TimeZone\n    tz = os.environ.get(\"TZ\", \"UTC\")\n    os.environ[\"TZ\"] = tz\n    time.tzset()\n\n    if to_add_conf is None:\n        to_add_conf = []\n\n    to_add_conf.extend(\n        [\n            (\"spark.app.name\", f\"{os.environ.get('USER')}_scikit\"),\n            (\"spark.sql.session.timeZone\", tz),\n            (\"spark.sql.execution.arrow.enabled\", \"true\"),\n            (\"spark.sql.execution.arrow.pyspark.enabled\", \"true\"),\n        ]\n    )\n\n    for key, value in to_add_conf:\n        conf.set(key, value)\n\n    # Stopping context to add necessary env variables\n    sc.stop()\n    spark.stop()\n\n    set_env_variables()\n\n    spark = SparkSession.builder.enableHiveSupport().config(conf=conf).getOrCreate()\n\n    sc = spark.sparkContext\n\n    if quiet_spark:\n        sc.setLogLevel(\"ERROR\")\n\n    sql = spark.sql\n\n    koalas_options()\n\n    return spark, sc, sql\n</code></pre>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>edsteva<ul> <li>io<ul> <li>files</li> <li>hive</li> <li>i2b2_mapping</li> <li>postgres</li> <li>settings</li> <li>synthetic<ul> <li>biology</li> <li>care_site</li> <li>note</li> <li>synthetic</li> <li>utils</li> <li>visit</li> </ul> </li> </ul> </li> <li>metrics<ul> <li>error</li> <li>error_after_t0</li> <li>error_between_t0_t1</li> </ul> </li> <li>models<ul> <li>base</li> <li>rectangle_function<ul> <li>algos<ul> <li>loss_minimization</li> </ul> </li> <li>rectangle_function</li> <li>viz_configs<ul> <li>defaults</li> <li>normalized_probe_dashboard</li> <li>normalized_probe_plot</li> <li>probe_dashboard</li> <li>probe_plot</li> </ul> </li> </ul> </li> <li>step_function<ul> <li>algos<ul> <li>loss_minimization</li> <li>quantile</li> </ul> </li> <li>step_function</li> <li>viz_configs<ul> <li>defaults</li> <li>normalized_probe_dashboard</li> <li>normalized_probe_plot</li> <li>probe_dashboard</li> <li>probe_plot</li> </ul> </li> </ul> </li> </ul> </li> <li>probes<ul> <li>base<ul> <li>base</li> <li>viz_configs</li> </ul> </li> <li>biology<ul> <li>biology</li> <li>completeness_predictors<ul> <li>per_measurement</li> <li>per_visit</li> </ul> </li> <li>viz_configs<ul> <li>n_measurement<ul> <li>defaults</li> <li>estimates_densities_plot</li> <li>normalized_probe_dashboard</li> <li>normalized_probe_plot</li> <li>probe_dashboard</li> <li>probe_plot</li> </ul> </li> <li>per_measurement<ul> <li>defaults</li> <li>estimates_densities_plot</li> <li>normalized_probe_dashboard</li> <li>normalized_probe_plot</li> <li>probe_dashboard</li> <li>probe_plot</li> </ul> </li> <li>per_visit<ul> <li>defaults</li> <li>estimates_densities_plot</li> <li>normalized_probe_dashboard</li> <li>normalized_probe_plot</li> <li>probe_dashboard</li> <li>probe_plot</li> </ul> </li> </ul> </li> </ul> </li> <li>condition<ul> <li>completeness_predictors<ul> <li>per_condition</li> <li>per_visit</li> </ul> </li> <li>condition</li> <li>viz_configs<ul> <li>n_condition<ul> <li>defaults</li> <li>estimates_densities_plot</li> <li>normalized_probe_dashboard</li> <li>normalized_probe_plot</li> <li>probe_dashboard</li> <li>probe_plot</li> </ul> </li> <li>per_condition<ul> <li>defaults</li> <li>estimates_densities_plot</li> <li>normalized_probe_dashboard</li> <li>normalized_probe_plot</li> <li>probe_dashboard</li> <li>probe_plot</li> </ul> </li> <li>per_visit<ul> <li>defaults</li> <li>estimates_densities_plot</li> <li>normalized_probe_dashboard</li> <li>normalized_probe_plot</li> <li>probe_dashboard</li> <li>probe_plot</li> </ul> </li> </ul> </li> </ul> </li> <li>note<ul> <li>completeness_predictors<ul> <li>per_note</li> <li>per_visit</li> </ul> </li> <li>note</li> <li>viz_configs<ul> <li>n_note<ul> <li>defaults</li> <li>estimates_densities_plot</li> <li>normalized_probe_dashboard</li> <li>normalized_probe_plot</li> <li>probe_dashboard</li> <li>probe_plot</li> </ul> </li> <li>per_note<ul> <li>defaults</li> <li>estimates_densities_plot</li> <li>normalized_probe_dashboard</li> <li>normalized_probe_plot</li> <li>probe_dashboard</li> <li>probe_plot</li> </ul> </li> <li>per_visit<ul> <li>defaults</li> <li>estimates_densities_plot</li> <li>normalized_probe_dashboard</li> <li>normalized_probe_plot</li> <li>probe_dashboard</li> <li>probe_plot</li> </ul> </li> </ul> </li> </ul> </li> <li>utils<ul> <li>filter_df</li> <li>prepare_df</li> <li>utils</li> </ul> </li> <li>visit<ul> <li>completeness_predictors<ul> <li>per_visit</li> </ul> </li> <li>visit</li> <li>viz_configs<ul> <li>n_visit<ul> <li>defaults</li> <li>estimates_densities_plot</li> <li>normalized_probe_dashboard</li> <li>normalized_probe_plot</li> <li>probe_dashboard</li> <li>probe_plot</li> </ul> </li> <li>per_visit<ul> <li>defaults</li> <li>estimates_densities_plot</li> <li>normalized_probe_dashboard</li> <li>normalized_probe_plot</li> <li>probe_dashboard</li> <li>probe_plot</li> </ul> </li> </ul> </li> </ul> </li> </ul> </li> <li>utils<ul> <li>checks</li> <li>file_management</li> <li>framework</li> <li>loss_functions</li> <li>typing</li> </ul> </li> <li>viz<ul> <li>dashboards<ul> <li>normalized_probe<ul> <li>normalized_probe</li> </ul> </li> <li>probe<ul> <li>fitted_probe</li> <li>probe</li> <li>wrapper</li> </ul> </li> </ul> </li> <li>plots<ul> <li>estimates_densities<ul> <li>estimates_densities</li> </ul> </li> <li>normalized_probe<ul> <li>normalized_probe</li> </ul> </li> <li>probe<ul> <li>fitted_probe</li> <li>probe</li> <li>wrapper</li> </ul> </li> </ul> </li> <li>utils</li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/io/","title":"<code>edsteva.io</code>","text":""},{"location":"reference/io/files/","title":"<code>edsteva.io.files</code>","text":""},{"location":"reference/io/files/#edsteva.io.files.LocalData","title":"LocalData","text":"<p>Pandas interface to OMOP data stored as local parquet files/folders.</p> PARAMETER DESCRIPTION <code>folder</code> <p>absolute path to a folder containing several parquet files with omop data</p> <p> TYPE: <code>str</code> </p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; data = LocalData(folder=\"/export/home/USER/my_data/\")\n&gt;&gt;&gt; person = data.person\n&gt;&gt;&gt; person.shape\n(100, 10)\n</code></pre> ATTRIBUTE DESCRIPTION <code>person</code> <p>Pandas dataframe <code>person</code>. All dataframe attributes are dynamically generated to match the content of the selected folder.</p> <p> TYPE: <code>pd.DataFrame</code> </p> Source code in <code>edsteva/io/files.py</code> <pre><code>class LocalData:  # pragma: no cover\n\"\"\"Pandas interface to OMOP data stored as local parquet files/folders.\n\n\n    Parameters\n    ----------\n    folder: str\n        absolute path to a folder containing several parquet files with omop data\n\n    Examples\n    --------\n    &gt;&gt;&gt; data = LocalData(folder=\"/export/home/USER/my_data/\")\n    &gt;&gt;&gt; person = data.person\n    &gt;&gt;&gt; person.shape\n    (100, 10)\n\n    Attributes\n    ----------\n    person: pd.DataFrame\n        Pandas dataframe `person`. All dataframe attributes are\n        dynamically generated to match the content of the\n        selected folder.\n\n    \"\"\"\n\n    def __init__(\n        self,\n        folder: str,\n    ):\n        (\n            self.available_tables,\n            self.tables_paths,\n            self.available_omop_tables,\n        ) = self.list_available_tables(folder)\n        if not self.available_omop_tables:\n            raise ValueError(f\"Folder {folder} does not contain any parquet omop data.\")\n\n    @staticmethod\n    def list_available_tables(folder: str) -&gt; Tuple[List[str], List[str]]:\n        available_tables = []\n        available_omop_tables = []\n        tables_paths = {}\n        known_omop_tables = settings.tables_to_load.keys()\n        for filename in os.listdir(folder):\n            file = Path(folder) / filename\n            table_name = file.stem\n            extension = file.suffix\n            if extension == \".parquet\":\n                abspath = Path.resolve(file)\n                tables_paths[table_name] = abspath\n                available_tables.append(table_name)\n                if table_name in known_omop_tables:\n                    available_omop_tables.append(table_name)\n\n        return available_tables, tables_paths, available_omop_tables\n\n    def _read_table(self, table_name: str) -&gt; pd.DataFrame:\n        path = self.tables_paths[table_name]\n        return pd.read_parquet(path)\n\n    def __getattr__(self, table_name: str) -&gt; pd.DataFrame:\n        if table_name in self.available_tables:\n            return self._read_table(table_name)\n        raise AttributeError(f\"Table '{table_name}' is not available in chosen folder.\")\n\n    def __dir__(self) -&gt; List[str]:\n        return list(super().__dir__()) + list(self.available_tables)\n</code></pre>"},{"location":"reference/io/hive/","title":"<code>edsteva.io.hive</code>","text":""},{"location":"reference/io/hive/#edsteva.io.hive.HiveData","title":"HiveData","text":"<p>Spark interface for OMOP data stored in a Hive database.</p> <p>This class provides a simple access to data stored in Hive. Data is returned as koalas dataframes that match the tables stored in Hive.</p> PARAMETER DESCRIPTION <code>database_name</code> <p>The name of you database in Hive. Ex: \"cse_82727572\"</p> <p> TYPE: <code>str</code> </p> <code>database_type</code> <p>The type of your database. Must be \"OMOP\" or \"I2B2\"</p> <p> TYPE: <code>str</code> DEFAULT: <code>'OMOP'</code> </p> <code>spark_session</code> <p>If None, a SparkSession will be retrieved or  created via <code>SparkSession.builder.enableHiveSupport().getOrCreate()</code></p> <p> TYPE: <code>pyspark.sql.SparkSession</code> DEFAULT: <code>None</code> </p> <code>person_ids</code> <p>An iterable of <code>person_id</code> that is used to define a subset of the database.</p> <p> TYPE: <code>Optional[Iterable[int]]</code> DEFAULT: <code>None</code> </p> <code>tables_to_load</code> <p>By default (i.e. if <code>tables_to_load is None</code>), loaded tables and columns loaded in each table are those listed in :py:data:<code>~edsteva.io.settings.tables_to_load</code>. A dictionnary can be provided to complement those default settings. Keys should be table names to load, and values should be: - <code>None</code> to load all columns - A list of columns to load (or to add to the default loaded columns if the table is already loaded by default)</p> <p> TYPE: <code>Optional[Dict[str, Optional[List[str]]]]</code> DEFAULT: <code>None</code> </p> ATTRIBUTE DESCRIPTION <code>person</code> <p>Hive data for table <code>person</code> as a koalas dataframe. Other OMOP tables can also be accessed as attributes</p> <p> TYPE: <code>koalas dataframe</code> </p> <code>available_tables</code> <p>names of OMOP tables that can be accessed as attributes with this HiveData object.</p> <p> TYPE: <code>list of str</code> </p> <p>Examples:</p> <pre><code>data = HiveData(database_name=\"edsomop_prod_a\")\ndata.available_tables\n# Out: [\"person\", \"care_site\", \"condition_occurrence\", ... ]\n\nperson = data.person\ntype(person)\n# Out: databricks.koalas.frame.DataFrame\n\nperson[\"person_id\"].count()\n# Out: 12670874\n</code></pre> <p>This class can be used to create a subset of data for a given list of <code>person_id</code>. This is useful because the smaller dataset can then be used to prototype more rapidly.</p> <pre><code>my_person_ids = [9226726, 2092082, 5097816]\ndata = HiveData(\n    spark_session=spark, database_name=\"edsomop_prod_a\", person_ids=my_person_ids\n)\ndata.person[\"person_id\"].count()\n# Out: 1000\n\ntables_to_save = [\"person\", \"visit_occurrence\"]\ndata.persist_tables_to_folder(\"./cohort_sample_1000\", table_names=tables_to_save)\n# Out: writing /export/home/USER/cohort_sample_1000/person.parquet\n# Out: writing /export/home/USER/cohort_sample_1000/visit_occurrence.parquet\n# Out: ...\n</code></pre> Source code in <code>edsteva/io/hive.py</code> <pre><code>class HiveData:  # pragma: no cover\n\"\"\"Spark interface for OMOP data stored in a Hive database.\n\n    This class provides a simple access to data stored in Hive.\n    Data is returned as koalas dataframes that match the tables\n    stored in Hive.\n\n    Parameters\n    ----------\n    database_name : str\n        The name of you database in Hive. Ex: \"cse_82727572\"\n    database_type : str\n        The type of your database. Must be \"OMOP\" or \"I2B2\"\n    spark_session : pyspark.sql.SparkSession, optional\n        If None, a SparkSession will be retrieved or  created via `SparkSession.builder.enableHiveSupport().getOrCreate()`\n    person_ids : Optional[Iterable[int]], default: None\n        An iterable of `person_id` that is used to define a subset of the database.\n    tables_to_load : Optional[Dict[str, Optional[List[str]]]], default: None\n        By default (i.e. if ``tables_to_load is None``), loaded tables and columns loaded in each table are those listed in\n        :py:data:`~edsteva.io.settings.tables_to_load`.\n        A dictionnary can be provided to complement those default settings. Keys should be table names to load,\n        and values should be:\n        - ``None`` to load all columns\n        - A list of columns to load (or to add to the default loaded columns if the table is already loaded by default)\n\n\n    Attributes\n    ----------\n    person : koalas dataframe\n        Hive data for table `person` as a koalas dataframe.\n        Other OMOP tables can also be accessed as attributes\n    available_tables : list of str\n        names of OMOP tables that can be accessed as attributes with this\n        HiveData object.\n\n\n    Examples\n    --------\n\n    ```python\n    data = HiveData(database_name=\"edsomop_prod_a\")\n    data.available_tables\n    # Out: [\"person\", \"care_site\", \"condition_occurrence\", ... ]\n\n    person = data.person\n    type(person)\n    # Out: databricks.koalas.frame.DataFrame\n\n    person[\"person_id\"].count()\n    # Out: 12670874\n    ```\n\n    This class can be used to create a subset of data for a given\n    list of `person_id`. This is useful because the smaller dataset\n    can then be used to prototype more rapidly.\n\n    ```python\n    my_person_ids = [9226726, 2092082, 5097816]\n    data = HiveData(\n        spark_session=spark, database_name=\"edsomop_prod_a\", person_ids=my_person_ids\n    )\n    data.person[\"person_id\"].count()\n    # Out: 1000\n\n    tables_to_save = [\"person\", \"visit_occurrence\"]\n    data.persist_tables_to_folder(\"./cohort_sample_1000\", table_names=tables_to_save)\n    # Out: writing /export/home/USER/cohort_sample_1000/person.parquet\n    # Out: writing /export/home/USER/cohort_sample_1000/visit_occurrence.parquet\n    # Out: ...\n    ```\n\n    \"\"\"\n\n    def __init__(\n        self,\n        database_name: str,\n        database_type: str = \"OMOP\",\n        spark_session: Optional[SparkSession] = None,\n        person_ids: Optional[Iterable[int]] = None,\n        tables_to_load: Optional[\n            Union[Dict[str, Optional[List[str]]], List[str]]\n        ] = None,\n    ):\n        if spark_session is not None:\n            self.spark_session = spark_session\n        else:\n            logger.warning(\n\"\"\"\n                To improve performances when using Spark and Koalas, please call `edsteva.improve_performances()`\n                This function optimally configures Spark. Use it as:\n                `spark, sc, sql = edsteva.improve_performances()`\n                The functions respectively returns a SparkSession, a SparkContext and an sql method\n                \"\"\"\n            )\n            self.spark_session = SparkSession.builder.enableHiveSupport().getOrCreate()\n\n        koalas_options()\n\n        self.database_name = database_name\n        self.database_type = database_type\n\n        if self.database_type == \"I2B2\":\n            self.database_source = \"cse\" if \"cse\" in self.database_name else \"edsprod\"\n            self.omop_to_i2b2 = settings.i2b2_tables[self.database_source]\n            self.i2b2_to_omop = {}\n            for omop_col, i2b2_col in self.omop_to_i2b2.items():\n                if i2b2_col in self.i2b2_to_omop.keys():\n                    self.i2b2_to_omop[i2b2_col].append(omop_col)\n                else:\n                    self.i2b2_to_omop[i2b2_col] = [omop_col]\n\n        self.person_ids = self._prepare_person_ids(person_ids)\n\n        tmp_tables_to_load = settings.tables_to_load\n\n        if isinstance(tables_to_load, dict):\n            for table_name, columns in tables_to_load.items():\n                if columns is None:\n                    tmp_tables_to_load[table_name] = None\n                else:\n                    tmp_tables_to_load[table_name] = list(\n                        set(tmp_tables_to_load.get(table_name, []) + columns)\n                    )\n        elif isinstance(tables_to_load, list):\n            for table_name in tables_to_load:\n                tmp_tables_to_load[table_name] = None\n\n        self.tables_to_load = tmp_tables_to_load\n        self.available_tables = self.list_available_tables()\n\n    def list_available_tables(self) -&gt; List[str]:\n        tables_df = self.spark_session.sql(\n            f\"SHOW TABLES IN {self.database_name}\"\n        ).toPandas()\n        available_tables = []\n        for table_name in tables_df[\"tableName\"].drop_duplicates().to_list():\n            if (\n                self.database_type == \"OMOP\"\n                and table_name in self.tables_to_load.keys()\n            ):\n                available_tables.append(table_name)\n            elif (\n                self.database_type == \"I2B2\" and table_name in self.i2b2_to_omop.keys()\n            ):\n                for omop_table in self.i2b2_to_omop[table_name]:\n                    if omop_table in self.tables_to_load.keys():\n                        available_tables.append(omop_table)\n            available_tables = list(set(available_tables))\n        return available_tables\n\n    def rename_table(self, old_table_name: str, new_table_name: str) -&gt; None:\n        if old_table_name in self.available_tables:\n            setattr(self, new_table_name, getattr(self, old_table_name))\n            self.available_tables.remove(old_table_name)\n            self.available_tables.append(new_table_name)\n            logger.info(\"Table {} has been renamed {}\", old_table_name, new_table_name)\n        else:\n            logger.info(\"Table {} is not available\", old_table_name)\n\n    def add_table(self, table_name: str, columns: List[str]) -&gt; None:\n        tables_df = self.spark_session.sql(\n            f\"SHOW TABLES IN {self.database_name}\"\n        ).toPandas()\n        if table_name in tables_df[\"tableName\"].drop_duplicates().to_list():\n            self.tables_to_load[table_name] = list(\n                set(self.tables_to_load.get(table_name, []) + columns)\n            )\n            self.available_tables = self.list_available_tables()\n            logger.info(\"Table {} has been added\", table_name)\n\n        else:\n            raise AttributeError(\n                f\"Table '{table_name}' is not in the database '{self.database_name}'\"\n            )\n\n    def delete_table(self, table_name: str) -&gt; None:\n        self.tables_to_load.pop(table_name, None)\n        self.available_tables = self.list_available_tables()\n        logger.info(\"Table {} has been deleted\", table_name)\n\n    def _prepare_person_ids(self, list_of_person_ids) -&gt; Optional[SparkDataFrame]:\n        if list_of_person_ids is None:\n            return None\n        if hasattr(list_of_person_ids, \"to_list\"):\n            # Useful when list_of_person_ids are Koalas (or Pandas) Series\n            unique_ids = set(list_of_person_ids.to_list())\n        else:\n            unique_ids = set(list_of_person_ids)\n\n        logger.info(\"Number of unique patients: {}\", len(unique_ids))\n        schema = StructType([StructField(\"person_id\", LongType(), True)])\n\n        return self.spark_session.createDataFrame(\n            [(int(p),) for p in unique_ids], schema=schema\n        )\n\n    def _read_table(self, table_name, person_ids=None) -&gt; DataFrame:\n        assert table_name in self.available_tables\n        if person_ids is None and self.person_ids is not None:\n            person_ids = self.person_ids\n\n        if self.database_type == \"OMOP\":\n            df = self.spark_session.sql(\n                f\"select * from {self.database_name}.{table_name}\"\n            )\n\n        elif self.database_type == \"I2B2\":\n            df = get_i2b2_table(\n                spark_session=self.spark_session,\n                db_name=self.database_name,\n                db_source=self.database_source,\n                table=table_name,\n            )\n\n        desired_columns = self.tables_to_load[table_name]\n        selected_columns = (\n            df.columns\n            if desired_columns is None\n            else [col for col in df.columns if col in desired_columns]\n        )\n        df = df.select(*selected_columns)\n\n        if \"person_id\" in df.columns and person_ids is not None:\n            df = df.join(person_ids, on=\"person_id\", how=\"inner\")\n\n        return df.to_koalas()\n\n    def persist_tables_to_folder(\n        self,\n        folder: str,\n        person_ids: Optional[Iterable[int]] = None,\n        tables: List[str] = None,\n    ) -&gt; None:\n\"\"\"Save OMOP tables as parquet files in a given folder.\n\n        Parameters\n        ----------\n        folder : str\n            path to folder where the tables will be written.\n        person_ids : iterable\n            person_ids to keep in the subcohort\n        tables : list of str, default None\n            list of table names to save. Default value is\n            :py:data:`~edsteva.io.settings.default_tables_to_save`\n\n        \"\"\"\n        if tables is None:\n            tables = settings.default_tables_to_save\n\n        unknown_tables = [\n            table for table in tables if table not in self.available_tables\n        ]\n        if unknown_tables:\n            raise ValueError(\n                f\"The following tables are not available : {unknown_tables}\"\n            )\n\n        folder = Path.resolve(folder)\n        assert Path.exists(folder) and Path.is_dir(\n            folder\n        ), f\"Folder {folder} not found.\"\n\n        if person_ids is not None:\n            person_ids = self._prepare_person_ids(person_ids)\n\n        for table in tables:\n            filepath = folder / f\"{table}.parquet\"\n            df = self._read_table(table, person_ids=person_ids)\n            self._write_df_to_parquet(df, filepath)\n\n    def _write_df_to_parquet(\n        self,\n        df: DataFrame,\n        filepath: str,\n    ) -&gt; None:\n        assert Path.is_absolute(filepath)\n        logger.info(f\"writing {filepath}\")\n        spark_filepath = \"file://\" + filepath\n        df.to_parquet(spark_filepath, mode=\"overwrite\")\n\n    def __getattr__(self, table_name: str) -&gt; DataFrame:\n        if table_name in self.available_tables:\n            # the first time it is called, we actually set the attribute\n            table = self._read_table(table_name)\n            setattr(self, table_name, table)\n            return getattr(self, table_name)\n        raise AttributeError(f\"Table '{table_name}' unknown\")\n\n    def __dir__(self) -&gt; List[str]:\n        return list(set(list(super().__dir__()) + self.available_tables))\n</code></pre>"},{"location":"reference/io/hive/#edsteva.io.hive.HiveData.persist_tables_to_folder","title":"persist_tables_to_folder","text":"<pre><code>persist_tables_to_folder(\n    folder: str,\n    person_ids: Optional[Iterable[int]] = None,\n    tables: List[str] = None,\n) -&gt; None\n</code></pre> <p>Save OMOP tables as parquet files in a given folder.</p> PARAMETER DESCRIPTION <code>folder</code> <p>path to folder where the tables will be written.</p> <p> TYPE: <code>str</code> </p> <code>person_ids</code> <p>person_ids to keep in the subcohort</p> <p> TYPE: <code>iterable</code> DEFAULT: <code>None</code> </p> <code>tables</code> <p>list of table names to save. Default value is :py:data:<code>~edsteva.io.settings.default_tables_to_save</code></p> <p> TYPE: <code>list of str</code> DEFAULT: <code>None</code> </p> Source code in <code>edsteva/io/hive.py</code> <pre><code>def persist_tables_to_folder(\n    self,\n    folder: str,\n    person_ids: Optional[Iterable[int]] = None,\n    tables: List[str] = None,\n) -&gt; None:\n\"\"\"Save OMOP tables as parquet files in a given folder.\n\n    Parameters\n    ----------\n    folder : str\n        path to folder where the tables will be written.\n    person_ids : iterable\n        person_ids to keep in the subcohort\n    tables : list of str, default None\n        list of table names to save. Default value is\n        :py:data:`~edsteva.io.settings.default_tables_to_save`\n\n    \"\"\"\n    if tables is None:\n        tables = settings.default_tables_to_save\n\n    unknown_tables = [\n        table for table in tables if table not in self.available_tables\n    ]\n    if unknown_tables:\n        raise ValueError(\n            f\"The following tables are not available : {unknown_tables}\"\n        )\n\n    folder = Path.resolve(folder)\n    assert Path.exists(folder) and Path.is_dir(\n        folder\n    ), f\"Folder {folder} not found.\"\n\n    if person_ids is not None:\n        person_ids = self._prepare_person_ids(person_ids)\n\n    for table in tables:\n        filepath = folder / f\"{table}.parquet\"\n        df = self._read_table(table, person_ids=person_ids)\n        self._write_df_to_parquet(df, filepath)\n</code></pre>"},{"location":"reference/io/i2b2_mapping/","title":"<code>edsteva.io.i2b2_mapping</code>","text":""},{"location":"reference/io/i2b2_mapping/#edsteva.io.i2b2_mapping.get_i2b2_table","title":"get_i2b2_table","text":"<pre><code>get_i2b2_table(\n    spark_session: SparkSession,\n    db_name: str,\n    db_source: str,\n    table: str,\n) -&gt; SparkDataFrame\n</code></pre> <p>Retrieve a Spark table in i2b2 and transform it to fit with OMOP standard.</p> PARAMETER DESCRIPTION <code>db_name</code> <p>Name of the database where the data is stored.</p> <p> TYPE: <code>str</code> </p> <code>table</code> <p>Name of the table to extract.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>df</code> <p>Spark DataFrame extracted from the i2b2 database given and converted to OMOP standard.</p> <p> TYPE: <code>Spark DataFrame</code> </p> Source code in <code>edsteva/io/i2b2_mapping.py</code> <pre><code>def get_i2b2_table(\n    spark_session: SparkSession, db_name: str, db_source: str, table: str\n) -&gt; SparkDataFrame:  # pragma: no cover\n\"\"\"\n    Retrieve a Spark table in i2b2 and transform it to fit with OMOP standard.\n\n    Parameters\n    ----------\n    db_name: str\n        Name of the database where the data is stored.\n    table: str\n        Name of the table to extract.\n\n    Returns\n    -------\n    df: Spark DataFrame\n        Spark DataFrame extracted from the i2b2 database given and converted to OMOP standard.\n    \"\"\"\n\n    table_name = i2b2_tables[db_source][table]\n    columns = i2b2_renaming[table]\n    if db_source == \"cse\":\n        columns.pop(\"i2b2_action\", None)\n    query = \",\".join([\"{k} AS {v}\".format(k=k, v=v) for k, v in columns.items()])\n\n    df = spark_session.sql(f\"\"\"SELECT {query} FROM {db_name}.{table_name}\"\"\")\n\n    # Special mapping for i2b2 :\n\n    # CIM10\n    if table == \"condition_occurrence\":\n        df = df.withColumn(\n            \"condition_source_value\",\n            F.split(F.col(\"condition_source_value\"), \":\").getItem(1),\n        )\n\n        # Retrieve UF\n        df = df.withColumn(\n            \"care_site_source_value\",\n            F.split(F.col(\"care_site_source_value\"), \":\").getItem(1),\n        )\n\n    # CCAM\n    elif table == \"procedure_occurrence\":\n        df = df.withColumn(\n            \"procedure_source_value\",\n            F.split(F.col(\"procedure_source_value\"), \":\").getItem(1),\n        )\n\n    # Visits\n    elif table == \"visit_occurrence\":\n        df = df.withColumn(\n            \"visit_source_value\",\n            mapping_dict(visit_type_mapping, \"Non Renseign\u00e9\")(\n                F.col(\"visit_source_value\")\n            ),\n        )\n        if db_source == \"cse\":\n            df = df.withColumn(\"row_status_source_value\", F.lit(\"Actif\"))\n            df = df.withColumn(\n                \"visit_occurrence_source_value\", df[\"visit_occurrence_id\"]\n            )\n        else:\n            df = df.withColumn(\n                \"row_status_source_value\",\n                F.when(\n                    F.col(\"row_status_source_value\").isin([-1, -2]), \"supprim\u00e9\"\n                ).otherwise(\"Actif\"),\n            )\n        # Retrieve Hospital trigram\n        ufr = spark_session.sql(\n            f\"SELECT * FROM {db_name}.{i2b2_tables[db_source]['visit_detail']}\"\n        )\n        ufr = ufr.withColumn(\n            \"care_site_id\",\n            F.substring(F.split(F.col(\"concept_cd\"), \":\").getItem(1), 1, 3),\n        )\n        ufr = ufr.withColumnRenamed(\"encounter_num\", \"visit_occurrence_id\")\n        ufr = ufr.drop_duplicates(subset=[\"visit_occurrence_id\"])\n        ufr = ufr.select([\"visit_occurrence_id\", \"care_site_id\"])\n        df = df.join(ufr, how=\"inner\", on=[\"visit_occurrence_id\"])\n\n    # Patients\n    elif table == \"person\":\n        df = df.withColumn(\n            \"gender_source_value\",\n            mapping_dict(sex_cd_mapping, \"Non Renseign\u00e9\")(F.col(\"gender_source_value\")),\n        )\n\n    # Documents\n    elif table == \"note\":\n        df = df.withColumn(\n            \"note_class_source_value\",\n            F.substring(F.col(\"note_class_source_value\"), 4, 100),\n        )\n        if db_source == \"cse\":\n            df = df.withColumn(\"row_status_source_value\", F.lit(\"Actif\"))\n        else:\n            df = df.withColumn(\n                \"row_status_source_value\",\n                F.when(F.col(\"row_status_source_value\") &lt; 0, \"SUPP\").otherwise(\"Actif\"),\n            )\n\n    # Hospital trigrams\n    elif table == \"care_site\":\n        df = df.withColumn(\"care_site_type_source_value\", F.lit(\"H\u00f4pital\"))\n        df = df.withColumn(\n            \"care_site_source_value\",\n            F.split(F.col(\"care_site_source_value\"), \":\").getItem(1),\n        )\n        df = df.withColumn(\n            \"care_site_id\", F.substring(F.col(\"care_site_source_value\"), 1, 3)\n        )\n        df = df.drop_duplicates(subset=[\"care_site_id\"])\n        df = df.withColumn(\n            \"care_site_short_name\",\n            mapping_dict(dict_code_UFR, \"Non Renseign\u00e9\")(F.col(\"care_site_id\")),\n        )\n\n    # UFR\n    elif table == \"visit_detail\":\n        df = df.withColumn(\n            \"care_site_id\", F.split(F.col(\"care_site_id\"), \":\").getItem(1)\n        )\n        df = df.withColumn(\"visit_detail_type_source_value\", F.lit(\"PASS\"))\n        df = df.withColumn(\"row_status_source_value\", F.lit(\"Actif\"))\n\n    # biology\n    elif table == \"biology\":\n        df = df.withColumn(\n            \"biology_source_value\", F.substring(F.col(\"biology_source_value\"), 5, 20)\n        )\n\n    # fact_relationship\n    elif table == \"fact_relationship\":\n        # Retrieve UF information\n        df = df.withColumn(\n            \"fact_id_1\",\n            F.split(F.col(\"care_site_source_value\"), \":\").getItem(1),\n        )\n        df = df.withColumn(\"domain_concept_id_1\", F.lit(57))  # Care_site domain\n\n        # Retrieve hospital information\n        df = df.withColumn(\"fact_id_2\", F.substring(F.col(\"fact_id_1\"), 1, 3))\n        df = df.withColumn(\"domain_concept_id_2\", F.lit(57))  # Care_site domain\n        df = df.drop_duplicates(subset=[\"fact_id_1\", \"fact_id_2\"])\n\n        # Only UF-Hospital relationships in i2b2\n        df = df.withColumn(\"relationship_concept_id\", F.lit(46233688))  # Included in\n\n    return df\n</code></pre>"},{"location":"reference/io/i2b2_mapping/#edsteva.io.i2b2_mapping.mapping_dict","title":"mapping_dict","text":"<pre><code>mapping_dict(\n    mapping: Dict[str, str], not_specified_val: str\n) -&gt; FunctionUDF\n</code></pre> <p>Returns a function that maps data according to a mapping dictionnary in a Spark DataFrame.</p> PARAMETER DESCRIPTION <code>mapping</code> <p>Mapping dictionnary</p> <p> TYPE: <code>Dict[str, str]</code> </p> <code>not_specified_val</code> <p>Value to return if the function input is not find in the mapping dictionnary.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Callable</code> <p>Function that maps the values of Spark DataFrame column.</p> Source code in <code>edsteva/io/i2b2_mapping.py</code> <pre><code>def mapping_dict(\n    mapping: Dict[str, str], not_specified_val: str\n) -&gt; FunctionUDF:  # pragma: no cover\n\"\"\"\n    Returns a function that maps data according to a mapping dictionnary in a Spark DataFrame.\n\n    Parameters\n    ----------\n    mapping: Dict\n        Mapping dictionnary\n    not_specified_val: str\n        Value to return if the function input is not find in the mapping dictionnary.\n\n    Returns\n    -------\n    Callable\n        Function that maps the values of Spark DataFrame column.\n    \"\"\"\n\n    def f(x):\n        if x in mapping:\n            return mapping.get(x)\n        return not_specified_val\n\n    return F.udf(f)\n</code></pre>"},{"location":"reference/io/postgres/","title":"<code>edsteva.io.postgres</code>","text":""},{"location":"reference/io/postgres/#edsteva.io.postgres.PostgresData","title":"PostgresData","text":"<p>PostgreSQL interface to run SQL queries.</p> <p>This uses the file <code>~/.pgpass</code> to find the password and extra connection infos.</p> PARAMETER DESCRIPTION <code>dbname</code> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> <code>schema</code> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> <code>user</code> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> <code>host</code> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> <code>port</code> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; data = PostgresData(dbname=\"YOUR_DBNAME\", schema=\"omop\", user=\"YOUR_USERNAME\")\n&gt;&gt;&gt; data.read_sql(\"select count(*) from person\")\n</code></pre> Source code in <code>edsteva/io/postgres.py</code> <pre><code>class PostgresData:  # pragma: no cover\n\"\"\"PostgreSQL interface to run SQL queries.\n\n    This uses the file `~/.pgpass` to find the password and extra connection infos.\n\n    Parameters\n    ----------\n    dbname : str\n    schema : str\n    user : str\n    host : str\n    port : str\n\n    Examples\n    --------\n    &gt;&gt;&gt; data = PostgresData(dbname=\"YOUR_DBNAME\", schema=\"omop\", user=\"YOUR_USERNAME\")\n    &gt;&gt;&gt; data.read_sql(\"select count(*) from person\")\n\n    \"\"\"\n\n    def __init__(\n        self,\n        dbname: Optional[str] = None,\n        schema: Optional[str] = None,\n        user: Optional[str] = None,\n        host: Optional[str] = None,\n        port: Optional[int] = None,\n    ):\n        (\n            self.host,\n            self.port,\n            self.dbname,\n            self.user,\n        ) = self._find_matching_pgpass_params(host, port, dbname, user)\n        self.schema = schema\n\n    @staticmethod\n    def _find_matching_pgpass_params(\n        host: str,\n        port: int,\n        dbname: str,\n        user: str,\n    ) -&gt; Tuple:\n        entries = pgpasslib._get_entries()\n        consolidated_params = [\n            (\n                host or entry.host,\n                port or entry.port,\n                dbname or entry.dbname,\n                user or entry.user,\n            )\n            for entry in entries\n        ]\n        matching_params = [\n            params\n            for entry, params in zip(entries, consolidated_params)\n            if entry.match(*params)\n        ]\n\n        if len(matching_params) == 0:\n            raise ValueError(\"Could not find matching entry in .pgpass file.\")\n        if len(matching_params) &gt; 1:\n            message = \"\\n\".join(\n                [\n                    \"Several entries found in .pgpass file. Be more specific.\",\n                    \"The following entries match what you specified :\",\n                    *[str(params) for params in matching_params],\n                ]\n            )\n            raise ValueError(message)\n\n        return matching_params[0]\n\n    def read_sql(self, sql_query: str, **kwargs) -&gt; pd.DataFrame:\n\"\"\"Execute pandas.read_sql() on the database.\n\n        Parameters\n        ----------\n        sql_query : str\n            SQL query (postgres flavor)\n        **kwargs\n            additional arguments passed to pandas.read_sql()\n\n        Returns\n        -------\n        df : pandas.DataFrame\n\n        \"\"\"\n        connection_infos = {\n            param: getattr(self, param) for param in [\"host\", \"port\", \"dbname\", \"user\"]\n        }\n        connection_infos[\"password\"] = pgpasslib.getpass(**connection_infos)\n        connection = pg.connect(**connection_infos)\n        if self.schema:\n            connection.cursor().execute(f\"SET SCHEMA '{self.schema}'\")\n\n        df = pd.read_sql(sql_query, con=connection, **kwargs)\n\n        connection.close()\n        return df\n</code></pre>"},{"location":"reference/io/postgres/#edsteva.io.postgres.PostgresData.read_sql","title":"read_sql","text":"<pre><code>read_sql(sql_query: str, **kwargs) -&gt; pd.DataFrame\n</code></pre> <p>Execute pandas.read_sql() on the database.</p> PARAMETER DESCRIPTION <code>sql_query</code> <p>SQL query (postgres flavor)</p> <p> TYPE: <code>str</code> </p> <code>**kwargs</code> <p>additional arguments passed to pandas.read_sql()</p> <p> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>df</code> <p> TYPE: <code>pandas.DataFrame</code> </p> Source code in <code>edsteva/io/postgres.py</code> <pre><code>def read_sql(self, sql_query: str, **kwargs) -&gt; pd.DataFrame:\n\"\"\"Execute pandas.read_sql() on the database.\n\n    Parameters\n    ----------\n    sql_query : str\n        SQL query (postgres flavor)\n    **kwargs\n        additional arguments passed to pandas.read_sql()\n\n    Returns\n    -------\n    df : pandas.DataFrame\n\n    \"\"\"\n    connection_infos = {\n        param: getattr(self, param) for param in [\"host\", \"port\", \"dbname\", \"user\"]\n    }\n    connection_infos[\"password\"] = pgpasslib.getpass(**connection_infos)\n    connection = pg.connect(**connection_infos)\n    if self.schema:\n        connection.cursor().execute(f\"SET SCHEMA '{self.schema}'\")\n\n    df = pd.read_sql(sql_query, con=connection, **kwargs)\n\n    connection.close()\n    return df\n</code></pre>"},{"location":"reference/io/settings/","title":"<code>edsteva.io.settings</code>","text":"<p>The default tables loaded when instanciating a <code>HiveData</code> or a <code>PostgresData</code></p>"},{"location":"reference/io/settings/#edsteva.io.settings.default_tables_to_save","title":"default_tables_to_save  <code>module-attribute</code>","text":"<pre><code>default_tables_to_save = [\n    \"person\",\n    \"visit_occurrence\",\n    \"visit_detail\",\n    \"condition_occurrence\",\n    \"procedure_occurrence\",\n    \"care_site\",\n    \"concept\",\n]\n</code></pre> <p>The default columns loaded when instanciating a <code>HiveData</code> or a <code>PostgresData</code></p>"},{"location":"reference/io/synthetic/","title":"<code>edsteva.io.synthetic</code>","text":""},{"location":"reference/io/synthetic/biology/","title":"<code>edsteva.io.synthetic.biology</code>","text":""},{"location":"reference/io/synthetic/care_site/","title":"<code>edsteva.io.synthetic.care_site</code>","text":""},{"location":"reference/io/synthetic/note/","title":"<code>edsteva.io.synthetic.note</code>","text":""},{"location":"reference/io/synthetic/synthetic/","title":"<code>edsteva.io.synthetic.synthetic</code>","text":""},{"location":"reference/io/synthetic/utils/","title":"<code>edsteva.io.synthetic.utils</code>","text":""},{"location":"reference/io/synthetic/visit/","title":"<code>edsteva.io.synthetic.visit</code>","text":""},{"location":"reference/metrics/","title":"<code>edsteva.metrics</code>","text":""},{"location":"reference/metrics/error/","title":"<code>edsteva.metrics.error</code>","text":""},{"location":"reference/metrics/error/#edsteva.metrics.error.error","title":"error","text":"<pre><code>error(\n    predictor: pd.DataFrame,\n    estimates: pd.DataFrame,\n    index: List[str],\n    loss_function: Callable = loss_functions.l2_loss,\n    y: str = \"c\",\n    y_0: str = \"c_0\",\n    x: str = \"date\",\n    name: str = \"error\",\n)\n</code></pre> <p>Compute the error between the predictor \\(c(t)\\) and the prediction \\(\\hat{c}(t)\\) as follow:</p> \\[ error = \\frac{\\sum_{t_{min} \\leq  t \\leq t_{max}} \\mathcal{l}(c(t), \\hat{c}(t))}{t_{max} - t_{min}} \\] <p>Where the loss function \\(\\mathcal{l}\\) can be the L1 distance or the L2 distance.</p> PARAMETER DESCRIPTION <code>predictor</code> <p>\\(c(t)\\) computed in the Probe</p> <p> TYPE: <code>pd.DataFrame</code> </p> <code>estimates</code> <p>\\(\\hat{c}(t)\\) computed in the Model</p> <p> TYPE: <code>pd.DataFrame</code> </p> <code>index</code> <p>Variable from which data is grouped</p> <p> TYPE: <code>List[str]</code> </p> <code>loss_function</code> <p>The loss function \\(\\mathcal{l}\\)</p> <p> TYPE: <code>str</code> DEFAULT: <code>loss_functions.l2_loss</code> </p> <code>y</code> <p>Target column name of \\(c(t)\\)</p> <p> TYPE: <code>str</code> DEFAULT: <code>'c'</code> </p> <code>y_0</code> <p>Target column name of \\(\\hat{c}(t)\\)</p> <p> TYPE: <code>str</code> DEFAULT: <code>'c_0'</code> </p> <code>x</code> <p>Target column name of \\(t\\)</p> <p> TYPE: <code>str</code> DEFAULT: <code>'date'</code> </p> <code>name</code> <p>Column name of the output</p> <p> TYPE: <code>str</code> DEFAULT: <code>'error'</code> </p>"},{"location":"reference/metrics/error/#edsteva.metrics.error.error--example","title":"Example","text":"care_site_level care_site_id stay_type error Unit\u00e9 Fonctionnelle (UF) 8312056386 'Urg_Hospit' 0.040 Unit\u00e9 Fonctionnelle (UF) 8312056386 'All' 0.028 P\u00f4le/DMU 8312027648 'Urg_Hospit' 0.022 P\u00f4le/DMU 8312027648 'All' 0.014 H\u00f4pital 8312022130 'Urg_Hospit' 0.027 Source code in <code>edsteva/metrics/error.py</code> <pre><code>def error(\n    predictor: pd.DataFrame,\n    estimates: pd.DataFrame,\n    index: List[str],\n    loss_function: Callable = loss_functions.l2_loss,\n    y: str = \"c\",\n    y_0: str = \"c_0\",\n    x: str = \"date\",\n    name: str = \"error\",\n):\nr\"\"\"Compute the error between the predictor $c(t)$ and the prediction $\\hat{c}(t)$ as follow:\n\n    $$\n    error = \\frac{\\sum_{t_{min} \\leq  t \\leq t_{max}} \\mathcal{l}(c(t), \\hat{c}(t))}{t_{max} - t_{min}}\n    $$\n\n    Where the loss function $\\mathcal{l}$ can be the L1 distance or the L2 distance.\n\n    Parameters\n    ----------\n    predictor : pd.DataFrame\n        $c(t)$ computed in the Probe\n    estimates : pd.DataFrame\n        $\\hat{c}(t)$ computed in the Model\n    index : List[str]\n        Variable from which data is grouped\n    loss_function : str, optional\n        The loss function $\\mathcal{l}$\n    y : str, optional\n        Target column name of $c(t)$\n    y_0 : str, optional\n        Target column name of $\\hat{c}(t)$\n    x : str, optional\n        Target column name of $t$\n    name : str, optional\n        Column name of the output\n\n    Example\n    -------\n\n    | care_site_level          | care_site_id | stay_type    | error |\n    | :----------------------- | :----------- | :----------- | :---- |\n    | Unit\u00e9 Fonctionnelle (UF) | 8312056386   | 'Urg_Hospit' | 0.040 |\n    | Unit\u00e9 Fonctionnelle (UF) | 8312056386   | 'All'        | 0.028 |\n    | P\u00f4le/DMU                 | 8312027648   | 'Urg_Hospit' | 0.022 |\n    | P\u00f4le/DMU                 | 8312027648   | 'All'        | 0.014 |\n    | H\u00f4pital                  | 8312022130   | 'Urg_Hospit' | 0.027 |\n    \"\"\"\n    check_columns(df=estimates, required_columns=[*index, y_0])\n    check_columns(df=predictor, required_columns=[*index, x, y])\n\n    fitted_predictor = predictor.merge(estimates, on=index)\n\n    fitted_predictor[\"loss\"] = loss_function(\n        fitted_predictor[y] - fitted_predictor[y_0]\n    )\n\n    error = fitted_predictor.groupby(index)[\"loss\"].mean().rename(name)\n\n    return error.reset_index()\n</code></pre>"},{"location":"reference/metrics/error_after_t0/","title":"<code>edsteva.metrics.error_after_t0</code>","text":""},{"location":"reference/metrics/error_after_t0/#edsteva.metrics.error_after_t0.error_after_t0","title":"error_after_t0","text":"<pre><code>error_after_t0(\n    predictor: pd.DataFrame,\n    estimates: pd.DataFrame,\n    index: List[str],\n    loss_function: Callable = loss_functions.l2_loss,\n    y: str = \"c\",\n    y_0: str = \"c_0\",\n    threshold: str = \"t_0\",\n    x: str = \"date\",\n    name: str = \"error\",\n)\n</code></pre> <p>Compute the error between the predictor \\(c(t)\\) and the prediction \\(\\hat{c}(t)\\) after \\(t_0\\) as follow:</p> \\[ error = \\frac{\\sum_{t_0 \\leq  t \\leq t_{max}} \\mathcal{l}(c(t), \\hat{c}(t))}{t_{max} - t_0} \\] <p>Where the loss function \\(\\mathcal{l}\\) can be the L1 distance or the L2 distance.</p> PARAMETER DESCRIPTION <code>predictor</code> <p>\\(c(t)\\) computed in the Probe</p> <p> TYPE: <code>pd.DataFrame</code> </p> <code>estimates</code> <p>\\(\\hat{c}(t)\\) computed in the Model</p> <p> TYPE: <code>pd.DataFrame</code> </p> <code>index</code> <p>Variable from which data is grouped</p> <p> TYPE: <code>List[str]</code> </p> <code>loss_function</code> <p>The loss function \\(\\mathcal{l}\\)</p> <p> TYPE: <code>Callable</code> DEFAULT: <code>loss_functions.l2_loss</code> </p> <code>y</code> <p>Column name for the completeness variable \\(c(t)\\)</p> <p> TYPE: <code>str</code> DEFAULT: <code>'c'</code> </p> <code>y_0</code> <p>Column name for the predicted completeness variable \\(\\hat{c}(t)\\)</p> <p> TYPE: <code>str</code> DEFAULT: <code>'c_0'</code> </p> <code>threshold</code> <p>Column name for the predicted threshold \\(t_0\\)</p> <p> TYPE: <code>str</code> DEFAULT: <code>'t_0'</code> </p> <code>x</code> <p>Column name for the time variable \\(t\\)</p> <p> TYPE: <code>str</code> DEFAULT: <code>'date'</code> </p> <code>name</code> <p>Column name for the metric output</p> <p> TYPE: <code>str</code> DEFAULT: <code>'error'</code> </p>"},{"location":"reference/metrics/error_after_t0/#edsteva.metrics.error_after_t0.error_after_t0--example","title":"Example","text":"care_site_level care_site_id stay_type error Unit\u00e9 Fonctionnelle (UF) 8312056386 'Urg' 0.040 Unit\u00e9 Fonctionnelle (UF) 8312056386 'All' 0.028 P\u00f4le/DMU 8312027648 'Urg' 0.022 P\u00f4le/DMU 8312027648 'All' 0.014 H\u00f4pital 8312022130 'Urg' 0.027 Source code in <code>edsteva/metrics/error_after_t0.py</code> <pre><code>def error_after_t0(\n    predictor: pd.DataFrame,\n    estimates: pd.DataFrame,\n    index: List[str],\n    loss_function: Callable = loss_functions.l2_loss,\n    y: str = \"c\",\n    y_0: str = \"c_0\",\n    threshold: str = \"t_0\",\n    x: str = \"date\",\n    name: str = \"error\",\n):\nr\"\"\"Compute the error between the predictor $c(t)$ and the prediction $\\hat{c}(t)$ after $t_0$ as follow:\n\n    $$\n    error = \\frac{\\sum_{t_0 \\leq  t \\leq t_{max}} \\mathcal{l}(c(t), \\hat{c}(t))}{t_{max} - t_0}\n    $$\n\n    Where the loss function $\\mathcal{l}$ can be the L1 distance or the L2 distance.\n\n    Parameters\n    ----------\n    predictor : pd.DataFrame\n        $c(t)$ computed in the Probe\n    estimates : pd.DataFrame\n        $\\hat{c}(t)$ computed in the Model\n    index : List[str]\n        Variable from which data is grouped\n    loss_function : Callable, optional\n        The loss function $\\mathcal{l}$\n    y : str, optional\n        Column name for the completeness variable $c(t)$\n    y_0 : str, optional\n        Column name for the predicted completeness variable $\\hat{c}(t)$\n    threshold : str, optional\n        Column name for the predicted threshold $t_0$\n    x : str, optional\n        Column name for the time variable $t$\n    name : str, optional\n        Column name for the metric output\n\n    Example\n    -------\n\n    | care_site_level          | care_site_id | stay_type | error |\n    | :----------------------- | :----------- | :---------| :---- |\n    | Unit\u00e9 Fonctionnelle (UF) | 8312056386   | 'Urg'     | 0.040 |\n    | Unit\u00e9 Fonctionnelle (UF) | 8312056386   | 'All'     | 0.028 |\n    | P\u00f4le/DMU                 | 8312027648   | 'Urg'     | 0.022 |\n    | P\u00f4le/DMU                 | 8312027648   | 'All'     | 0.014 |\n    | H\u00f4pital                  | 8312022130   | 'Urg'     | 0.027 |\n    \"\"\"\n    check_columns(df=estimates, required_columns=[*index, y_0, threshold])\n    check_columns(df=predictor, required_columns=[*index, x, y])\n\n    fitted_predictor = predictor.merge(estimates, on=index)\n\n    fitted_predictor = fitted_predictor.dropna(subset=[threshold])\n\n    fitted_predictor[\"loss\"] = loss_function(\n        fitted_predictor[y] - fitted_predictor[y_0]\n    )\n\n    mask_after_t0 = fitted_predictor[x] &gt;= fitted_predictor[threshold]\n    fitted_predictor = fitted_predictor.loc[mask_after_t0]\n\n    error = fitted_predictor.groupby(index)[\"loss\"].mean().rename(name)\n\n    return error.reset_index()\n</code></pre>"},{"location":"reference/metrics/error_between_t0_t1/","title":"<code>edsteva.metrics.error_between_t0_t1</code>","text":""},{"location":"reference/metrics/error_between_t0_t1/#edsteva.metrics.error_between_t0_t1.error_between_t0_t1","title":"error_between_t0_t1","text":"<pre><code>error_between_t0_t1(\n    predictor: pd.DataFrame,\n    estimates: pd.DataFrame,\n    index: List[str],\n    loss_function: Callable = loss_functions.l2_loss,\n    y: str = \"c\",\n    y_0: str = \"c_0\",\n    t_0: str = \"t_0\",\n    t_1: str = \"t_1\",\n    x: str = \"date\",\n    name: str = \"error\",\n)\n</code></pre> <p>Compute the error between the predictor \\(c(t)\\) and the prediction \\(\\hat{c}(t)\\) after \\(t_0\\) as follow:</p> \\[ error = \\frac{\\sum_{t_0 \\leq  t \\leq t_{max}} \\mathcal{l}(c(t), \\hat{c}(t))}{t_{max} - t_0} \\] <p>Where the loss function \\(\\mathcal{l}\\) can be the L1 distance or the L2 distance.</p> PARAMETER DESCRIPTION <code>predictor</code> <p>\\(c(t)\\) computed in the Probe</p> <p> TYPE: <code>pd.DataFrame</code> </p> <code>estimates</code> <p>\\(\\hat{c}(t)\\) computed in the Model</p> <p> TYPE: <code>pd.DataFrame</code> </p> <code>index</code> <p>Variable from which data is grouped</p> <p> TYPE: <code>List[str]</code> </p> <code>loss_function</code> <p>The loss function \\(\\mathcal{l}\\)</p> <p> TYPE: <code>Callable</code> DEFAULT: <code>loss_functions.l2_loss</code> </p> <code>y</code> <p>Column name for the completeness variable \\(c(t)\\)</p> <p> TYPE: <code>str</code> DEFAULT: <code>'c'</code> </p> <code>y_0</code> <p>Column name for the predicted completeness variable \\(\\hat{c}(t)\\)</p> <p> TYPE: <code>str</code> DEFAULT: <code>'c_0'</code> </p> <code>t_0</code> <p>Column name for the predicted threshold \\(t_0\\)</p> <p> TYPE: <code>str</code> DEFAULT: <code>'t_0'</code> </p> <code>t_1</code> <p>Column name for the predicted threshold \\(t_1\\)</p> <p> TYPE: <code>str</code> DEFAULT: <code>'t_1'</code> </p> <code>x</code> <p>Column name for the time variable \\(t\\)</p> <p> TYPE: <code>str</code> DEFAULT: <code>'date'</code> </p> <code>name</code> <p>Column name for the metric output</p> <p> TYPE: <code>str</code> DEFAULT: <code>'error'</code> </p>"},{"location":"reference/metrics/error_between_t0_t1/#edsteva.metrics.error_between_t0_t1.error_between_t0_t1--example","title":"Example","text":"care_site_level care_site_id stay_type error Unit\u00e9 Fonctionnelle (UF) 8312056386 'Urg' 0.040 Unit\u00e9 Fonctionnelle (UF) 8312056386 'All' 0.028 P\u00f4le/DMU 8312027648 'Urg' 0.022 P\u00f4le/DMU 8312027648 'All' 0.014 H\u00f4pital 8312022130 'Urg' 0.027 Source code in <code>edsteva/metrics/error_between_t0_t1.py</code> <pre><code>def error_between_t0_t1(\n    predictor: pd.DataFrame,\n    estimates: pd.DataFrame,\n    index: List[str],\n    loss_function: Callable = loss_functions.l2_loss,\n    y: str = \"c\",\n    y_0: str = \"c_0\",\n    t_0: str = \"t_0\",\n    t_1: str = \"t_1\",\n    x: str = \"date\",\n    name: str = \"error\",\n):\nr\"\"\"Compute the error between the predictor $c(t)$ and the prediction $\\hat{c}(t)$ after $t_0$ as follow:\n\n    $$\n    error = \\frac{\\sum_{t_0 \\leq  t \\leq t_{max}} \\mathcal{l}(c(t), \\hat{c}(t))}{t_{max} - t_0}\n    $$\n\n    Where the loss function $\\mathcal{l}$ can be the L1 distance or the L2 distance.\n\n    Parameters\n    ----------\n    predictor : pd.DataFrame\n        $c(t)$ computed in the Probe\n    estimates : pd.DataFrame\n        $\\hat{c}(t)$ computed in the Model\n    index : List[str]\n        Variable from which data is grouped\n    loss_function : Callable, optional\n        The loss function $\\mathcal{l}$\n    y : str, optional\n        Column name for the completeness variable $c(t)$\n    y_0 : str, optional\n        Column name for the predicted completeness variable $\\hat{c}(t)$\n    t_0 : str, optional\n        Column name for the predicted threshold $t_0$\n    t_1 : str, optional\n        Column name for the predicted threshold $t_1$\n    x : str, optional\n        Column name for the time variable $t$\n    name : str, optional\n        Column name for the metric output\n\n    Example\n    -------\n\n    | care_site_level          | care_site_id | stay_type | error |\n    | :----------------------- | :----------- | :---------| :---- |\n    | Unit\u00e9 Fonctionnelle (UF) | 8312056386   | 'Urg'     | 0.040 |\n    | Unit\u00e9 Fonctionnelle (UF) | 8312056386   | 'All'     | 0.028 |\n    | P\u00f4le/DMU                 | 8312027648   | 'Urg'     | 0.022 |\n    | P\u00f4le/DMU                 | 8312027648   | 'All'     | 0.014 |\n    | H\u00f4pital                  | 8312022130   | 'Urg'     | 0.027 |\n    \"\"\"\n    check_columns(df=estimates, required_columns=[*index, y_0, t_0, t_1])\n    check_columns(df=predictor, required_columns=[*index, x, y])\n\n    fitted_predictor = predictor.merge(estimates, on=index)\n\n    fitted_predictor = fitted_predictor.dropna(subset=[t_0, t_1])\n\n    fitted_predictor[\"loss\"] = loss_function(\n        fitted_predictor[y] - fitted_predictor[y_0]\n    )\n\n    mask_between_t0_t1 = (fitted_predictor[x] &gt;= fitted_predictor[t_0]) &amp; (\n        fitted_predictor[x] &lt;= fitted_predictor[t_1]\n    )\n    fitted_predictor = fitted_predictor.loc[mask_between_t0_t1]\n\n    error = fitted_predictor.groupby(index)[\"loss\"].mean().rename(name)\n\n    return error.reset_index()\n</code></pre>"},{"location":"reference/models/","title":"<code>edsteva.models</code>","text":""},{"location":"reference/models/base/","title":"<code>edsteva.models.base</code>","text":""},{"location":"reference/models/base/#edsteva.models.base.BaseModel","title":"BaseModel","text":"<p>Base class for Models</p> ATTRIBUTE DESCRIPTION <code>_coefs</code> <p>The list of the Model coefficients</p> <p> TYPE: <code>List[str]</code> </p> <code>estimates</code> <p>Available with the <code>fit()</code> method</p> <p> TYPE: <code>pd.DataFrame</code> </p> <code>_metrics</code> <p>Available with the <code>fit()</code> method</p> <p>The list of computed metrics if any</p> <p> TYPE: <code>List[str]</code> </p> <code>params</code> <p>Available with the <code>fit()</code> method</p> <p>Ths list of extra keyword parameters used.</p> <p> TYPE: <code>List[str]</code> </p> Source code in <code>edsteva/models/base.py</code> <pre><code>class BaseModel(metaclass=ABCMeta):\n\n\"\"\"Base class for Models\n\n    Attributes\n    ----------\n     _coefs: List[str]\n        The list of the Model coefficients\n    estimates: pd.DataFrame\n        Available with the [``fit()``][edsteva.models.base.BaseModel.fit] method\n    _metrics: List[str]\n        Available with the [``fit()``][edsteva.models.base.BaseModel.fit] method\n\n        The list of computed metrics if any\n    params: List[str]\n        Available with the [``fit()``][edsteva.models.base.BaseModel.fit] method\n\n        Ths list of extra keyword parameters used.\n    \"\"\"\n\n    def __init__(\n        self,\n        algo: str,\n        coefs: List[str],\n        default_metrics: List[str],\n    ):\n        self._algo = algo\n        self._coefs = coefs\n        self._default_metrics = default_metrics\n        self._viz_config = {}\n\n    def is_computed_estimates(self) -&gt; None:\n\"\"\"Raises an error if the Probe has not been fitted properly\"\"\"\n        if hasattr(self, \"estimates\"):\n            if isinstance(self.estimates, pd.DataFrame):\n                if len(self.estimates) == 0:\n                    raise Exception(\n                        \"Estimates are empty, please review the process method or your arguments\"\n                    )\n            else:\n                raise Exception(\n                    \"The fit process must return a Pandas Dataframe and not {}\".format(\n                        type(self.estimates).__name__\n                    )\n                )\n\n        else:\n            raise Exception(\n                \"Model has not been fitted, please use the fit method as follow: Model.fit()\"\n            )\n\n    @abstractmethod\n    def fit_process(\n        self,\n        predictor: pd.DataFrame,\n        index: List[str] = None,\n        **kwargs,\n    ):\n\"\"\"Fit the Probe in order to obtain estimates\"\"\"\n\n    @abstractmethod\n    def predict_process(\n        self,\n        prediction: pd.DataFrame,\n        **kwargs,\n    ):\n\"\"\"Compute the predicted Probe\"\"\"\n\n    def fit(\n        self,\n        probe: BaseProbe,\n        metric_functions: List[str] = None,\n        start_date: str = None,\n        end_date: str = None,\n        with_cache: bool = True,\n        **kwargs,\n    ) -&gt; None:\n\"\"\"Fit the model to the probe instance\n\n        Parameters\n        ----------\n        probe : BaseProbe\n            Target variable to be fitted\n        metric_functions : List[str], optional\n            Metrics to apply on the fitted Probe. By default it will apply the default metric specified in the model.\n\n            **EXAMPLE**: `[error, error_after_t0]`\n        start_date : str, optional\n            **EXAMPLE**: `\"2019-05-01\"`\n        end_date : str, optional\n            **EXAMPLE**: `\"2021-07-01\"`\n\n        Examples\n        --------\n        ```python\n        from edsteva.models.step_function import StepFunction\n\n        step_function_model = StepFunction()\n        step_function_model.fit(probe)\n        step_function_model.estimates.head()\n        ```\n\n        | care_site_level          | care_site_id | stay_type    | t_0        | c_0   | error |\n        | :----------------------- | :----------- | :----------- | :--------- | :---- | :---- |\n        | Unit\u00e9 Fonctionnelle (UF) | 8312056386   | 'Urg_Hospit' | 2019-05-01 | 0.397 | 0.040 |\n        | Unit\u00e9 Fonctionnelle (UF) | 8312056386   | 'All'        | 2011-04-01 | 0.583 | 0.028 |\n        | P\u00f4le/DMU                 | 8312027648   | 'Urg_Hospit' | 2021-03-01 | 0.677 | 0.022 |\n        | P\u00f4le/DMU                 | 8312027648   | 'All'        | 2018-08-01 | 0.764 | 0.014 |\n        | H\u00f4pital                  | 8312022130   | 'Urg_Hospit' | 2022-02-01 | 0.652 | 0.027 |\n        \"\"\"\n        if isinstance(probe, BaseProbe):\n            probe.is_computed_probe()\n        else:\n            raise TypeError(\n                \"Unsupported type {} for probe.\".format(type(probe).__name__)\n            )\n\n        predictor = filter_table_by_date(\n            table=probe.predictor,\n            table_name=\"predictor\",\n            start_date=start_date,\n            end_date=end_date,\n        )\n        index = probe._index\n\n        estimates = self.fit_process(\n            predictor=predictor,\n            index=index,\n            **kwargs,\n        )\n\n        metrics_df = self._compute_metrics(\n            predictor=predictor,\n            estimates=estimates,\n            index=index,\n            metric_functions=metric_functions,\n        )\n\n        if metrics_df is not None:\n            self._metrics = list(metrics_df.columns.difference(index))\n            self.estimates = estimates.merge(metrics_df, on=index)\n\n        else:\n            self.estimates = estimates\n\n        self.is_computed_estimates()\n        self.params = kwargs\n        if with_cache:\n            self.cache_estimates()\n\n    def reset_estimates(\n        self,\n    ) -&gt; None:\n\"\"\"Reset the estimates to its initial state\"\"\"\n        self.estimates = self._cache_estimates.copy()\n\n    def cache_estimates(\n        self,\n    ) -&gt; None:\n\"\"\"Cache the predictor\"\"\"\n        self._cache_estimates = self.estimates.copy()\n        logger.info(\n            \"Cache the estimates, you can reset the estimates to this state with the method reset_estimates\"\n        )\n\n    def predict(\n        self,\n        probe: BaseProbe,\n    ) -&gt; pd.DataFrame:\n\"\"\"Computes the predicted probe by using the estimates\n\n        Parameters\n        ----------\n        probe : BaseProbe\n            Target variable to be predicted\n\n        Examples\n        --------\n        ```python\n        from edsteva.models.step_function import StepFunction\n\n        step_function_model.predict(visit).head()\n        ```\n\n        | care_site_level          | care_site_id | stay_type    | date       | n_visit | c     | c_fit |\n        | :----------------------- | :----------- | :----------- | :--------- | :------ | :---- | :---- |\n        | Unit\u00e9 Fonctionnelle (UF) | 8312056386   | 'Urg_Hospit' | 2019-05-01 | 233.0   | 0.841 | 0.758 |\n        | Unit\u00e9 Fonctionnelle (UF) | 8312056386   | 'All'        | 2021-04-01 | 393.0   | 0.640 | 0.758 |\n        | P\u00f4le/DMU                 | 8312027648   | 'Urg_Hospit' | 2011-03-01 | 204.0   | 0.497 | 0     |\n        | P\u00f4le/DMU                 | 8312027648   | 'All'        | 2018-08-01 | 22.0    | 0.784 | 0.874 |\n        | H\u00f4pital                  | 8312022130   | 'Urg_Hospit' | 2022-02-01 | 9746.0  | 0.974 | 0.912 |\n\n        \"\"\"\n\n        predictor = probe.predictor\n        index = probe._index\n\n        return self.predict_process(predictor=predictor, index=index)\n\n    def load(self, path=None) -&gt; None:\n\"\"\"Loads a Model from local\n\n        Parameters\n        ----------\n        path : str, optional\n            **EXAMPLE**: `\"my_folder/my_file.html\"`\n\n        Examples\n        -------\n        ```python\n        from edsteva.probes import VisitProbe\n\n        probe_path = \"my_path/visit.pkl\"\n\n        visit = VisitProbe()\n        visit.load(path=probe_path)\n        ```\n\n        \"\"\"\n\n        path = path or self._get_path()\n        loaded_model = load_object(path)\n        self.__dict__ = loaded_model.__dict__.copy()\n        self.path = path\n\n    def save(self, path: str = None, name: str = None) -&gt; bool:\n\"\"\"Saves computed Model instance\n\n        Parameters\n        ----------\n        path : str, optional\n            **EXAMPLE**: `\"my_folder/my_file.html\"`\n        name : str, optional\n            **EXAMPLE**: `\"fitted_visit\"`\n\n        Examples\n        -------\n        ```python\n        from edsteva.probes import VisitProbe\n\n        probe_path = \"my_path/visit.pkl\"\n\n        visit = VisitProbe()\n        visit.compute(data)\n        visit.save(path=probe_path)\n        ```\n\n        \"\"\"\n\n        self.is_computed_estimates()\n\n        if name:\n            self.name = name\n        if not path:\n            path = self._get_path()\n\n        self.path = path\n        save_object(self, path)\n\n    def delete(self, path: str = None) -&gt; bool:\n\"\"\"Delete the saved Model instance\n\n        Parameters\n        ----------\n        path : str, optional\n            **EXAMPLE**: `\"my_folder/my_file.html\"`\n        \"\"\"\n        if not path:\n            path = self.path\n\n        delete_object(self, path)\n\n    def _get_path(self):\n        base_path = CACHE_DIR / \"edsteva\" / \"models\"\n        if hasattr(self, \"name\"):\n            filename = f\"{self.name.lower()}.pickle\"\n        else:\n            filename = f\"{type(self).__name__.lower()}.pickle\"\n        return base_path / filename\n\n    def _compute_metrics(\n        self,\n        predictor: pd.DataFrame,\n        estimates: pd.DataFrame,\n        index: List[str],\n        metric_functions: List[str] = None,\n    ):\n        if metric_functions is None:\n            if hasattr(self, \"_default_metrics\") and self._default_metrics:\n                metric_functions = self._default_metrics\n            else:\n                return None\n        if isinstance(metric_functions, str):\n            metric_functions = [metric_functions]\n        metrics_df = []\n        for metric_function in metric_functions:\n            metrics_df.append(\n                metrics.get(metric_function)(\n                    predictor=predictor, estimates=estimates, index=index\n                )\n            )\n        return reduce(lambda left, right: left.merge(right, on=index), metrics_df)\n\n    def is_predictable_probe(\n        self,\n        predictor: pd.DataFrame,\n        index: List[str],\n    ) -&gt; pd.DataFrame:\n\"\"\"Raises an error if the model has not been fitted on the input predictor.\n\n        Parameters\n        ----------\n        predictor : pd.DataFrame\n            Target DataFrame to be predicted\n        index : List[str]\n            List of the columns given by Probe._index\n\n        Returns\n        -------\n        pd.DataFrame\n            Predictor along with the fitted estimates\n\n        Raises\n        ------\n        Exception\n            Some indexes have no associated estimates, the model must be fitted on an adequate probe\n        \"\"\"\n        prediction = predictor.merge(\n            self.estimates, on=index, how=\"left\", validate=\"many_to_one\", indicator=True\n        )\n        if (prediction[\"_merge\"] == \"both\").all():\n            return prediction.drop(columns=\"_merge\")\n\n        raise Exception(\n            \"Some indexes have no associated estimates, the model must be fitted on an adequate probe\"\n        )\n</code></pre>"},{"location":"reference/models/base/#edsteva.models.base.BaseModel.is_computed_estimates","title":"is_computed_estimates","text":"<pre><code>is_computed_estimates() -&gt; None\n</code></pre> <p>Raises an error if the Probe has not been fitted properly</p> Source code in <code>edsteva/models/base.py</code> <pre><code>def is_computed_estimates(self) -&gt; None:\n\"\"\"Raises an error if the Probe has not been fitted properly\"\"\"\n    if hasattr(self, \"estimates\"):\n        if isinstance(self.estimates, pd.DataFrame):\n            if len(self.estimates) == 0:\n                raise Exception(\n                    \"Estimates are empty, please review the process method or your arguments\"\n                )\n        else:\n            raise Exception(\n                \"The fit process must return a Pandas Dataframe and not {}\".format(\n                    type(self.estimates).__name__\n                )\n            )\n\n    else:\n        raise Exception(\n            \"Model has not been fitted, please use the fit method as follow: Model.fit()\"\n        )\n</code></pre>"},{"location":"reference/models/base/#edsteva.models.base.BaseModel.fit_process","title":"fit_process  <code>abstractmethod</code>","text":"<pre><code>fit_process(\n    predictor: pd.DataFrame,\n    index: List[str] = None,\n    **kwargs\n)\n</code></pre> <p>Fit the Probe in order to obtain estimates</p> Source code in <code>edsteva/models/base.py</code> <pre><code>@abstractmethod\ndef fit_process(\n    self,\n    predictor: pd.DataFrame,\n    index: List[str] = None,\n    **kwargs,\n):\n\"\"\"Fit the Probe in order to obtain estimates\"\"\"\n</code></pre>"},{"location":"reference/models/base/#edsteva.models.base.BaseModel.predict_process","title":"predict_process  <code>abstractmethod</code>","text":"<pre><code>predict_process(prediction: pd.DataFrame, **kwargs)\n</code></pre> <p>Compute the predicted Probe</p> Source code in <code>edsteva/models/base.py</code> <pre><code>@abstractmethod\ndef predict_process(\n    self,\n    prediction: pd.DataFrame,\n    **kwargs,\n):\n\"\"\"Compute the predicted Probe\"\"\"\n</code></pre>"},{"location":"reference/models/base/#edsteva.models.base.BaseModel.fit","title":"fit","text":"<pre><code>fit(\n    probe: BaseProbe,\n    metric_functions: List[str] = None,\n    start_date: str = None,\n    end_date: str = None,\n    with_cache: bool = True,\n    **kwargs\n) -&gt; None\n</code></pre> <p>Fit the model to the probe instance</p> PARAMETER DESCRIPTION <code>probe</code> <p>Target variable to be fitted</p> <p> TYPE: <code>BaseProbe</code> </p> <code>metric_functions</code> <p>Metrics to apply on the fitted Probe. By default it will apply the default metric specified in the model.</p> <p>EXAMPLE: <code>[error, error_after_t0]</code></p> <p> TYPE: <code>List[str]</code> DEFAULT: <code>None</code> </p> <code>start_date</code> <p>EXAMPLE: <code>\"2019-05-01\"</code></p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> <code>end_date</code> <p>EXAMPLE: <code>\"2021-07-01\"</code></p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> <p>Examples:</p> <pre><code>from edsteva.models.step_function import StepFunction\n\nstep_function_model = StepFunction()\nstep_function_model.fit(probe)\nstep_function_model.estimates.head()\n</code></pre> care_site_level care_site_id stay_type t_0 c_0 error Unit\u00e9 Fonctionnelle (UF) 8312056386 'Urg_Hospit' 2019-05-01 0.397 0.040 Unit\u00e9 Fonctionnelle (UF) 8312056386 'All' 2011-04-01 0.583 0.028 P\u00f4le/DMU 8312027648 'Urg_Hospit' 2021-03-01 0.677 0.022 P\u00f4le/DMU 8312027648 'All' 2018-08-01 0.764 0.014 H\u00f4pital 8312022130 'Urg_Hospit' 2022-02-01 0.652 0.027 Source code in <code>edsteva/models/base.py</code> <pre><code>def fit(\n    self,\n    probe: BaseProbe,\n    metric_functions: List[str] = None,\n    start_date: str = None,\n    end_date: str = None,\n    with_cache: bool = True,\n    **kwargs,\n) -&gt; None:\n\"\"\"Fit the model to the probe instance\n\n    Parameters\n    ----------\n    probe : BaseProbe\n        Target variable to be fitted\n    metric_functions : List[str], optional\n        Metrics to apply on the fitted Probe. By default it will apply the default metric specified in the model.\n\n        **EXAMPLE**: `[error, error_after_t0]`\n    start_date : str, optional\n        **EXAMPLE**: `\"2019-05-01\"`\n    end_date : str, optional\n        **EXAMPLE**: `\"2021-07-01\"`\n\n    Examples\n    --------\n    ```python\n    from edsteva.models.step_function import StepFunction\n\n    step_function_model = StepFunction()\n    step_function_model.fit(probe)\n    step_function_model.estimates.head()\n    ```\n\n    | care_site_level          | care_site_id | stay_type    | t_0        | c_0   | error |\n    | :----------------------- | :----------- | :----------- | :--------- | :---- | :---- |\n    | Unit\u00e9 Fonctionnelle (UF) | 8312056386   | 'Urg_Hospit' | 2019-05-01 | 0.397 | 0.040 |\n    | Unit\u00e9 Fonctionnelle (UF) | 8312056386   | 'All'        | 2011-04-01 | 0.583 | 0.028 |\n    | P\u00f4le/DMU                 | 8312027648   | 'Urg_Hospit' | 2021-03-01 | 0.677 | 0.022 |\n    | P\u00f4le/DMU                 | 8312027648   | 'All'        | 2018-08-01 | 0.764 | 0.014 |\n    | H\u00f4pital                  | 8312022130   | 'Urg_Hospit' | 2022-02-01 | 0.652 | 0.027 |\n    \"\"\"\n    if isinstance(probe, BaseProbe):\n        probe.is_computed_probe()\n    else:\n        raise TypeError(\n            \"Unsupported type {} for probe.\".format(type(probe).__name__)\n        )\n\n    predictor = filter_table_by_date(\n        table=probe.predictor,\n        table_name=\"predictor\",\n        start_date=start_date,\n        end_date=end_date,\n    )\n    index = probe._index\n\n    estimates = self.fit_process(\n        predictor=predictor,\n        index=index,\n        **kwargs,\n    )\n\n    metrics_df = self._compute_metrics(\n        predictor=predictor,\n        estimates=estimates,\n        index=index,\n        metric_functions=metric_functions,\n    )\n\n    if metrics_df is not None:\n        self._metrics = list(metrics_df.columns.difference(index))\n        self.estimates = estimates.merge(metrics_df, on=index)\n\n    else:\n        self.estimates = estimates\n\n    self.is_computed_estimates()\n    self.params = kwargs\n    if with_cache:\n        self.cache_estimates()\n</code></pre>"},{"location":"reference/models/base/#edsteva.models.base.BaseModel.reset_estimates","title":"reset_estimates","text":"<pre><code>reset_estimates() -&gt; None\n</code></pre> <p>Reset the estimates to its initial state</p> Source code in <code>edsteva/models/base.py</code> <pre><code>def reset_estimates(\n    self,\n) -&gt; None:\n\"\"\"Reset the estimates to its initial state\"\"\"\n    self.estimates = self._cache_estimates.copy()\n</code></pre>"},{"location":"reference/models/base/#edsteva.models.base.BaseModel.cache_estimates","title":"cache_estimates","text":"<pre><code>cache_estimates() -&gt; None\n</code></pre> <p>Cache the predictor</p> Source code in <code>edsteva/models/base.py</code> <pre><code>def cache_estimates(\n    self,\n) -&gt; None:\n\"\"\"Cache the predictor\"\"\"\n    self._cache_estimates = self.estimates.copy()\n    logger.info(\n        \"Cache the estimates, you can reset the estimates to this state with the method reset_estimates\"\n    )\n</code></pre>"},{"location":"reference/models/base/#edsteva.models.base.BaseModel.predict","title":"predict","text":"<pre><code>predict(probe: BaseProbe) -&gt; pd.DataFrame\n</code></pre> <p>Computes the predicted probe by using the estimates</p> PARAMETER DESCRIPTION <code>probe</code> <p>Target variable to be predicted</p> <p> TYPE: <code>BaseProbe</code> </p> <p>Examples:</p> <pre><code>from edsteva.models.step_function import StepFunction\n\nstep_function_model.predict(visit).head()\n</code></pre> care_site_level care_site_id stay_type date n_visit c c_fit Unit\u00e9 Fonctionnelle (UF) 8312056386 'Urg_Hospit' 2019-05-01 233.0 0.841 0.758 Unit\u00e9 Fonctionnelle (UF) 8312056386 'All' 2021-04-01 393.0 0.640 0.758 P\u00f4le/DMU 8312027648 'Urg_Hospit' 2011-03-01 204.0 0.497 0 P\u00f4le/DMU 8312027648 'All' 2018-08-01 22.0 0.784 0.874 H\u00f4pital 8312022130 'Urg_Hospit' 2022-02-01 9746.0 0.974 0.912 Source code in <code>edsteva/models/base.py</code> <pre><code>def predict(\n    self,\n    probe: BaseProbe,\n) -&gt; pd.DataFrame:\n\"\"\"Computes the predicted probe by using the estimates\n\n    Parameters\n    ----------\n    probe : BaseProbe\n        Target variable to be predicted\n\n    Examples\n    --------\n    ```python\n    from edsteva.models.step_function import StepFunction\n\n    step_function_model.predict(visit).head()\n    ```\n\n    | care_site_level          | care_site_id | stay_type    | date       | n_visit | c     | c_fit |\n    | :----------------------- | :----------- | :----------- | :--------- | :------ | :---- | :---- |\n    | Unit\u00e9 Fonctionnelle (UF) | 8312056386   | 'Urg_Hospit' | 2019-05-01 | 233.0   | 0.841 | 0.758 |\n    | Unit\u00e9 Fonctionnelle (UF) | 8312056386   | 'All'        | 2021-04-01 | 393.0   | 0.640 | 0.758 |\n    | P\u00f4le/DMU                 | 8312027648   | 'Urg_Hospit' | 2011-03-01 | 204.0   | 0.497 | 0     |\n    | P\u00f4le/DMU                 | 8312027648   | 'All'        | 2018-08-01 | 22.0    | 0.784 | 0.874 |\n    | H\u00f4pital                  | 8312022130   | 'Urg_Hospit' | 2022-02-01 | 9746.0  | 0.974 | 0.912 |\n\n    \"\"\"\n\n    predictor = probe.predictor\n    index = probe._index\n\n    return self.predict_process(predictor=predictor, index=index)\n</code></pre>"},{"location":"reference/models/base/#edsteva.models.base.BaseModel.load","title":"load","text":"<pre><code>load(path = None) -&gt; None\n</code></pre> <p>Loads a Model from local</p> PARAMETER DESCRIPTION <code>path</code> <p>EXAMPLE: <code>\"my_folder/my_file.html\"</code></p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> <p>Examples:</p> <pre><code>from edsteva.probes import VisitProbe\n\nprobe_path = \"my_path/visit.pkl\"\n\nvisit = VisitProbe()\nvisit.load(path=probe_path)\n</code></pre> Source code in <code>edsteva/models/base.py</code> <pre><code>def load(self, path=None) -&gt; None:\n\"\"\"Loads a Model from local\n\n    Parameters\n    ----------\n    path : str, optional\n        **EXAMPLE**: `\"my_folder/my_file.html\"`\n\n    Examples\n    -------\n    ```python\n    from edsteva.probes import VisitProbe\n\n    probe_path = \"my_path/visit.pkl\"\n\n    visit = VisitProbe()\n    visit.load(path=probe_path)\n    ```\n\n    \"\"\"\n\n    path = path or self._get_path()\n    loaded_model = load_object(path)\n    self.__dict__ = loaded_model.__dict__.copy()\n    self.path = path\n</code></pre>"},{"location":"reference/models/base/#edsteva.models.base.BaseModel.save","title":"save","text":"<pre><code>save(path: str = None, name: str = None) -&gt; bool\n</code></pre> <p>Saves computed Model instance</p> PARAMETER DESCRIPTION <code>path</code> <p>EXAMPLE: <code>\"my_folder/my_file.html\"</code></p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> <code>name</code> <p>EXAMPLE: <code>\"fitted_visit\"</code></p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> <p>Examples:</p> <pre><code>from edsteva.probes import VisitProbe\n\nprobe_path = \"my_path/visit.pkl\"\n\nvisit = VisitProbe()\nvisit.compute(data)\nvisit.save(path=probe_path)\n</code></pre> Source code in <code>edsteva/models/base.py</code> <pre><code>def save(self, path: str = None, name: str = None) -&gt; bool:\n\"\"\"Saves computed Model instance\n\n    Parameters\n    ----------\n    path : str, optional\n        **EXAMPLE**: `\"my_folder/my_file.html\"`\n    name : str, optional\n        **EXAMPLE**: `\"fitted_visit\"`\n\n    Examples\n    -------\n    ```python\n    from edsteva.probes import VisitProbe\n\n    probe_path = \"my_path/visit.pkl\"\n\n    visit = VisitProbe()\n    visit.compute(data)\n    visit.save(path=probe_path)\n    ```\n\n    \"\"\"\n\n    self.is_computed_estimates()\n\n    if name:\n        self.name = name\n    if not path:\n        path = self._get_path()\n\n    self.path = path\n    save_object(self, path)\n</code></pre>"},{"location":"reference/models/base/#edsteva.models.base.BaseModel.delete","title":"delete","text":"<pre><code>delete(path: str = None) -&gt; bool\n</code></pre> <p>Delete the saved Model instance</p> PARAMETER DESCRIPTION <code>path</code> <p>EXAMPLE: <code>\"my_folder/my_file.html\"</code></p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> Source code in <code>edsteva/models/base.py</code> <pre><code>def delete(self, path: str = None) -&gt; bool:\n\"\"\"Delete the saved Model instance\n\n    Parameters\n    ----------\n    path : str, optional\n        **EXAMPLE**: `\"my_folder/my_file.html\"`\n    \"\"\"\n    if not path:\n        path = self.path\n\n    delete_object(self, path)\n</code></pre>"},{"location":"reference/models/base/#edsteva.models.base.BaseModel.is_predictable_probe","title":"is_predictable_probe","text":"<pre><code>is_predictable_probe(\n    predictor: pd.DataFrame, index: List[str]\n) -&gt; pd.DataFrame\n</code></pre> <p>Raises an error if the model has not been fitted on the input predictor.</p> PARAMETER DESCRIPTION <code>predictor</code> <p>Target DataFrame to be predicted</p> <p> TYPE: <code>pd.DataFrame</code> </p> <code>index</code> <p>List of the columns given by Probe._index</p> <p> TYPE: <code>List[str]</code> </p> RETURNS DESCRIPTION <code>pd.DataFrame</code> <p>Predictor along with the fitted estimates</p> RAISES DESCRIPTION <code>Exception</code> <p>Some indexes have no associated estimates, the model must be fitted on an adequate probe</p> Source code in <code>edsteva/models/base.py</code> <pre><code>def is_predictable_probe(\n    self,\n    predictor: pd.DataFrame,\n    index: List[str],\n) -&gt; pd.DataFrame:\n\"\"\"Raises an error if the model has not been fitted on the input predictor.\n\n    Parameters\n    ----------\n    predictor : pd.DataFrame\n        Target DataFrame to be predicted\n    index : List[str]\n        List of the columns given by Probe._index\n\n    Returns\n    -------\n    pd.DataFrame\n        Predictor along with the fitted estimates\n\n    Raises\n    ------\n    Exception\n        Some indexes have no associated estimates, the model must be fitted on an adequate probe\n    \"\"\"\n    prediction = predictor.merge(\n        self.estimates, on=index, how=\"left\", validate=\"many_to_one\", indicator=True\n    )\n    if (prediction[\"_merge\"] == \"both\").all():\n        return prediction.drop(columns=\"_merge\")\n\n    raise Exception(\n        \"Some indexes have no associated estimates, the model must be fitted on an adequate probe\"\n    )\n</code></pre>"},{"location":"reference/models/rectangle_function/","title":"<code>edsteva.models.rectangle_function</code>","text":""},{"location":"reference/models/rectangle_function/rectangle_function/","title":"<code>edsteva.models.rectangle_function.rectangle_function</code>","text":""},{"location":"reference/models/rectangle_function/rectangle_function/#edsteva.models.rectangle_function.rectangle_function.RectangleFunction","title":"RectangleFunction","text":"<p>         Bases: <code>BaseModel</code></p> <p>It models the completeness predictor \\(c(t)\\) as a rectangle function \\(f_{t_0, c_0, t_1}(t)\\) as follow:</p> \\[ f_{t_0, c_0, t_1}(t) = c_0 \\ \\mathbb{1}_{t_0 \\leq t \\leq t_1}(t) \\] <p>It computes the following estimates \\((t_0, c_0, t_1)\\):</p> <ul> <li>the characteristic time \\(t_0\\) estimates the time after which the data is available.</li> <li>the characteristic time \\(t_1\\) estimates the time after which the data is not available anymore.</li> <li>the characteristic value \\(c_0\\) estimates the completeness between \\(t_0\\) and \\(t_1\\).</li> </ul> ATTRIBUTE DESCRIPTION <code>_algo</code> <p>Algorithm used to compute the estimates.</p> <p>VALUE: <code>\"loss_minimization\"</code></p> <p> TYPE: <code>List[str]</code> </p> <code>_coefs</code> <p>Model coefficients.</p> <p>VALUE: <code>[\"t_0\", \"c_0\", \"t_1\"]</code></p> <p> TYPE: <code>List[str]</code> </p> <code>_default_metrics</code> <p>Metrics to used by default.</p> <p>VALUE: <code>[error_between_t0_t1]</code></p> <p> TYPE: <code>List[str]</code> </p> <code>_viz_config</code> <p>Dictionary of configuration for visualization purpose.</p> <p>VALUE: <code>{}</code></p> <p> TYPE: <code>List[str]</code> </p>"},{"location":"reference/models/rectangle_function/rectangle_function/#edsteva.models.rectangle_function.rectangle_function.RectangleFunction--example","title":"Example","text":"<pre><code>from edsteva.models.step_function import StepFunction\n\nstep_function_model = StepFunction()\nstep_function_model.fit(probe)\nstep_function_model.estimates.head()\n</code></pre> care_site_level care_site_id stay_type t_0 c_0 t_1 error Unit\u00e9 Fonctionnelle (UF) 8312056386 'Urg' 2019-05-01 0.397 2020-05-01 0.040 Unit\u00e9 Fonctionnelle (UF) 8312056386 'All' 2011-04-01 0.583 2013-04-01 0.028 P\u00f4le/DMU 8312027648 'Hospit' 2021-03-01 0.677 2022-03-01 0.022 P\u00f4le/DMU 8312027648 'All' 2018-08-01 0.764 2019-08-01 0.014 H\u00f4pital 8312022130 'Hospit' 2022-02-01 0.652 2022-08-01 0.027 Source code in <code>edsteva/models/rectangle_function/rectangle_function.py</code> <pre><code>class RectangleFunction(BaseModel):\nr\"\"\"It models the completeness predictor $c(t)$ as a rectangle function $f_{t_0, c_0, t_1}(t)$ as follow:\n\n    $$\n    f_{t_0, c_0, t_1}(t) = c_0 \\ \\mathbb{1}_{t_0 \\leq t \\leq t_1}(t)\n    $$\n\n    It computes the following estimates $(t_0, c_0, t_1)$:\n\n    - the characteristic time $t_0$ estimates the time after which the data is available.\n    - the characteristic time $t_1$ estimates the time after which the data is not available anymore.\n    - the characteristic value $c_0$ estimates the completeness between $t_0$ and $t_1$.\n\n    Attributes\n    ----------\n    _algo: List[str]\n        Algorithm used to compute the estimates.\n\n        **VALUE**: ``\"loss_minimization\"``\n    _coefs: List[str]\n        Model coefficients.\n\n        **VALUE**: ``[\"t_0\", \"c_0\", \"t_1\"]``\n    _default_metrics: List[str]\n        Metrics to used by default.\n\n        **VALUE**: ``[error_between_t0_t1]``\n    _viz_config: List[str]\n        Dictionary of configuration for visualization purpose.\n\n        **VALUE**: ``{}``\n\n    Example\n    ----------\n\n    ```python\n    from edsteva.models.step_function import StepFunction\n\n    step_function_model = StepFunction()\n    step_function_model.fit(probe)\n    step_function_model.estimates.head()\n    ```\n\n    | care_site_level          | care_site_id | stay_type | t_0        | c_0   | t_1        | error |\n    | :----------------------- | :----------- | :-------- | :--------- | :---- | :--------- | :---- |\n    | Unit\u00e9 Fonctionnelle (UF) | 8312056386   | 'Urg'     | 2019-05-01 | 0.397 | 2020-05-01 | 0.040 |\n    | Unit\u00e9 Fonctionnelle (UF) | 8312056386   | 'All'     | 2011-04-01 | 0.583 | 2013-04-01 | 0.028 |\n    | P\u00f4le/DMU                 | 8312027648   | 'Hospit'  | 2021-03-01 | 0.677 | 2022-03-01 | 0.022 |\n    | P\u00f4le/DMU                 | 8312027648   | 'All'     | 2018-08-01 | 0.764 | 2019-08-01 | 0.014 |\n    | H\u00f4pital                  | 8312022130   | 'Hospit'  | 2022-02-01 | 0.652 | 2022-08-01 | 0.027 |\n    \"\"\"\n\n    def __init__(\n        self,\n        algo: str = \"loss_minimization\",\n    ):\n\"\"\"Initialisation of the RectangleFunction Model.\n\n        Parameters\n        ----------\n        algo : Callable, optional\n            Algorithm used for the coefficients estimation ($t_0$, $t_1$ and $c_0$)\n        \"\"\"\n        coefs = [\"t_0\", \"c_0\", \"t_1\"]\n        default_metrics = [\"error_between_t0_t1\"]\n        super().__init__(\n            algo=algo,\n            coefs=coefs,\n            default_metrics=default_metrics,\n        )\n\n    def fit_process(\n        self,\n        predictor: pd.DataFrame,\n        index: List[str] = None,\n        **kwargs,\n    ):\n\"\"\"Script to be used by [``fit()``][edsteva.models.base.BaseModel.fit]\n\n        Parameters\n        ----------\n        predictor : pd.DataFrame\n            Target variable to be fitted\n        index : List[str], optional\n            Variable from which data is grouped.\n\n            **EXAMPLE**: `[\"care_site_level\", \"stay_type\", \"note_type\", \"care_site_id\"]`\n        \"\"\"\n        return algos.get(self._algo)(predictor=predictor, index=index, **kwargs)\n\n    def predict_process(\n        self,\n        predictor: pd.DataFrame,\n        index: List[str],\n    ):\n\"\"\"Script to be used by [``predict()``][edsteva.models.base.BaseModel.predict]\n\n        Parameters\n        ----------\n        predictor : pd.DataFrame\n            Target DataFrame to be predicted\n        index : List[str]\n            List of the columns given by Probe._index\n\n        Returns\n        -------\n        pd.DataFrame\n            Prediction\n\n        Raises\n        ------\n        Exception\n            Some indexes have no associated estimates, the model must be fitted on an adequate probe\n\n        Examples\n        --------\n        | care_site_level          | care_site_id | care_site_short_name | stay_type    | date       | n_visit | c     | c_fit |\n        | :----------------------- | :----------- | :------------------- | :----------- | :--------- | :------ | :---- | :---- |\n        | Unit\u00e9 Fonctionnelle (UF) | 8312056386   | Care site 1          | 'Urg_Hospit' | 2019-05-01 | 233.0   | 0.841 | 0.758 |\n        | Unit\u00e9 Fonctionnelle (UF) | 8312056386   | Care site 1          | 'All'        | 2021-04-01 | 393.0   | 0.640 | 0.758 |\n        | P\u00f4le/DMU                 | 8312027648   | Care site 2          | 'Urg_Hospit' | 2011-03-01 | 204.0   | 0.497 | 0     |\n        | P\u00f4le/DMU                 | 8312027648   | Care site 2          | 'All'        | 2018-08-01 | 22.0    | 0.784 | 0.874 |\n        | H\u00f4pital                  | 8312022130   | Care site 3          | 'Urg_Hospit' | 2022-02-01 | 9746.0  | 0.974 | 0.912 |\n        \"\"\"\n        prediction = self.is_predictable_probe(predictor, index)\n\n        rect_mask = (prediction[\"date\"] &gt;= prediction[\"t_0\"]) &amp; (\n            prediction[\"date\"] &lt;= prediction[\"t_1\"]\n        )\n        prediction[\"c_hat\"] = prediction[\"c_0\"].where(rect_mask, 0)\n\n        return prediction.drop(columns=self._metrics)\n\n    def get_viz_config(self, viz_type: str, **kwargs):\n        if viz_type in viz_configs.keys():\n            _viz_config = self._viz_config.get(viz_type)\n            if _viz_config is None:\n                _viz_config = \"default\"\n        else:\n            raise ValueError(f\"edsteva has no {viz_type} registry !\")\n        return viz_configs[viz_type].get(_viz_config)(self, **kwargs)\n</code></pre>"},{"location":"reference/models/rectangle_function/rectangle_function/#edsteva.models.rectangle_function.rectangle_function.RectangleFunction.__init__","title":"__init__","text":"<pre><code>__init__(algo: str = 'loss_minimization')\n</code></pre> <p>Initialisation of the RectangleFunction Model.</p> PARAMETER DESCRIPTION <code>algo</code> <p>Algorithm used for the coefficients estimation (\\(t_0\\), \\(t_1\\) and \\(c_0\\))</p> <p> TYPE: <code>Callable</code> DEFAULT: <code>'loss_minimization'</code> </p> Source code in <code>edsteva/models/rectangle_function/rectangle_function.py</code> <pre><code>def __init__(\n    self,\n    algo: str = \"loss_minimization\",\n):\n\"\"\"Initialisation of the RectangleFunction Model.\n\n    Parameters\n    ----------\n    algo : Callable, optional\n        Algorithm used for the coefficients estimation ($t_0$, $t_1$ and $c_0$)\n    \"\"\"\n    coefs = [\"t_0\", \"c_0\", \"t_1\"]\n    default_metrics = [\"error_between_t0_t1\"]\n    super().__init__(\n        algo=algo,\n        coefs=coefs,\n        default_metrics=default_metrics,\n    )\n</code></pre>"},{"location":"reference/models/rectangle_function/rectangle_function/#edsteva.models.rectangle_function.rectangle_function.RectangleFunction.fit_process","title":"fit_process","text":"<pre><code>fit_process(\n    predictor: pd.DataFrame,\n    index: List[str] = None,\n    **kwargs\n)\n</code></pre> <p>Script to be used by <code>fit()</code></p> PARAMETER DESCRIPTION <code>predictor</code> <p>Target variable to be fitted</p> <p> TYPE: <code>pd.DataFrame</code> </p> <code>index</code> <p>Variable from which data is grouped.</p> <p>EXAMPLE: <code>[\"care_site_level\", \"stay_type\", \"note_type\", \"care_site_id\"]</code></p> <p> TYPE: <code>List[str]</code> DEFAULT: <code>None</code> </p> Source code in <code>edsteva/models/rectangle_function/rectangle_function.py</code> <pre><code>def fit_process(\n    self,\n    predictor: pd.DataFrame,\n    index: List[str] = None,\n    **kwargs,\n):\n\"\"\"Script to be used by [``fit()``][edsteva.models.base.BaseModel.fit]\n\n    Parameters\n    ----------\n    predictor : pd.DataFrame\n        Target variable to be fitted\n    index : List[str], optional\n        Variable from which data is grouped.\n\n        **EXAMPLE**: `[\"care_site_level\", \"stay_type\", \"note_type\", \"care_site_id\"]`\n    \"\"\"\n    return algos.get(self._algo)(predictor=predictor, index=index, **kwargs)\n</code></pre>"},{"location":"reference/models/rectangle_function/rectangle_function/#edsteva.models.rectangle_function.rectangle_function.RectangleFunction.predict_process","title":"predict_process","text":"<pre><code>predict_process(predictor: pd.DataFrame, index: List[str])\n</code></pre> <p>Script to be used by <code>predict()</code></p> PARAMETER DESCRIPTION <code>predictor</code> <p>Target DataFrame to be predicted</p> <p> TYPE: <code>pd.DataFrame</code> </p> <code>index</code> <p>List of the columns given by Probe._index</p> <p> TYPE: <code>List[str]</code> </p> RETURNS DESCRIPTION <code>pd.DataFrame</code> <p>Prediction</p> RAISES DESCRIPTION <code>Exception</code> <p>Some indexes have no associated estimates, the model must be fitted on an adequate probe</p> <p>Examples:</p> care_site_level care_site_id care_site_short_name stay_type date n_visit c c_fit Unit\u00e9 Fonctionnelle (UF) 8312056386 Care site 1 'Urg_Hospit' 2019-05-01 233.0 0.841 0.758 Unit\u00e9 Fonctionnelle (UF) 8312056386 Care site 1 'All' 2021-04-01 393.0 0.640 0.758 P\u00f4le/DMU 8312027648 Care site 2 'Urg_Hospit' 2011-03-01 204.0 0.497 0 P\u00f4le/DMU 8312027648 Care site 2 'All' 2018-08-01 22.0 0.784 0.874 H\u00f4pital 8312022130 Care site 3 'Urg_Hospit' 2022-02-01 9746.0 0.974 0.912 Source code in <code>edsteva/models/rectangle_function/rectangle_function.py</code> <pre><code>def predict_process(\n    self,\n    predictor: pd.DataFrame,\n    index: List[str],\n):\n\"\"\"Script to be used by [``predict()``][edsteva.models.base.BaseModel.predict]\n\n    Parameters\n    ----------\n    predictor : pd.DataFrame\n        Target DataFrame to be predicted\n    index : List[str]\n        List of the columns given by Probe._index\n\n    Returns\n    -------\n    pd.DataFrame\n        Prediction\n\n    Raises\n    ------\n    Exception\n        Some indexes have no associated estimates, the model must be fitted on an adequate probe\n\n    Examples\n    --------\n    | care_site_level          | care_site_id | care_site_short_name | stay_type    | date       | n_visit | c     | c_fit |\n    | :----------------------- | :----------- | :------------------- | :----------- | :--------- | :------ | :---- | :---- |\n    | Unit\u00e9 Fonctionnelle (UF) | 8312056386   | Care site 1          | 'Urg_Hospit' | 2019-05-01 | 233.0   | 0.841 | 0.758 |\n    | Unit\u00e9 Fonctionnelle (UF) | 8312056386   | Care site 1          | 'All'        | 2021-04-01 | 393.0   | 0.640 | 0.758 |\n    | P\u00f4le/DMU                 | 8312027648   | Care site 2          | 'Urg_Hospit' | 2011-03-01 | 204.0   | 0.497 | 0     |\n    | P\u00f4le/DMU                 | 8312027648   | Care site 2          | 'All'        | 2018-08-01 | 22.0    | 0.784 | 0.874 |\n    | H\u00f4pital                  | 8312022130   | Care site 3          | 'Urg_Hospit' | 2022-02-01 | 9746.0  | 0.974 | 0.912 |\n    \"\"\"\n    prediction = self.is_predictable_probe(predictor, index)\n\n    rect_mask = (prediction[\"date\"] &gt;= prediction[\"t_0\"]) &amp; (\n        prediction[\"date\"] &lt;= prediction[\"t_1\"]\n    )\n    prediction[\"c_hat\"] = prediction[\"c_0\"].where(rect_mask, 0)\n\n    return prediction.drop(columns=self._metrics)\n</code></pre>"},{"location":"reference/models/rectangle_function/algos/","title":"<code>edsteva.models.rectangle_function.algos</code>","text":""},{"location":"reference/models/rectangle_function/algos/loss_minimization/","title":"<code>edsteva.models.rectangle_function.algos.loss_minimization</code>","text":""},{"location":"reference/models/rectangle_function/algos/loss_minimization/#edsteva.models.rectangle_function.algos.loss_minimization.loss_minimization","title":"loss_minimization","text":"<pre><code>loss_minimization(\n    predictor: pd.DataFrame,\n    index: List[str],\n    x_col: str = \"date\",\n    y_col: str = \"c\",\n    loss_function: Callable = l2_loss,\n    min_rect_month_width=3,\n)\n</code></pre> <p>Computes the threshold \\(t_0\\) and \\(t_1\\) of a predictor \\(c(t)\\) by minimizing the following loss function:</p> \\[ \\begin{aligned} \\mathcal{L}(t_0, t_1) &amp; = \\frac{\\sum_{t = t_{min}}^{t_{max}} \\mathcal{l}(c(t), f_{t_0, t_1}(t))}{t_{max} - t_{min}} \\\\ (\\hat{t_0}, \\hat{t_1}) &amp; = \\underset{t_0, t_1}{\\mathrm{argmin}}(\\mathcal{L}(t_0, t_1)) \\end{aligned} \\] <p>Where the loss function \\(\\mathcal{l}\\) is by default the L2 distance and the estimated completeness \\(c_0\\) is the mean completeness between \\(t_0\\) and \\(t_1\\).</p> \\[ \\begin{aligned} \\mathcal{l}(c(t), f_{t_0, t_1}(t)) &amp; = |c(t) - f_{t_0, t_1}(t)|^2 \\\\ c_0 &amp; = \\frac{\\sum_{t = t_0}^{t_1} c(t)}{t_1 - t_0} \\end{aligned} \\] PARAMETER DESCRIPTION <code>predictor</code> <p>\\(c(t)\\) computed in the Probe.</p> <p> TYPE: <code>pd.DataFrame</code> </p> <code>index</code> <p>Variable from which data is grouped.</p> <p>EXAMPLE: <code>[\"care_site_level\", \"stay_type\", \"note_type\", \"care_site_id\"]</code></p> <p> TYPE: <code>List[str]</code> </p> <code>x_col</code> <p>Column name for the time variable \\(t\\).</p> <p> TYPE: <code>str</code> DEFAULT: <code>'date'</code> </p> <code>y_col</code> <p>Column name  for the completeness variable \\(c(t)\\).</p> <p> TYPE: <code>str</code> DEFAULT: <code>'c'</code> </p> <code>loss_function</code> <p>The loss function \\(\\mathcal{L}\\).</p> <p> TYPE: <code>Callable</code> DEFAULT: <code>l2_loss</code> </p> <code>min_rect_month_width</code> <p>Min number of months between \\(t_0\\) and \\(t_1\\).</p> <p> TYPE: <code>int</code> DEFAULT: <code>3</code> </p> Source code in <code>edsteva/models/rectangle_function/algos/loss_minimization.py</code> <pre><code>def loss_minimization(\n    predictor: pd.DataFrame,\n    index: List[str],\n    x_col: str = \"date\",\n    y_col: str = \"c\",\n    loss_function: Callable = l2_loss,\n    min_rect_month_width=3,\n):\nr\"\"\"Computes the threshold $t_0$ and $t_1$ of a predictor $c(t)$ by minimizing the following loss function:\n\n    $$\n    \\begin{aligned}\n    \\mathcal{L}(t_0, t_1) &amp; = \\frac{\\sum_{t = t_{min}}^{t_{max}} \\mathcal{l}(c(t), f_{t_0, t_1}(t))}{t_{max} - t_{min}} \\\\\n    (\\hat{t_0}, \\hat{t_1}) &amp; = \\underset{t_0, t_1}{\\mathrm{argmin}}(\\mathcal{L}(t_0, t_1))\n    \\end{aligned}\n    $$\n\n    Where the loss function $\\mathcal{l}$ is by default the L2 distance and the estimated completeness $c_0$ is the mean completeness between $t_0$ and $t_1$.\n\n    $$\n    \\begin{aligned}\n    \\mathcal{l}(c(t), f_{t_0, t_1}(t)) &amp; = |c(t) - f_{t_0, t_1}(t)|^2 \\\\\n    c_0 &amp; = \\frac{\\sum_{t = t_0}^{t_1} c(t)}{t_1 - t_0}\n    \\end{aligned}\n    $$\n\n\n\n    Parameters\n    ----------\n    predictor : pd.DataFrame\n        $c(t)$ computed in the Probe.\n    index : List[str]\n        Variable from which data is grouped.\n\n        **EXAMPLE**: `[\"care_site_level\", \"stay_type\", \"note_type\", \"care_site_id\"]`\n    x_col : str, optional\n        Column name for the time variable $t$.\n    y_col : str, optional\n        Column name  for the completeness variable $c(t)$.\n    loss_function : Callable, optional\n        The loss function $\\mathcal{L}$.\n    min_rect_month_width : int, optional\n        Min number of months between $t_0$ and $t_1$.\n    \"\"\"\n    check_columns(df=predictor, required_columns=[*index, x_col, y_col])\n    predictor = predictor.sort_values(x_col)\n    cols = [*index, x_col, y_col]\n    iter = predictor[cols].groupby(index)\n    results = []\n    for partition, group in tqdm.tqdm(iter):\n        row = dict(zip(index, partition))\n        t_0, c_0, t_1 = _compute_one_double_threshold(\n            group,\n            x_col,\n            y_col,\n            loss_function,\n            min_rect_month_width,\n        )\n        row[\"t_0\"] = t_0\n        row[\"c_0\"] = c_0\n        row[\"t_1\"] = t_1\n        results.append(row)\n\n    return pd.DataFrame(results)\n</code></pre>"},{"location":"reference/models/rectangle_function/viz_configs/","title":"<code>edsteva.models.rectangle_function.viz_configs</code>","text":""},{"location":"reference/models/rectangle_function/viz_configs/defaults/","title":"<code>edsteva.models.rectangle_function.viz_configs.defaults</code>","text":""},{"location":"reference/models/rectangle_function/viz_configs/normalized_probe_dashboard/","title":"<code>edsteva.models.rectangle_function.viz_configs.normalized_probe_dashboard</code>","text":""},{"location":"reference/models/rectangle_function/viz_configs/normalized_probe_plot/","title":"<code>edsteva.models.rectangle_function.viz_configs.normalized_probe_plot</code>","text":""},{"location":"reference/models/rectangle_function/viz_configs/probe_dashboard/","title":"<code>edsteva.models.rectangle_function.viz_configs.probe_dashboard</code>","text":""},{"location":"reference/models/rectangle_function/viz_configs/probe_plot/","title":"<code>edsteva.models.rectangle_function.viz_configs.probe_plot</code>","text":""},{"location":"reference/models/step_function/","title":"<code>edsteva.models.step_function</code>","text":""},{"location":"reference/models/step_function/step_function/","title":"<code>edsteva.models.step_function.step_function</code>","text":""},{"location":"reference/models/step_function/step_function/#edsteva.models.step_function.step_function.StepFunction","title":"StepFunction","text":"<p>         Bases: <code>BaseModel</code></p> <p>It models the completeness predictor \\(c(t)\\) as a step function \\(f_{t_0, c_0}(t)\\) as follow:</p> \\[ f_{t_0, c_0}(t) = c_0 \\ \\mathbb{1}_{t \\geq t_0}(t) \\] <p>It computes the following estimates \\((t_0, c_0)\\):</p> <ul> <li>the characteristic time \\(t_0\\) estimates the time after which the data is available</li> <li>the characteristic value \\(c_0\\) estimates the stabilized routine completeness</li> </ul> ATTRIBUTE DESCRIPTION <code>_algo</code> <p>Algorithm used to compute the estimates.</p> <p>VALUE: <code>\"loss_minimization\"</code></p> <p> TYPE: <code>List[str]</code> </p> <code>_coefs</code> <p>Model coefficients.</p> <p>VALUE: <code>[\"t_0\", \"c_0\"]</code></p> <p> TYPE: <code>List[str]</code> </p> <code>_default_metrics</code> <p>Metrics to used by default.</p> <p>VALUE: <code>[error_after_t0]</code></p> <p> TYPE: <code>List[str]</code> </p> <code>_viz_config</code> <p>Dictionary of configuration for visualization purpose.</p> <p>VALUE: <code>{}</code></p> <p> TYPE: <code>List[str]</code> </p>"},{"location":"reference/models/step_function/step_function/#edsteva.models.step_function.step_function.StepFunction--example","title":"Example","text":"<pre><code>from edsteva.models.step_function import StepFunction\n\nstep_function_model = StepFunction()\nstep_function_model.fit(probe)\nstep_function_model.estimates.head()\n</code></pre> care_site_level care_site_id stay_type t_0 c_0 Unit\u00e9 Fonctionnelle (UF) 8312056386 'Urg_Hospit' 2019-05-01 0.397 Unit\u00e9 Fonctionnelle (UF) 8312056386 'All' 2011-04-01 0.583 P\u00f4le/DMU 8312027648 'Urg_Hospit' 2021-03-01 0.677 P\u00f4le/DMU 8312027648 'All' 2018-08-01 0.764 H\u00f4pital 8312022130 'Urg_Hospit' 2022-02-01 0.652 Source code in <code>edsteva/models/step_function/step_function.py</code> <pre><code>class StepFunction(BaseModel):\nr\"\"\"It models the completeness predictor $c(t)$ as a step function $f_{t_0, c_0}(t)$ as follow:\n\n    $$\n    f_{t_0, c_0}(t) = c_0 \\ \\mathbb{1}_{t \\geq t_0}(t)\n    $$\n\n    It computes the following estimates $(t_0, c_0)$:\n\n    - the characteristic time $t_0$ estimates the time after which the data is available\n    - the characteristic value $c_0$ estimates the stabilized routine completeness\n\n    Attributes\n    ----------\n    _algo: List[str]\n        Algorithm used to compute the estimates.\n\n        **VALUE**: ``\"loss_minimization\"``\n    _coefs: List[str]\n        Model coefficients.\n\n        **VALUE**: ``[\"t_0\", \"c_0\"]``\n    _default_metrics: List[str]\n        Metrics to used by default.\n\n        **VALUE**: ``[error_after_t0]``\n    _viz_config: List[str]\n        Dictionary of configuration for visualization purpose.\n\n        **VALUE**: ``{}``\n\n    Example\n    ----------\n\n    ```python\n    from edsteva.models.step_function import StepFunction\n\n    step_function_model = StepFunction()\n    step_function_model.fit(probe)\n    step_function_model.estimates.head()\n    ```\n\n    | care_site_level          | care_site_id | stay_type    | t_0        | c_0   |\n    | :----------------------- | :----------- | :----------- | :--------- | :---- |\n    | Unit\u00e9 Fonctionnelle (UF) | 8312056386   | 'Urg_Hospit' | 2019-05-01 | 0.397 |\n    | Unit\u00e9 Fonctionnelle (UF) | 8312056386   | 'All'        | 2011-04-01 | 0.583 |\n    | P\u00f4le/DMU                 | 8312027648   | 'Urg_Hospit' | 2021-03-01 | 0.677 |\n    | P\u00f4le/DMU                 | 8312027648   | 'All'        | 2018-08-01 | 0.764 |\n    | H\u00f4pital                  | 8312022130   | 'Urg_Hospit' | 2022-02-01 | 0.652 |\n    \"\"\"\n\n    def __init__(\n        self,\n        algo: str = \"loss_minimization\",\n    ):\n\"\"\"Initialisation of the StepFunction Model.\n\n        Parameters\n        ----------\n        algo : Callable, optional\n            Algorithm used for the coefficients estimation ($t_0$ and $c_0$)\n        \"\"\"\n        coefs = [\"t_0\", \"c_0\"]\n        default_metrics = [\"error_after_t0\"]\n        super().__init__(\n            algo=algo,\n            coefs=coefs,\n            default_metrics=default_metrics,\n        )\n\n    def fit_process(\n        self,\n        predictor: pd.DataFrame,\n        index: List[str] = None,\n        **kwargs,\n    ) -&gt; None:\n\"\"\"Script to be used by [``fit()``][edsteva.models.base.BaseModel.fit]\n\n        Parameters\n        ----------\n        predictor : pd.DataFrame\n            Target variable to be fitted\n        index : List[str], optional\n            Variable from which data is grouped.\n\n            **EXAMPLE**: `[\"care_site_level\", \"stay_type\", \"note_type\", \"care_site_id\"]`\n        \"\"\"\n\n        estimates = algos.get(self._algo)(predictor=predictor, index=index, **kwargs)\n\n        return estimates[index + self._coefs]\n\n    def predict_process(\n        self,\n        predictor: pd.DataFrame,\n        index: List[str],\n    ) -&gt; pd.DataFrame:\n\"\"\"Script to be used by [``predict()``][edsteva.models.base.BaseModel.predict]\n\n        Parameters\n        ----------\n        predictor : pd.DataFrame\n            Target DataFrame to be predicted\n        index : List[str]\n            List of the columns given by Probe._index\n\n        Returns\n        -------\n        pd.DataFrame\n            Prediction\n\n        Raises\n        ------\n        Exception\n            Some indexes have no associated estimates, the model must be fitted on an adequate probe\n\n        Examples\n        --------\n        | care_site_level          | care_site_id | care_site_short_name | stay_type    | date       | n_visit | c     | c_fit |\n        | :----------------------- | :----------- | :------------------- | :----------- | :--------- | :------ | :---- | :---- |\n        | Unit\u00e9 Fonctionnelle (UF) | 8312056386   | Care site 1          | 'Urg_Hospit' | 2019-05-01 | 233.0   | 0.841 | 0.758 |\n        | Unit\u00e9 Fonctionnelle (UF) | 8312056386   | Care site 1          | 'All'        | 2021-04-01 | 393.0   | 0.640 | 0.758 |\n        | P\u00f4le/DMU                 | 8312027648   | Care site 2          | 'Urg_Hospit' | 2011-03-01 | 204.0   | 0.497 | 0     |\n        | P\u00f4le/DMU                 | 8312027648   | Care site 2          | 'All'        | 2018-08-01 | 22.0    | 0.784 | 0.874 |\n        | H\u00f4pital                  | 8312022130   | Care site 3          | 'Urg_Hospit' | 2022-02-01 | 9746.0  | 0.974 | 0.912 |\n        \"\"\"\n\n        prediction = self.is_predictable_probe(predictor=predictor, index=index)\n\n        prediction[\"c_hat\"] = prediction[\"c_0\"].where(\n            prediction[\"date\"] &gt;= prediction[\"t_0\"], 0\n        )\n        return prediction.drop(columns=self._metrics)\n\n    def get_viz_config(self, viz_type: str, **kwargs):\n        if viz_type in viz_configs.keys():\n            _viz_config = self._viz_config.get(viz_type)\n            if _viz_config is None:\n                _viz_config = \"default\"\n        else:\n            raise ValueError(f\"edsteva has no {viz_type} registry !\")\n        return viz_configs[viz_type].get(_viz_config)(self, **kwargs)\n</code></pre>"},{"location":"reference/models/step_function/step_function/#edsteva.models.step_function.step_function.StepFunction.__init__","title":"__init__","text":"<pre><code>__init__(algo: str = 'loss_minimization')\n</code></pre> <p>Initialisation of the StepFunction Model.</p> PARAMETER DESCRIPTION <code>algo</code> <p>Algorithm used for the coefficients estimation (\\(t_0\\) and \\(c_0\\))</p> <p> TYPE: <code>Callable</code> DEFAULT: <code>'loss_minimization'</code> </p> Source code in <code>edsteva/models/step_function/step_function.py</code> <pre><code>def __init__(\n    self,\n    algo: str = \"loss_minimization\",\n):\n\"\"\"Initialisation of the StepFunction Model.\n\n    Parameters\n    ----------\n    algo : Callable, optional\n        Algorithm used for the coefficients estimation ($t_0$ and $c_0$)\n    \"\"\"\n    coefs = [\"t_0\", \"c_0\"]\n    default_metrics = [\"error_after_t0\"]\n    super().__init__(\n        algo=algo,\n        coefs=coefs,\n        default_metrics=default_metrics,\n    )\n</code></pre>"},{"location":"reference/models/step_function/step_function/#edsteva.models.step_function.step_function.StepFunction.fit_process","title":"fit_process","text":"<pre><code>fit_process(\n    predictor: pd.DataFrame,\n    index: List[str] = None,\n    **kwargs\n) -&gt; None\n</code></pre> <p>Script to be used by <code>fit()</code></p> PARAMETER DESCRIPTION <code>predictor</code> <p>Target variable to be fitted</p> <p> TYPE: <code>pd.DataFrame</code> </p> <code>index</code> <p>Variable from which data is grouped.</p> <p>EXAMPLE: <code>[\"care_site_level\", \"stay_type\", \"note_type\", \"care_site_id\"]</code></p> <p> TYPE: <code>List[str]</code> DEFAULT: <code>None</code> </p> Source code in <code>edsteva/models/step_function/step_function.py</code> <pre><code>def fit_process(\n    self,\n    predictor: pd.DataFrame,\n    index: List[str] = None,\n    **kwargs,\n) -&gt; None:\n\"\"\"Script to be used by [``fit()``][edsteva.models.base.BaseModel.fit]\n\n    Parameters\n    ----------\n    predictor : pd.DataFrame\n        Target variable to be fitted\n    index : List[str], optional\n        Variable from which data is grouped.\n\n        **EXAMPLE**: `[\"care_site_level\", \"stay_type\", \"note_type\", \"care_site_id\"]`\n    \"\"\"\n\n    estimates = algos.get(self._algo)(predictor=predictor, index=index, **kwargs)\n\n    return estimates[index + self._coefs]\n</code></pre>"},{"location":"reference/models/step_function/step_function/#edsteva.models.step_function.step_function.StepFunction.predict_process","title":"predict_process","text":"<pre><code>predict_process(\n    predictor: pd.DataFrame, index: List[str]\n) -&gt; pd.DataFrame\n</code></pre> <p>Script to be used by <code>predict()</code></p> PARAMETER DESCRIPTION <code>predictor</code> <p>Target DataFrame to be predicted</p> <p> TYPE: <code>pd.DataFrame</code> </p> <code>index</code> <p>List of the columns given by Probe._index</p> <p> TYPE: <code>List[str]</code> </p> RETURNS DESCRIPTION <code>pd.DataFrame</code> <p>Prediction</p> RAISES DESCRIPTION <code>Exception</code> <p>Some indexes have no associated estimates, the model must be fitted on an adequate probe</p> <p>Examples:</p> care_site_level care_site_id care_site_short_name stay_type date n_visit c c_fit Unit\u00e9 Fonctionnelle (UF) 8312056386 Care site 1 'Urg_Hospit' 2019-05-01 233.0 0.841 0.758 Unit\u00e9 Fonctionnelle (UF) 8312056386 Care site 1 'All' 2021-04-01 393.0 0.640 0.758 P\u00f4le/DMU 8312027648 Care site 2 'Urg_Hospit' 2011-03-01 204.0 0.497 0 P\u00f4le/DMU 8312027648 Care site 2 'All' 2018-08-01 22.0 0.784 0.874 H\u00f4pital 8312022130 Care site 3 'Urg_Hospit' 2022-02-01 9746.0 0.974 0.912 Source code in <code>edsteva/models/step_function/step_function.py</code> <pre><code>def predict_process(\n    self,\n    predictor: pd.DataFrame,\n    index: List[str],\n) -&gt; pd.DataFrame:\n\"\"\"Script to be used by [``predict()``][edsteva.models.base.BaseModel.predict]\n\n    Parameters\n    ----------\n    predictor : pd.DataFrame\n        Target DataFrame to be predicted\n    index : List[str]\n        List of the columns given by Probe._index\n\n    Returns\n    -------\n    pd.DataFrame\n        Prediction\n\n    Raises\n    ------\n    Exception\n        Some indexes have no associated estimates, the model must be fitted on an adequate probe\n\n    Examples\n    --------\n    | care_site_level          | care_site_id | care_site_short_name | stay_type    | date       | n_visit | c     | c_fit |\n    | :----------------------- | :----------- | :------------------- | :----------- | :--------- | :------ | :---- | :---- |\n    | Unit\u00e9 Fonctionnelle (UF) | 8312056386   | Care site 1          | 'Urg_Hospit' | 2019-05-01 | 233.0   | 0.841 | 0.758 |\n    | Unit\u00e9 Fonctionnelle (UF) | 8312056386   | Care site 1          | 'All'        | 2021-04-01 | 393.0   | 0.640 | 0.758 |\n    | P\u00f4le/DMU                 | 8312027648   | Care site 2          | 'Urg_Hospit' | 2011-03-01 | 204.0   | 0.497 | 0     |\n    | P\u00f4le/DMU                 | 8312027648   | Care site 2          | 'All'        | 2018-08-01 | 22.0    | 0.784 | 0.874 |\n    | H\u00f4pital                  | 8312022130   | Care site 3          | 'Urg_Hospit' | 2022-02-01 | 9746.0  | 0.974 | 0.912 |\n    \"\"\"\n\n    prediction = self.is_predictable_probe(predictor=predictor, index=index)\n\n    prediction[\"c_hat\"] = prediction[\"c_0\"].where(\n        prediction[\"date\"] &gt;= prediction[\"t_0\"], 0\n    )\n    return prediction.drop(columns=self._metrics)\n</code></pre>"},{"location":"reference/models/step_function/algos/","title":"<code>edsteva.models.step_function.algos</code>","text":""},{"location":"reference/models/step_function/algos/loss_minimization/","title":"<code>edsteva.models.step_function.algos.loss_minimization</code>","text":""},{"location":"reference/models/step_function/algos/loss_minimization/#edsteva.models.step_function.algos.loss_minimization.loss_minimization","title":"loss_minimization","text":"<pre><code>loss_minimization(\n    predictor: pd.DataFrame,\n    index: List[str],\n    x_col: str = \"date\",\n    y_col: str = \"c\",\n    loss_function: Callable = l2_loss,\n) -&gt; pd.DataFrame\n</code></pre> <p>Computes the threshold \\(t_0\\) of a predictor \\(c(t)\\) by minimizing the following loss function:</p> \\[ \\begin{aligned} \\mathcal{L}(t_0) &amp; = \\frac{\\sum_{t = t_{min}}^{t_{max}} \\mathcal{l}(c(t), f_{t_0}(t))}{t_{max} - t_{min}} \\\\ \\hat{t_0} &amp; = \\underset{t_0}{\\mathrm{argmin}}(\\mathcal{L}(t_0)) \\end{aligned} \\] <p>Where the loss function \\(\\mathcal{l}\\) is by default the L2 distance and the estimated completeness \\(c_0\\) is the mean completeness after \\(t_0\\).</p> \\[ \\begin{aligned} \\mathcal{l}(c(t), f_{t_0}(t)) &amp; = |c(t) - f_{t_0}(t)|^2 \\\\ c_0 &amp; = \\frac{\\sum_{t = t_0}^{t_{max}} c(t)}{t_{max} - t_0} \\end{aligned} \\] PARAMETER DESCRIPTION <code>predictor</code> <p>\\(c(t)\\) computed in the Probe</p> <p> TYPE: <code>pd.DataFrame</code> </p> <code>index</code> <p>Variable from which data is grouped</p> <p>EXAMPLE: <code>[\"care_site_level\", \"stay_type\", \"note_type\", \"care_site_id\"]</code></p> <p> TYPE: <code>List[str]</code> </p> <code>x_col</code> <p>Column name for the time variable \\(t\\)</p> <p> TYPE: <code>str</code> DEFAULT: <code>'date'</code> </p> <code>y_col</code> <p>Column name  for the completeness variable \\(c(t)\\)</p> <p> TYPE: <code>str</code> DEFAULT: <code>'c'</code> </p> <code>loss_function</code> <p>The loss function \\(\\mathcal{L}\\)</p> <p> TYPE: <code>Callable</code> DEFAULT: <code>l2_loss</code> </p> Source code in <code>edsteva/models/step_function/algos/loss_minimization.py</code> <pre><code>def loss_minimization(\n    predictor: pd.DataFrame,\n    index: List[str],\n    x_col: str = \"date\",\n    y_col: str = \"c\",\n    loss_function: Callable = l2_loss,\n) -&gt; pd.DataFrame:\nr\"\"\"Computes the threshold $t_0$ of a predictor $c(t)$ by minimizing the following loss function:\n\n    $$\n    \\begin{aligned}\n    \\mathcal{L}(t_0) &amp; = \\frac{\\sum_{t = t_{min}}^{t_{max}} \\mathcal{l}(c(t), f_{t_0}(t))}{t_{max} - t_{min}} \\\\\n    \\hat{t_0} &amp; = \\underset{t_0}{\\mathrm{argmin}}(\\mathcal{L}(t_0))\n    \\end{aligned}\n    $$\n\n    Where the loss function $\\mathcal{l}$ is by default the L2 distance and the estimated completeness $c_0$ is the mean completeness after $t_0$.\n\n    $$\n    \\begin{aligned}\n    \\mathcal{l}(c(t), f_{t_0}(t)) &amp; = |c(t) - f_{t_0}(t)|^2 \\\\\n    c_0 &amp; = \\frac{\\sum_{t = t_0}^{t_{max}} c(t)}{t_{max} - t_0}\n    \\end{aligned}\n    $$\n\n\n    Parameters\n    ----------\n    predictor : pd.DataFrame\n        $c(t)$ computed in the Probe\n    index : List[str]\n        Variable from which data is grouped\n\n        **EXAMPLE**: `[\"care_site_level\", \"stay_type\", \"note_type\", \"care_site_id\"]`\n    x_col : str, optional\n        Column name for the time variable $t$\n    y_col : str, optional\n        Column name  for the completeness variable $c(t)$\n    loss_function : Callable, optional\n        The loss function $\\mathcal{L}$\n    \"\"\"\n    check_columns(df=predictor, required_columns=[*index, x_col, y_col])\n    predictor = predictor.sort_values(x_col)\n    cols = [*index, x_col, y_col]\n    iter = predictor[cols].groupby(index)\n    results = []\n    for partition, group in tqdm.tqdm(iter):\n        row = dict(zip(index, partition))\n        t_0, c_0 = _compute_one_threshold(\n            group,\n            x_col,\n            y_col,\n            loss_function,\n        )\n        row[\"t_0\"] = t_0\n        row[\"c_0\"] = c_0\n        results.append(row)\n\n    return pd.DataFrame(results)\n</code></pre>"},{"location":"reference/models/step_function/algos/quantile/","title":"<code>edsteva.models.step_function.algos.quantile</code>","text":""},{"location":"reference/models/step_function/algos/quantile/#edsteva.models.step_function.algos.quantile.c_0_from_quantile","title":"c_0_from_quantile","text":"<pre><code>c_0_from_quantile(\n    predictor: pd.DataFrame,\n    index: List[str],\n    q: float = 0.8,\n    x: str = \"date\",\n    y: str = \"c\",\n) -&gt; pd.DataFrame\n</code></pre> <p>Compute the quantile on the given y-axis. Column \\(c_0\\) is created.</p> \\[ \\hat{c_0} = x^{th} \\text{ quantile of } c(t) \\] PARAMETER DESCRIPTION <code>predictor</code> <p>\\(c(t)\\) computed in the Probe</p> <p> TYPE: <code>pd.DataFrame</code> </p> <code>index</code> <p>Variable from which data is grouped</p> <p>EXAMPLE: <code>[\"care_site_level\", \"stay_type\", \"note_type\", \"care_site_id\"]</code></p> <p> TYPE: <code>List[str]</code> </p> <code>q</code> <p>Quantile value</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.8</code> </p> <code>x</code> <p>Column name for the time variable \\(t\\)</p> <p> TYPE: <code>str</code> DEFAULT: <code>'date'</code> </p> <code>y</code> <p>Column name  for the completeness variable \\(c(t)\\)</p> <p> TYPE: <code>str</code> DEFAULT: <code>'c'</code> </p> Source code in <code>edsteva/models/step_function/algos/quantile.py</code> <pre><code>def c_0_from_quantile(\n    predictor: pd.DataFrame,\n    index: List[str],\n    q: float = 0.8,\n    x: str = \"date\",\n    y: str = \"c\",\n) -&gt; pd.DataFrame:\nr\"\"\"Compute the quantile on the given y-axis. Column $c_0$ is created.\n\n    $$\n    \\hat{c_0} = x^{th} \\text{ quantile of } c(t)\n    $$\n\n    Parameters\n    ----------\n    predictor : pd.DataFrame\n        $c(t)$ computed in the Probe\n    index : List[str]\n        Variable from which data is grouped\n\n        **EXAMPLE**: `[\"care_site_level\", \"stay_type\", \"note_type\", \"care_site_id\"]`\n    q : float, optional\n        Quantile value\n    x : str, optional\n        Column name for the time variable $t$\n    y : str, optional\n        Column name  for the completeness variable $c(t)$\n    \"\"\"\n\n    check_columns(df=predictor, required_columns=[*index, x, y])\n\n    quantile = (\n        predictor.groupby(index)[[y]]\n        .agg(lambda g: np.quantile(g, q=q))\n        .rename(columns={y: \"c_0\"})\n    )\n\n    return predictor.merge(quantile, on=index)\n</code></pre>"},{"location":"reference/models/step_function/algos/quantile/#edsteva.models.step_function.algos.quantile.t_0_from_c_0","title":"t_0_from_c_0","text":"<pre><code>t_0_from_c_0(\n    predictor: pd.DataFrame,\n    index: List[str],\n    x: str = \"date\",\n    y: str = \"c\",\n    threshold: str = \"c_0\",\n) -&gt; pd.DataFrame\n</code></pre> <p>Compute \\(t_0\\) column using value of \\(c_0\\)</p> <p>Returns the first date at which values are greater than \\(c_0\\):</p> \\[ \\hat{t_0} = \\underset{t}{\\mathrm{argmin}}(c(t) \\geq \\hat{c_0}) \\] PARAMETER DESCRIPTION <code>predictor</code> <p>\\(c(t)\\) computed in the Probe</p> <p> TYPE: <code>pd.DataFrame</code> </p> <code>index</code> <p>Variable from which data is grouped</p> <p> TYPE: <code>List[str]</code> </p> <code>x</code> <p>Column name for the time variable \\(t\\)</p> <p> TYPE: <code>str</code> DEFAULT: <code>'date'</code> </p> <code>y</code> <p>Column name  for the completeness variable \\(c(t)\\)</p> <p> TYPE: <code>str</code> DEFAULT: <code>'c'</code> </p> <code>threshold</code> <p>Column name  for the threshold variable \\(t_0\\)</p> <p> TYPE: <code>str</code> DEFAULT: <code>'c_0'</code> </p> Source code in <code>edsteva/models/step_function/algos/quantile.py</code> <pre><code>def t_0_from_c_0(\n    predictor: pd.DataFrame,\n    index: List[str],\n    x: str = \"date\",\n    y: str = \"c\",\n    threshold: str = \"c_0\",\n) -&gt; pd.DataFrame:\nr\"\"\"Compute $t_0$ column using value of $c_0$\n\n    Returns the first date at which values are greater than $c_0$:\n\n    $$\n    \\hat{t_0} = \\underset{t}{\\mathrm{argmin}}(c(t) \\geq \\hat{c_0})\n    $$\n\n    Parameters\n    ----------\n    predictor : pd.DataFrame\n        $c(t)$ computed in the Probe\n    index : List[str]\n        Variable from which data is grouped\n    x : str, optional\n        Column name for the time variable $t$\n    y : str, optional\n        Column name  for the completeness variable $c(t)$\n    threshold : str, optional\n        Column name  for the threshold variable $t_0$\n    \"\"\"\n\n    check_columns(df=predictor, required_columns=[*index, x, y, threshold])\n\n    threshold = (\n        predictor[predictor[y] &gt; predictor[threshold]]\n        .groupby(index)[[x]]\n        .min()\n        .rename(columns={x: \"t_0\"})\n    )\n\n    return predictor.merge(threshold, on=index)\n</code></pre>"},{"location":"reference/models/step_function/viz_configs/","title":"<code>edsteva.models.step_function.viz_configs</code>","text":""},{"location":"reference/models/step_function/viz_configs/defaults/","title":"<code>edsteva.models.step_function.viz_configs.defaults</code>","text":""},{"location":"reference/models/step_function/viz_configs/normalized_probe_dashboard/","title":"<code>edsteva.models.step_function.viz_configs.normalized_probe_dashboard</code>","text":""},{"location":"reference/models/step_function/viz_configs/normalized_probe_plot/","title":"<code>edsteva.models.step_function.viz_configs.normalized_probe_plot</code>","text":""},{"location":"reference/models/step_function/viz_configs/probe_dashboard/","title":"<code>edsteva.models.step_function.viz_configs.probe_dashboard</code>","text":""},{"location":"reference/models/step_function/viz_configs/probe_plot/","title":"<code>edsteva.models.step_function.viz_configs.probe_plot</code>","text":""},{"location":"reference/probes/","title":"<code>edsteva.probes</code>","text":""},{"location":"reference/probes/base/","title":"<code>edsteva.probes.base</code>","text":""},{"location":"reference/probes/base/base/","title":"<code>edsteva.probes.base.base</code>","text":""},{"location":"reference/probes/base/base/#edsteva.probes.base.base.BaseProbe","title":"BaseProbe","text":"<p>Base class for Probes</p> ATTRIBUTE DESCRIPTION <code>_schema</code> <p>The columns a predictor must have.</p> <p>VALUE: <code>[\"date\", \"c\"]</code></p> <p> TYPE: <code>List[str]</code> </p> <code>predictor</code> <p>Available with the <code>compute()</code> method</p> <p> TYPE: <code>pd.DataFrame</code> </p> <code>_cache_predictor</code> <p>Available with the <code>compute()</code> method</p> <p>It is a copy of the predictor DataFrame used to <code>reset_predictor()</code></p> <p> TYPE: <code>pd.DataFrame</code> </p> <code>care_site_relationship</code> <p>Available with the <code>compute()</code> method</p> <p>It describes the care site structure (cf. <code>prepare_care_site_relationship()</code>)</p> <p> TYPE: <code>pd.DataFrame</code> </p> Source code in <code>edsteva/probes/base/base.py</code> <pre><code>class BaseProbe(metaclass=ABCMeta):\n\"\"\"Base class for Probes\n\n    Attributes\n    ----------\n    _schema: List[str]\n        The columns a predictor must have.\n\n        **VALUE**: ``[\"date\", \"c\"]``\n    predictor: pd.DataFrame\n        Available with the [``compute()``][edsteva.probes.base.BaseProbe.compute] method\n    _cache_predictor: pd.DataFrame\n        Available with the [``compute()``][edsteva.probes.base.BaseProbe.compute] method\n\n        It is a copy of the predictor DataFrame used to [``reset_predictor()``][edsteva.probes.base.BaseProbe.reset_predictor]\n    care_site_relationship: pd.DataFrame\n        Available with the [``compute()``][edsteva.probes.base.BaseProbe.compute] method\n\n        It describes the care site structure (cf. [``prepare_care_site_relationship()``][edsteva.probes.utils.prepare_df.prepare_care_site_relationship])\n    \"\"\"\n\n    _schema: ClassVar[List[str]] = [\"date\", \"c\"]\n\n    def __init__(\n        self,\n        index: List[str],\n        completeness_predictor: str = None,\n    ):\n        if completeness_predictor is not None:\n            self._completeness_predictor = completeness_predictor\n        self._cache_index = index.copy()\n        self._viz_config = {}\n\n    def validate_input_data(self, data: Data) -&gt; None:\n\"\"\"Raises an error if the input data is not valid\n\n        Parameters\n        ----------\n        data: Data\n            Instantiated [``HiveData``][edsteva.io.hive.HiveData], [``PostgresData``][edsteva.io.postgres.PostgresData] or [``LocalData``][edsteva.io.files.LocalData]\n        \"\"\"\n\n        if not isinstance(data, Data.__args__):\n            raise TypeError(\"Unsupported type {} for data\".format(type(data).__name__))\n\n        check_tables(\n            data=data,\n            required_tables=[\n                \"visit_occurrence\",\n                \"care_site\",\n                \"fact_relationship\",\n            ],\n        )\n\n    def is_computed_probe(self) -&gt; None:\n\"\"\"Raises an error if the Probe has not been computed properly\"\"\"\n        if hasattr(self, \"predictor\"):\n            if not isinstance(self.predictor, pd.DataFrame):\n                raise TypeError(\n                    \"Predictor must be a Pandas DataFrame and not a {}, please review the process method or your arguments\".format(\n                        type(self.predictor).__name__\n                    )\n                )\n            if self.predictor.empty:\n                raise Exception(\n                    \"Predictor is empty, please review the process method or your arguments\"\n                )\n            check_columns(\n                self.predictor,\n                required_columns=self._schema,\n            )\n            if self.predictor.dtypes[\"date\"] != \"datetime64[ns]\":\n                try:\n                    self.predictor[\"date\"] = self.predictor[\"date\"].astype(\n                        \"datetime64[ns]\"\n                    )\n                except Exception as e:\n                    raise TypeError(\n                        \"Predictor column 'date' type is {} and cannot convert to datetime and return the following error: {}. Please review the process method or your arguments\".format(\n                            self.predictor.dtypes[\"date\"], e\n                        )\n                    ) from e\n        else:\n            raise Exception(\n                \"Predictor has not been computed, please use the compute method as follow: Predictor.compute()\"\n            )\n\n    def filter_date_per_care_site(self, target_column: str):\n        filtered_predictor = self.predictor.copy()\n        predictor_activity = self.predictor[self.predictor[target_column] &gt; 0].copy()\n        predictor_activity = (\n            predictor_activity.groupby(\"care_site_id\")\n            .agg({\"date\": [\"min\", \"max\"]})\n            .droplevel(axis=\"columns\", level=0)\n            .reset_index()\n        )\n        filtered_predictor = filtered_predictor.merge(\n            predictor_activity, on=\"care_site_id\"\n        )\n        filtered_predictor = filtered_predictor[\n            (filtered_predictor[\"date\"] &gt;= filtered_predictor[\"min\"])\n            &amp; (filtered_predictor[\"date\"] &lt;= filtered_predictor[\"max\"])\n        ].drop(columns=[\"min\", \"max\"])\n        self.predictor = filtered_predictor\n\n    @abstractmethod\n    def compute_process(\n        self,\n        data: Data,\n        care_site_relationship: pd.DataFrame,\n        start_date: datetime,\n        end_date: datetime,\n        **kwargs,\n    ) -&gt; pd.DataFrame:\n\"\"\"Process the data in order to obtain a predictor table\"\"\"\n\n    def compute(\n        self,\n        data: Data,\n        start_date: datetime = None,\n        end_date: datetime = None,\n        with_cache: bool = True,\n        **kwargs,\n    ) -&gt; None:\n\"\"\"Calls [``compute_process()``][edsteva.probes.base.BaseProbe.compute_process]\n\n\n        Here are the following computation steps:\n\n        - check if input data is valid with [``validate_input_data()``][edsteva.probes.base.BaseProbe.validate_input_data] method\n        - query care site relationship table with [``prepare_care_site_relationship()``][edsteva.probes.utils.prepare_df.prepare_care_site_relationship]\n        - compute predictor with [``compute_process()``][edsteva.probes.base.BaseProbe.compute_process] method\n        - check if predictor is valid with [``is_computed_probe()``][edsteva.probes.base.BaseProbe.is_computed_probe] method\n\n\n\n        Parameters\n        ----------\n        data : Data\n            Instantiated [``HiveData``][edsteva.io.hive.HiveData], [``PostgresData``][edsteva.io.postgres.PostgresData] or [``LocalData``][edsteva.io.files.LocalData]\n        start_date : datetime, optional\n            **EXAMPLE**: `\"2019-05-01\"`\n        end_date : datetime, optional\n            **EXAMPLE**: `\"2021-07-01\"`\n\n        Attributes\n        ----------\n        Add to the Probe th following attributes:\n\n        - predictor is the target DataFrame\n        - _cache_predictor is a copy of the target DataFrame (used to [``reset_predictor()``][edsteva.probes.base.BaseProbe.reset_predictor])\n        - care_site_relationship is a DataFrame with the hierarchy of the care site structure\n\n        Examples\n        -------\n\n        ```python\n        from edsteva.probes import VisitProbe\n\n        visit = VisitProbe()\n        visit.compute(\n            data,\n            stay_types={\"All\": \".*\", \"Urg_and_consult\": \"urgences|consultation\"},\n            care_site_levels=[\"Hospital\", \"Pole\", \"UF\"],\n        )\n        visit.predictor.head()\n        ```\n\n        | care_site_level          | care_site_id | care_site_short_name | stay_type       | date       | n_visit | c     |\n        | :----------------------- | :----------- | :------------------- | :-------------- | :--------- | :------ | :---- |\n        | Unit\u00e9 Fonctionnelle (UF) | 8312056386   | Care site 1          | Urg_and_consult | 2019-05-01 | 233.0   | 0.841 |\n        | Unit\u00e9 Fonctionnelle (UF) | 8312056386   | Care site 1          | 'All'           | 2021-04-01 | 393.0   | 0.640 |\n        | P\u00f4le/DMU                 | 8312027648   | Care site 2          | Urg_and_consult | 2011-03-01 | 204.0   | 0.497 |\n        | P\u00f4le/DMU                 | 8312027648   | Care site 2          | 'All'           | 2018-08-01 | 22.0    | 0.274 |\n        | H\u00f4pital                  | 8312022130   | Care site 3          | Urg_and_consult | 2022-02-01 | 9746.0  | 0.769 |\n\n\n        \"\"\"\n        self.validate_input_data(data=data)\n        self._reset_index()\n        care_site_relationship = prepare_care_site_relationship(data=data)\n        self.start_date = pd.to_datetime(start_date) if start_date else None\n        self.end_date = pd.to_datetime(end_date) if end_date else None\n        self.predictor = self.compute_process(\n            data=data,\n            care_site_relationship=care_site_relationship,\n            start_date=start_date,\n            end_date=end_date,\n            **kwargs,\n        )\n        self.is_computed_probe()\n        self.care_site_relationship = care_site_relationship\n        self.predictor = self.add_names_columns(self.predictor)\n        if with_cache:\n            self.cache_predictor()\n\n    def reset_predictor(\n        self,\n    ) -&gt; None:\n\"\"\"Reset the predictor to its initial state\"\"\"\n        self.predictor = self._cache_predictor.copy()\n\n    def cache_predictor(\n        self,\n    ) -&gt; None:\n\"\"\"Cache the predictor\"\"\"\n        self._cache_predictor = self.predictor.copy()\n        logger.info(\n            \"Cache the predictor, you can reset the predictor to this state with the method reset_predictor\"\n        )\n\n    def filter_care_site(\n        self,\n        care_site_ids: Union[int, List[int]] = None,\n        care_site_short_names: Union[str, List[str]] = None,\n        care_site_specialties: Union[str, List[str]] = None,\n    ) -&gt; None:\n\"\"\"Filters all the care sites related to the selected care sites.\n\n        Parameters\n        ----------\n        care_site_ids : Union[int, List[int]], optional\n            **EXAMPLE**: `[8312056386, 8312027648]`\n        care_site_short_names : Union[str, List[str]], optional\n            **EXAMPLE**: `[\"HOSPITAL 1\", \"HOSPITAL 2\"]`\n        \"\"\"\n        self.predictor = filter_table_by_care_site(\n            table_to_filter=self.predictor,\n            care_site_relationship=self.care_site_relationship,\n            care_site_ids=care_site_ids,\n            care_site_short_names=care_site_short_names,\n            care_site_specialties=care_site_specialties,\n        )\n        logger.info(\"Use probe.reset_predictor() to get back the initial predictor\")\n\n    def add_names_columns(self, df: DataFrame):\n        if hasattr(self, \"care_site_relationship\") and \"care_site_id\" in df.columns:\n            df = df.merge(\n                self.care_site_relationship[\n                    [\"care_site_id\", \"care_site_short_name\"]\n                ].drop_duplicates(),\n                on=\"care_site_id\",\n                how=\"left\",\n            )\n        if hasattr(self, \"biology_relationship\"):\n            concept_codes = [\n                \"{}_concept_code\".format(terminology)\n                for terminology in self._standard_terminologies\n            ]\n            concept_names = [\n                \"{}_concept_name\".format(terminology)\n                for terminology in self._standard_terminologies\n            ]\n            if set(concept_codes).issubset(df.columns):\n                df = df.merge(\n                    self.biology_relationship[\n                        concept_codes + concept_names\n                    ].drop_duplicates(),\n                    on=concept_codes,\n                    how=\"left\",\n                )\n        return df.reset_index(drop=True)\n\n    def get_viz_config(self, viz_type: str, **kwargs):\n\"\"\"This is the basic viz configs if not overridden by the probe.\n\n        Parameters\n        ----------\n        viz_type : str,\n            **EXAMPLE**: `\"probe_dashboard\"`\n        \"\"\"\n        if viz_type in viz_configs.keys():\n            return viz_configs[viz_type](self, **kwargs)\n        raise ValueError(f\"edsteva has no {viz_type} registry !\")\n\n    def generate_bar_chart_config(self, threshold: int = 10):\n        self.is_computed_probe()\n\n        # Sort index with regard to number of unique values\n        index = self._index.copy()\n        nunique_per_index = self.predictor[index].nunique()  # Number of unique value\n        vertical_variables = nunique_per_index.loc[\n            lambda x: x &lt;= threshold\n        ].index.tolist()\n        horizontal_variables = nunique_per_index.loc[\n            lambda x: x &gt; threshold\n        ].index.tolist()\n\n        # Sort metrics wether it is rate between 0 and 1 or integers\n        metrics = [\n            metric for metric in self._metrics if metric in self.predictor.columns\n        ]\n        if len(metrics) &gt;= 2 and \"c\" in metrics:\n            metrics.remove(\"c\")\n        metrics = {\n            metric: \"mean\"\n            if self.predictor[metric].between(0, 1, \"neither\").any()\n            else \"sum\"\n            for metric in metrics\n        }\n\n        vertical_bar_charts = dict(\n            x=[\n                {\n                    \"title\": field.replace(\"_\", \" \").capitalize(),\n                    \"field\": field,\n                    \"type\": \"nominal\",\n                    \"sort\": \"-y\",\n                }\n                for field in vertical_variables\n            ],\n            y=[\n                dict(\n                    y=alt.Y(\n                        f\"{agg}({metric}):Q\",\n                        axis=alt.Axis(format=\"s\" if agg == \"sum\" else \".2f\"),\n                    ),\n                    tooltip=alt.Tooltip(\n                        f\"{agg}({metric}):Q\",\n                        format=\",\" if agg == \"sum\" else \".2f\",\n                    ),\n                    sort={\n                        \"field\": metric,\n                        \"op\": agg,\n                        \"order\": \"descending\",\n                    },\n                )\n                for metric, agg in metrics.items()\n            ],\n        )\n        horizontal_bar_charts = dict(\n            y=[\n                {\n                    \"title\": field.replace(\"_\", \" \").capitalize(),\n                    \"field\": field,\n                    \"type\": \"nominal\",\n                    \"sort\": \"-x\",\n                }\n                for field in horizontal_variables\n            ],\n            x=[\n                dict(\n                    x=alt.X(\n                        f\"{agg}({metric}):Q\",\n                        axis=alt.Axis(format=\"s\" if agg == \"sum\" else \".2f\"),\n                    ),\n                    tooltip=alt.Tooltip(\n                        f\"{agg}({metric}):Q\",\n                        format=\",\" if agg == \"sum\" else \".2f\",\n                    ),\n                    sort={\n                        \"field\": metric,\n                        \"op\": agg,\n                        \"order\": \"descending\",\n                    },\n                )\n                for metric, agg in metrics.items()\n            ],\n        )\n        return vertical_bar_charts, horizontal_bar_charts\n\n    def load(self, path=None) -&gt; None:\n\"\"\"Loads a Probe from local\n\n        Parameters\n        ----------\n        path : str, optional\n            **EXAMPLE**: `\"my_folder/my_file.html\"`\n\n        Examples\n        -------\n        ```python\n        from edsteva.probes import VisitProbe\n\n        probe_path = \"my_path/visit.pkl\"\n\n        visit = VisitProbe()\n        visit.load(path=probe_path)\n        ```\n\n        \"\"\"\n\n        path = path or self._get_path()\n\n        loaded_probe = load_object(path)\n        self.__dict__ = loaded_probe.__dict__.copy()\n        self.path = path\n\n    def save(self, path: str = None, name: str = None) -&gt; bool:\n\"\"\"Saves computed Model instance\n\n        Parameters\n        ----------\n        path : str, optional\n            **EXAMPLE**: `\"my_folder/my_file.html\"`\n        name : str, optional\n            **EXAMPLE**: `\"visit_from_BCT\"`\n\n        Examples\n        -------\n        ```python\n        from edsteva.probes import VisitProbe\n\n        probe_path = \"my_path/visit.pkl\"\n\n        visit = VisitProbe()\n        visit.compute(data)\n        visit.save(path=probe_path)\n        ```\n\n        \"\"\"\n\n        self.is_computed_probe()\n\n        if name:\n            self.name = name\n        if not path:\n            path = self._get_path()\n\n        self.path = path\n        save_object(self, path)\n\n    def delete(self, path: str = None):\n\"\"\"Delete the saved Probe instance\n\n        Parameters\n        ----------\n        path : str, optional\n            **EXAMPLE**: `\"my_folder/my_file.html\"`\n        \"\"\"\n\n        if not path:\n            path = self.path\n\n        delete_object(self, path)\n\n    def _get_path(self):\n        base_path = CACHE_DIR / \"edsteva\" / \"probes\"\n        if hasattr(self, \"name\"):\n            filename = f\"{self.name.lower()}.pickle\"\n        else:\n            filename = f\"{type(self).__name__.lower()}.pickle\"\n        return base_path / filename\n\n    def _reset_index(\n        self,\n    ) -&gt; None:\n\"\"\"Reset the index to its initial state\"\"\"\n        self._index = self._cache_index.copy()\n</code></pre>"},{"location":"reference/probes/base/base/#edsteva.probes.base.base.BaseProbe.validate_input_data","title":"validate_input_data","text":"<pre><code>validate_input_data(data: Data) -&gt; None\n</code></pre> <p>Raises an error if the input data is not valid</p> PARAMETER DESCRIPTION <code>data</code> <p>Instantiated <code>HiveData</code>, <code>PostgresData</code> or <code>LocalData</code></p> <p> TYPE: <code>Data</code> </p> Source code in <code>edsteva/probes/base/base.py</code> <pre><code>def validate_input_data(self, data: Data) -&gt; None:\n\"\"\"Raises an error if the input data is not valid\n\n    Parameters\n    ----------\n    data: Data\n        Instantiated [``HiveData``][edsteva.io.hive.HiveData], [``PostgresData``][edsteva.io.postgres.PostgresData] or [``LocalData``][edsteva.io.files.LocalData]\n    \"\"\"\n\n    if not isinstance(data, Data.__args__):\n        raise TypeError(\"Unsupported type {} for data\".format(type(data).__name__))\n\n    check_tables(\n        data=data,\n        required_tables=[\n            \"visit_occurrence\",\n            \"care_site\",\n            \"fact_relationship\",\n        ],\n    )\n</code></pre>"},{"location":"reference/probes/base/base/#edsteva.probes.base.base.BaseProbe.is_computed_probe","title":"is_computed_probe","text":"<pre><code>is_computed_probe() -&gt; None\n</code></pre> <p>Raises an error if the Probe has not been computed properly</p> Source code in <code>edsteva/probes/base/base.py</code> <pre><code>def is_computed_probe(self) -&gt; None:\n\"\"\"Raises an error if the Probe has not been computed properly\"\"\"\n    if hasattr(self, \"predictor\"):\n        if not isinstance(self.predictor, pd.DataFrame):\n            raise TypeError(\n                \"Predictor must be a Pandas DataFrame and not a {}, please review the process method or your arguments\".format(\n                    type(self.predictor).__name__\n                )\n            )\n        if self.predictor.empty:\n            raise Exception(\n                \"Predictor is empty, please review the process method or your arguments\"\n            )\n        check_columns(\n            self.predictor,\n            required_columns=self._schema,\n        )\n        if self.predictor.dtypes[\"date\"] != \"datetime64[ns]\":\n            try:\n                self.predictor[\"date\"] = self.predictor[\"date\"].astype(\n                    \"datetime64[ns]\"\n                )\n            except Exception as e:\n                raise TypeError(\n                    \"Predictor column 'date' type is {} and cannot convert to datetime and return the following error: {}. Please review the process method or your arguments\".format(\n                        self.predictor.dtypes[\"date\"], e\n                    )\n                ) from e\n    else:\n        raise Exception(\n            \"Predictor has not been computed, please use the compute method as follow: Predictor.compute()\"\n        )\n</code></pre>"},{"location":"reference/probes/base/base/#edsteva.probes.base.base.BaseProbe.compute_process","title":"compute_process  <code>abstractmethod</code>","text":"<pre><code>compute_process(\n    data: Data,\n    care_site_relationship: pd.DataFrame,\n    start_date: datetime,\n    end_date: datetime,\n    **kwargs\n) -&gt; pd.DataFrame\n</code></pre> <p>Process the data in order to obtain a predictor table</p> Source code in <code>edsteva/probes/base/base.py</code> <pre><code>@abstractmethod\ndef compute_process(\n    self,\n    data: Data,\n    care_site_relationship: pd.DataFrame,\n    start_date: datetime,\n    end_date: datetime,\n    **kwargs,\n) -&gt; pd.DataFrame:\n\"\"\"Process the data in order to obtain a predictor table\"\"\"\n</code></pre>"},{"location":"reference/probes/base/base/#edsteva.probes.base.base.BaseProbe.compute","title":"compute","text":"<pre><code>compute(\n    data: Data,\n    start_date: datetime = None,\n    end_date: datetime = None,\n    with_cache: bool = True,\n    **kwargs\n) -&gt; None\n</code></pre> <p>Calls <code>compute_process()</code></p> <p>Here are the following computation steps:</p> <ul> <li>check if input data is valid with <code>validate_input_data()</code> method</li> <li>query care site relationship table with <code>prepare_care_site_relationship()</code></li> <li>compute predictor with <code>compute_process()</code> method</li> <li>check if predictor is valid with <code>is_computed_probe()</code> method</li> </ul> PARAMETER DESCRIPTION <code>data</code> <p>Instantiated <code>HiveData</code>, <code>PostgresData</code> or <code>LocalData</code></p> <p> TYPE: <code>Data</code> </p> <code>start_date</code> <p>EXAMPLE: <code>\"2019-05-01\"</code></p> <p> TYPE: <code>datetime</code> DEFAULT: <code>None</code> </p> <code>end_date</code> <p>EXAMPLE: <code>\"2021-07-01\"</code></p> <p> TYPE: <code>datetime</code> DEFAULT: <code>None</code> </p> ATTRIBUTE DESCRIPTION <code>Add to the Probe th following attributes</code> <p> </p> <ul> <li>predictor is the target DataFrame</li> <li>_cache_predictor is a copy of the target DataFrame (used to <code>reset_predictor()</code>)</li> <li>care_site_relationship is a DataFrame with the hierarchy of the care site structure</li> </ul> <p>Examples:</p> <pre><code>from edsteva.probes import VisitProbe\n\nvisit = VisitProbe()\nvisit.compute(\n    data,\n    stay_types={\"All\": \".*\", \"Urg_and_consult\": \"urgences|consultation\"},\n    care_site_levels=[\"Hospital\", \"Pole\", \"UF\"],\n)\nvisit.predictor.head()\n</code></pre> care_site_level care_site_id care_site_short_name stay_type date n_visit c Unit\u00e9 Fonctionnelle (UF) 8312056386 Care site 1 Urg_and_consult 2019-05-01 233.0 0.841 Unit\u00e9 Fonctionnelle (UF) 8312056386 Care site 1 'All' 2021-04-01 393.0 0.640 P\u00f4le/DMU 8312027648 Care site 2 Urg_and_consult 2011-03-01 204.0 0.497 P\u00f4le/DMU 8312027648 Care site 2 'All' 2018-08-01 22.0 0.274 H\u00f4pital 8312022130 Care site 3 Urg_and_consult 2022-02-01 9746.0 0.769 Source code in <code>edsteva/probes/base/base.py</code> <pre><code>def compute(\n    self,\n    data: Data,\n    start_date: datetime = None,\n    end_date: datetime = None,\n    with_cache: bool = True,\n    **kwargs,\n) -&gt; None:\n\"\"\"Calls [``compute_process()``][edsteva.probes.base.BaseProbe.compute_process]\n\n\n    Here are the following computation steps:\n\n    - check if input data is valid with [``validate_input_data()``][edsteva.probes.base.BaseProbe.validate_input_data] method\n    - query care site relationship table with [``prepare_care_site_relationship()``][edsteva.probes.utils.prepare_df.prepare_care_site_relationship]\n    - compute predictor with [``compute_process()``][edsteva.probes.base.BaseProbe.compute_process] method\n    - check if predictor is valid with [``is_computed_probe()``][edsteva.probes.base.BaseProbe.is_computed_probe] method\n\n\n\n    Parameters\n    ----------\n    data : Data\n        Instantiated [``HiveData``][edsteva.io.hive.HiveData], [``PostgresData``][edsteva.io.postgres.PostgresData] or [``LocalData``][edsteva.io.files.LocalData]\n    start_date : datetime, optional\n        **EXAMPLE**: `\"2019-05-01\"`\n    end_date : datetime, optional\n        **EXAMPLE**: `\"2021-07-01\"`\n\n    Attributes\n    ----------\n    Add to the Probe th following attributes:\n\n    - predictor is the target DataFrame\n    - _cache_predictor is a copy of the target DataFrame (used to [``reset_predictor()``][edsteva.probes.base.BaseProbe.reset_predictor])\n    - care_site_relationship is a DataFrame with the hierarchy of the care site structure\n\n    Examples\n    -------\n\n    ```python\n    from edsteva.probes import VisitProbe\n\n    visit = VisitProbe()\n    visit.compute(\n        data,\n        stay_types={\"All\": \".*\", \"Urg_and_consult\": \"urgences|consultation\"},\n        care_site_levels=[\"Hospital\", \"Pole\", \"UF\"],\n    )\n    visit.predictor.head()\n    ```\n\n    | care_site_level          | care_site_id | care_site_short_name | stay_type       | date       | n_visit | c     |\n    | :----------------------- | :----------- | :------------------- | :-------------- | :--------- | :------ | :---- |\n    | Unit\u00e9 Fonctionnelle (UF) | 8312056386   | Care site 1          | Urg_and_consult | 2019-05-01 | 233.0   | 0.841 |\n    | Unit\u00e9 Fonctionnelle (UF) | 8312056386   | Care site 1          | 'All'           | 2021-04-01 | 393.0   | 0.640 |\n    | P\u00f4le/DMU                 | 8312027648   | Care site 2          | Urg_and_consult | 2011-03-01 | 204.0   | 0.497 |\n    | P\u00f4le/DMU                 | 8312027648   | Care site 2          | 'All'           | 2018-08-01 | 22.0    | 0.274 |\n    | H\u00f4pital                  | 8312022130   | Care site 3          | Urg_and_consult | 2022-02-01 | 9746.0  | 0.769 |\n\n\n    \"\"\"\n    self.validate_input_data(data=data)\n    self._reset_index()\n    care_site_relationship = prepare_care_site_relationship(data=data)\n    self.start_date = pd.to_datetime(start_date) if start_date else None\n    self.end_date = pd.to_datetime(end_date) if end_date else None\n    self.predictor = self.compute_process(\n        data=data,\n        care_site_relationship=care_site_relationship,\n        start_date=start_date,\n        end_date=end_date,\n        **kwargs,\n    )\n    self.is_computed_probe()\n    self.care_site_relationship = care_site_relationship\n    self.predictor = self.add_names_columns(self.predictor)\n    if with_cache:\n        self.cache_predictor()\n</code></pre>"},{"location":"reference/probes/base/base/#edsteva.probes.base.base.BaseProbe.reset_predictor","title":"reset_predictor","text":"<pre><code>reset_predictor() -&gt; None\n</code></pre> <p>Reset the predictor to its initial state</p> Source code in <code>edsteva/probes/base/base.py</code> <pre><code>def reset_predictor(\n    self,\n) -&gt; None:\n\"\"\"Reset the predictor to its initial state\"\"\"\n    self.predictor = self._cache_predictor.copy()\n</code></pre>"},{"location":"reference/probes/base/base/#edsteva.probes.base.base.BaseProbe.cache_predictor","title":"cache_predictor","text":"<pre><code>cache_predictor() -&gt; None\n</code></pre> <p>Cache the predictor</p> Source code in <code>edsteva/probes/base/base.py</code> <pre><code>def cache_predictor(\n    self,\n) -&gt; None:\n\"\"\"Cache the predictor\"\"\"\n    self._cache_predictor = self.predictor.copy()\n    logger.info(\n        \"Cache the predictor, you can reset the predictor to this state with the method reset_predictor\"\n    )\n</code></pre>"},{"location":"reference/probes/base/base/#edsteva.probes.base.base.BaseProbe.filter_care_site","title":"filter_care_site","text":"<pre><code>filter_care_site(\n    care_site_ids: Union[int, List[int]] = None,\n    care_site_short_names: Union[str, List[str]] = None,\n    care_site_specialties: Union[str, List[str]] = None,\n) -&gt; None\n</code></pre> <p>Filters all the care sites related to the selected care sites.</p> PARAMETER DESCRIPTION <code>care_site_ids</code> <p>EXAMPLE: <code>[8312056386, 8312027648]</code></p> <p> TYPE: <code>Union[int, List[int]]</code> DEFAULT: <code>None</code> </p> <code>care_site_short_names</code> <p>EXAMPLE: <code>[\"HOSPITAL 1\", \"HOSPITAL 2\"]</code></p> <p> TYPE: <code>Union[str, List[str]]</code> DEFAULT: <code>None</code> </p> Source code in <code>edsteva/probes/base/base.py</code> <pre><code>def filter_care_site(\n    self,\n    care_site_ids: Union[int, List[int]] = None,\n    care_site_short_names: Union[str, List[str]] = None,\n    care_site_specialties: Union[str, List[str]] = None,\n) -&gt; None:\n\"\"\"Filters all the care sites related to the selected care sites.\n\n    Parameters\n    ----------\n    care_site_ids : Union[int, List[int]], optional\n        **EXAMPLE**: `[8312056386, 8312027648]`\n    care_site_short_names : Union[str, List[str]], optional\n        **EXAMPLE**: `[\"HOSPITAL 1\", \"HOSPITAL 2\"]`\n    \"\"\"\n    self.predictor = filter_table_by_care_site(\n        table_to_filter=self.predictor,\n        care_site_relationship=self.care_site_relationship,\n        care_site_ids=care_site_ids,\n        care_site_short_names=care_site_short_names,\n        care_site_specialties=care_site_specialties,\n    )\n    logger.info(\"Use probe.reset_predictor() to get back the initial predictor\")\n</code></pre>"},{"location":"reference/probes/base/base/#edsteva.probes.base.base.BaseProbe.get_viz_config","title":"get_viz_config","text":"<pre><code>get_viz_config(viz_type: str, **kwargs)\n</code></pre> <p>This is the basic viz configs if not overridden by the probe.</p> PARAMETER DESCRIPTION <code>viz_type</code> <p>EXAMPLE: <code>\"probe_dashboard\"</code></p> <p> TYPE: <code>str</code> </p> Source code in <code>edsteva/probes/base/base.py</code> <pre><code>def get_viz_config(self, viz_type: str, **kwargs):\n\"\"\"This is the basic viz configs if not overridden by the probe.\n\n    Parameters\n    ----------\n    viz_type : str,\n        **EXAMPLE**: `\"probe_dashboard\"`\n    \"\"\"\n    if viz_type in viz_configs.keys():\n        return viz_configs[viz_type](self, **kwargs)\n    raise ValueError(f\"edsteva has no {viz_type} registry !\")\n</code></pre>"},{"location":"reference/probes/base/base/#edsteva.probes.base.base.BaseProbe.load","title":"load","text":"<pre><code>load(path = None) -&gt; None\n</code></pre> <p>Loads a Probe from local</p> PARAMETER DESCRIPTION <code>path</code> <p>EXAMPLE: <code>\"my_folder/my_file.html\"</code></p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> <p>Examples:</p> <pre><code>from edsteva.probes import VisitProbe\n\nprobe_path = \"my_path/visit.pkl\"\n\nvisit = VisitProbe()\nvisit.load(path=probe_path)\n</code></pre> Source code in <code>edsteva/probes/base/base.py</code> <pre><code>def load(self, path=None) -&gt; None:\n\"\"\"Loads a Probe from local\n\n    Parameters\n    ----------\n    path : str, optional\n        **EXAMPLE**: `\"my_folder/my_file.html\"`\n\n    Examples\n    -------\n    ```python\n    from edsteva.probes import VisitProbe\n\n    probe_path = \"my_path/visit.pkl\"\n\n    visit = VisitProbe()\n    visit.load(path=probe_path)\n    ```\n\n    \"\"\"\n\n    path = path or self._get_path()\n\n    loaded_probe = load_object(path)\n    self.__dict__ = loaded_probe.__dict__.copy()\n    self.path = path\n</code></pre>"},{"location":"reference/probes/base/base/#edsteva.probes.base.base.BaseProbe.save","title":"save","text":"<pre><code>save(path: str = None, name: str = None) -&gt; bool\n</code></pre> <p>Saves computed Model instance</p> PARAMETER DESCRIPTION <code>path</code> <p>EXAMPLE: <code>\"my_folder/my_file.html\"</code></p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> <code>name</code> <p>EXAMPLE: <code>\"visit_from_BCT\"</code></p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> <p>Examples:</p> <pre><code>from edsteva.probes import VisitProbe\n\nprobe_path = \"my_path/visit.pkl\"\n\nvisit = VisitProbe()\nvisit.compute(data)\nvisit.save(path=probe_path)\n</code></pre> Source code in <code>edsteva/probes/base/base.py</code> <pre><code>def save(self, path: str = None, name: str = None) -&gt; bool:\n\"\"\"Saves computed Model instance\n\n    Parameters\n    ----------\n    path : str, optional\n        **EXAMPLE**: `\"my_folder/my_file.html\"`\n    name : str, optional\n        **EXAMPLE**: `\"visit_from_BCT\"`\n\n    Examples\n    -------\n    ```python\n    from edsteva.probes import VisitProbe\n\n    probe_path = \"my_path/visit.pkl\"\n\n    visit = VisitProbe()\n    visit.compute(data)\n    visit.save(path=probe_path)\n    ```\n\n    \"\"\"\n\n    self.is_computed_probe()\n\n    if name:\n        self.name = name\n    if not path:\n        path = self._get_path()\n\n    self.path = path\n    save_object(self, path)\n</code></pre>"},{"location":"reference/probes/base/base/#edsteva.probes.base.base.BaseProbe.delete","title":"delete","text":"<pre><code>delete(path: str = None)\n</code></pre> <p>Delete the saved Probe instance</p> PARAMETER DESCRIPTION <code>path</code> <p>EXAMPLE: <code>\"my_folder/my_file.html\"</code></p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> Source code in <code>edsteva/probes/base/base.py</code> <pre><code>def delete(self, path: str = None):\n\"\"\"Delete the saved Probe instance\n\n    Parameters\n    ----------\n    path : str, optional\n        **EXAMPLE**: `\"my_folder/my_file.html\"`\n    \"\"\"\n\n    if not path:\n        path = self.path\n\n    delete_object(self, path)\n</code></pre>"},{"location":"reference/probes/base/viz_configs/","title":"<code>edsteva.probes.base.viz_configs</code>","text":""},{"location":"reference/probes/biology/","title":"<code>edsteva.probes.biology</code>","text":""},{"location":"reference/probes/biology/biology/","title":"<code>edsteva.probes.biology.biology</code>","text":""},{"location":"reference/probes/biology/biology/#edsteva.probes.biology.biology.BiologyProbe","title":"BiologyProbe","text":"<p>         Bases: <code>BaseProbe</code></p> <p>The <code>BiologyProbe</code> computes \\(c_(t)\\) the availability of laboratory data related to biological measurements for each biological code and each care site according to time:</p> \\[ c(t) = \\frac{n_{biology}(t)}{n_{99}} \\] <p>Where \\(n_{biology}(t)\\) is the number of biological measurements, \\(n_{99}\\) is the \\(99^{th}\\) percentile and \\(t\\) is the month.</p> PARAMETER DESCRIPTION <code>completeness_predictor</code> <p>Algorithm used to compute the completeness predictor</p> <p>EXAMPLE: <code>\"per_visit_default\"</code></p> <p> TYPE: <code>str</code> DEFAULT: <code>'per_measurement_default'</code> </p> <code>standard_terminologies</code> <p>List of standards terminologies to consider</p> <p>EXAMPLE: <code>[\"LOINC\", \"ANABIO\"]</code></p> <p> TYPE: <code>List[str]</code> DEFAULT: <code>['ANABIO', 'LOINC']</code> </p> ATTRIBUTE DESCRIPTION <code>_completeness_predictor</code> <p>Algorithm used to compute the completeness predictor</p> <p>VALUE: <code>\"per_visit_default\"</code></p> <p> TYPE: <code>str</code> </p> <code>_standard_terminologies</code> <p>List of standards terminologies to consider</p> <p>VALUE: <code>[\"LOINC\", \"ANABIO\"]</code></p> <p> TYPE: <code>List[str]</code> </p> <code>_index</code> <p>Variable from which data is grouped</p> <p>VALUE: <code>[\"care_site_level\", \"concepts_set\", \"stay_type\", \"length_of_stay\", \"care_site_id\", \"care_site_specialty\", \"specialties_set\", \"&lt;std_terminology&gt;_concept_code\"]</code></p> <p> TYPE: <code>List[str]</code> </p> <code>_viz_config</code> <p>Dictionary of configuration for visualization purpose.</p> <p>VALUE: <code>{}</code></p> <p> TYPE: <code>List[str]</code> </p> Source code in <code>edsteva/probes/biology/biology.py</code> <pre><code>class BiologyProbe(BaseProbe):\nr\"\"\"\n    The ``BiologyProbe`` computes $c_(t)$ the availability of laboratory data related to biological measurements for each biological code and each care site according to time:\n\n    $$\n    c(t) = \\frac{n_{biology}(t)}{n_{99}}\n    $$\n\n    Where $n_{biology}(t)$ is the number of biological measurements, $n_{99}$ is the $99^{th}$ percentile and $t$ is the month.\n\n    Parameters\n    ----------\n    completeness_predictor: str\n        Algorithm used to compute the completeness predictor\n\n        **EXAMPLE**: ``\"per_visit_default\"``\n    standard_terminologies: List[str]\n        List of standards terminologies to consider\n\n        **EXAMPLE**: ``[\"LOINC\", \"ANABIO\"]``\n\n    Attributes\n    ----------\n    _completeness_predictor: str\n        Algorithm used to compute the completeness predictor\n\n        **VALUE**: ``\"per_visit_default\"``\n    _standard_terminologies: List[str]\n        List of standards terminologies to consider\n\n        **VALUE**: ``[\"LOINC\", \"ANABIO\"]``\n    _index: List[str]\n        Variable from which data is grouped\n\n        **VALUE**: ``[\"care_site_level\", \"concepts_set\", \"stay_type\", \"length_of_stay\", \"care_site_id\", \"care_site_specialty\", \"specialties_set\", \"&lt;std_terminology&gt;_concept_code\"]``\n    _viz_config: List[str]\n        Dictionary of configuration for visualization purpose.\n\n        **VALUE**: ``{}``\n    \"\"\"\n\n    def __init__(\n        self,\n        completeness_predictor: str = \"per_measurement_default\",\n        standard_terminologies: List[str] = [\"ANABIO\", \"LOINC\"],\n    ):\n        self._standard_terminologies = standard_terminologies\n        self._index = [\n            \"{}_concept_code\".format(terminology)\n            for terminology in standard_terminologies\n        ] + [\n            \"concepts_set\",\n            \"care_site_id\",\n            \"care_site_level\",\n            \"care_sites_set\",\n            \"care_site_specialty\",\n            \"specialties_set\",\n            \"stay_type\",\n            \"stay_source\",\n            \"length_of_stay\",\n            \"provenance_source\",\n            \"age_range\",\n        ]\n        super().__init__(\n            completeness_predictor=completeness_predictor,\n            index=self._index,\n        )\n\n    def compute_process(\n        self,\n        data: Data,\n        care_site_relationship: pd.DataFrame,\n        start_date: datetime,\n        end_date: datetime,\n        source_terminologies: Dict[str, str] = {\n            \"ANALYSES_LABORATOIRE\": r\"Analyses Laboratoire\",\n            \"GLIMS_ANABIO\": r\"GLIMS.{0,20}Anabio\",\n            \"GLIMS_LOINC\": r\"GLIMS.{0,20}LOINC\",\n            \"ANABIO_ITM\": r\"ITM - ANABIO\",\n            \"LOINC_ITM\": r\"ITM - LOINC\",\n        },\n        mapping: List[Tuple[str, str, str]] = [\n            (\"ANALYSES_LABORATOIRE\", \"GLIMS_ANABIO\", \"Maps to\"),\n            (\"ANALYSES_LABORATOIRE\", \"GLIMS_LOINC\", \"Maps to\"),\n            (\"GLIMS_ANABIO\", \"ANABIO_ITM\", \"Mapped from\"),\n            (\"ANABIO_ITM\", \"LOINC_ITM\", \"Maps to\"),\n        ],\n        concept_codes: Union[bool, List[str]] = None,\n        concepts_sets: Union[str, Dict[str, str]] = {\n            \"Leucocytes\": \"A0174|K3232|H6740|E4358|C9784|C8824|E6953\",\n            \"Plaquettes\": \"E4812|C0326|A1636|A0230|H6751|A1598|G7728|G7727|G7833|A2538|A2539|J4463\",\n            \"Cr\u00e9atinine\": \"E3180|G1974|J1002|A7813|A0094|G1975|J1172|G7834|F9409|F9410|C0697|H4038|F2621\",\n            \"Potassium\": \"A1656|C8757|C8758|A2380|E2073|L5014|F2618|E2337|J1178|A3819|J1181\",\n            \"Sodium\": \"A1772|C8759|C8760|A0262|J1177|F8162|L5013|F2617|K9086|J1180\",\n            \"Chlorure\": \"B5597|F2359|A0079|J1179|F2619|J1182|F2358|A0079|J1179|F2619|J1182\",\n            \"Glucose\": \"A1245|E7961|C8796|H7753|A8029|H7749|A0141|H7323|J7401|F2622|B9553|C7236|E7312|G9557|A7338|H7324|C0565|E9889|A8424|F6235|F5659|F2406\",\n            \"Bicarbonate\": \"A0422|H9622|C6408|F4161\",\n        },\n        care_site_ids: List[int] = None,\n        care_site_short_names: List[str] = None,\n        care_site_levels: Union[bool, str, List[str]] = True,\n        care_sites_sets: Union[str, Dict[str, str]] = None,\n        care_site_specialties: Union[bool, List[str]] = None,\n        specialties_sets: Union[str, Dict[str, str]] = None,\n        stay_types: Union[bool, str, Dict[str, str]] = True,\n        stay_sources: Union[bool, str, Dict[str, str]] = None,\n        length_of_stays: List[float] = [1],\n        provenance_sources: Union[bool, str, Dict[str, str]] = None,\n        age_ranges: List[int] = None,\n        **kwargs,\n    ):\n\"\"\"Script to be used by [``compute()``][edsteva.probes.base.BaseProbe.compute]\n\n        Parameters\n        ----------\n        data : Data\n            Instantiated [``HiveData``][edsteva.io.hive.HiveData], [``PostgresData``][edsteva.io.postgres.PostgresData] or [``LocalData``][edsteva.io.files.LocalData]\n        care_site_relationship: pd.DataFrame\n            DataFrame computed in the [``compute()``][edsteva.probes.base.BaseProbe.compute] that gives the hierarchy of the care site structure.\n        start_date: datetime, optional\n            **EXAMPLE**: `\"2019-05-01\"`\n        end_date: datetime, optional\n            **EXAMPLE**: `\"2021-07-01\"`\n        source_terminologies: Dict[str, str], optional\n            Dictionary of regex used to detect terminology in the column `vocabulary_id`.\n\n            **EXAMPLE**: `{\"GLIMS_LOINC\": r\"GLIMS.{0,20}LOINC\"}`\n        mapping: List[Tuple[str, str, str]], optional\n            List of values to filter in the column `relationship_id` in order to map between 2 terminologies.\n\n            **EXAMPLE**: `[(\"ANALYSES_LABORATOIRE\", \"GLIMS_ANABIO\", \"Maps to\")]`\n        concepts_sets: Union[str, Dict[str, str]] , optional\n            **EXAMPLE**: `{\"Cr\u00e9atinine\": \"E3180|G1974|J1002|A7813|A0094|G1975|J1172|G7834|F9409|F9410|C0697|H4038|F2621\", \"Leucocytes\": r\"A0174|K3232|H6740|E4358|C9784|C8824|E6953\"}`\n        concept_codes: Union[bool, List[str]], optional\n            **EXAMPLE**: ['E3180', 'G1974', 'J1002', 'A7813', 'A0094', 'G1975', 'J1172', 'G7834', 'F9409', 'F9410', 'C0697', 'H4038']`\n        care_site_ids : List[int], optional\n            **EXAMPLE**: `[8312056386, 8312027648]`\n        care_site_short_names : List[str], optional\n            **EXAMPLE**: `[\"HOSPITAL 1\", \"HOSPITAL 2\"]`\n        care_site_levels : Union[bool, str, List[str]], optional\n            **EXAMPLE**: `[\"Hospital\", \"Pole\", \"UF\", \"UC\", \"UH\"]`\n        care_sites_sets: Union[str, Dict[str, str]], optional\n            **EXAMPLE**: `{\"All AP-HP\": \".*\"}` or `{\"All AP-HP\": \".*\", \"Pediatrics\": r\"debre|trousseau|necker\"}`\n        care_site_specialties: Union[bool, List[str]], optional\n            **EXAMPLE**: `[\"CARDIOLOGIE\", \"CHIRURGIE\"]`\n        specialties_sets: Union[str, Dict[str, str]], optional\n            **EXAMPLE**: `{\"All\": \".*\"}` or `{\"All\": \".*\", \"ICU\": r\"REA\\s|USI\\s|SC\\s\"}`\n        stay_types: Union[bool, str, Dict[str, str]], optional\n            **EXAMPLE**: `{\"All\": \".*\"}` or `{\"All\": \".*\", \"Urg_and_consult\": \"urgences|consultation\"}` or `\"hospitalis\u00e9s`\n        stay_sources: Union[bool, str, Dict[str, str]], optional\n            **EXAMPLE**: `{\"All\": \".*\"}, {\"MCO\" : \"MCO\", \"MCO_PSY_SSR\" : \"MCO|Psychiatrie|SSR\"}`\n        length_of_stays: List[float], optional\n            **EXAMPLE**: `[1, 30]`\n        provenance_sources: Union[bool, str, Dict[str, str]], optional\n            **EXAMPLE**: `{\"All\": \".*\"}, {\"urgence\" : \"service d'urgence\"}`\n        age_ranges: List[int], optional\n            **EXAMPLE**: `[18, 64]`\n        \"\"\"\n        if not concepts_sets and \"concepts_set\" in self._index:\n            self._index.remove(\"concepts_set\")\n        if not concept_codes:\n            for terminology in self._standard_terminologies:\n                if \"{}_concept_code\".format(terminology) in self._index:\n                    self._index.remove(\"{}_concept_code\".format(terminology))\n        if not care_site_levels and \"care_site_level\" in self._index:\n            self._index.remove(\"care_site_level\")\n        if not care_sites_sets and \"care_sites_set\" in self._index:\n            self._index.remove(\"care_sites_set\")\n        if not care_site_specialties and \"care_site_specialty\" in self._index:\n            self._index.remove(\"care_site_specialty\")\n        if not specialties_sets and \"specialties_set\" in self._index:\n            self._index.remove(\"specialties_set\")\n        if not stay_types and \"stay_type\" in self._index:\n            self._index.remove(\"stay_type\")\n        if not stay_sources and \"stay_source\" in self._index:\n            self._index.remove(\"stay_source\")\n        if not length_of_stays and \"length_of_stay\" in self._index:\n            self._index.remove(\"length_of_stay\")\n        if not provenance_sources and \"provenance_source\" in self._index:\n            self._index.remove(\"provenance_source\")\n        if not age_ranges and \"age_range\" in self._index:\n            self._index.remove(\"age_range\")\n        return completeness_predictors.get(self._completeness_predictor)(\n            self,\n            data=data,\n            care_site_relationship=care_site_relationship,\n            start_date=start_date,\n            end_date=end_date,\n            care_site_levels=care_site_levels,\n            stay_types=stay_types,\n            care_site_ids=care_site_ids,\n            care_site_short_names=care_site_short_names,\n            care_site_specialties=care_site_specialties,\n            concept_codes=concept_codes,\n            care_sites_sets=care_sites_sets,\n            specialties_sets=specialties_sets,\n            concepts_sets=concepts_sets,\n            length_of_stays=length_of_stays,\n            source_terminologies=source_terminologies,\n            mapping=mapping,\n            provenance_sources=provenance_sources,\n            stay_sources=stay_sources,\n            age_ranges=age_ranges,\n            **kwargs,\n        )\n\n    def get_viz_config(self, viz_type: str, **kwargs):\n        if viz_type in viz_configs.keys():\n            _viz_config = self._viz_config.get(viz_type)\n            if _viz_config is None:\n                _viz_config = self._completeness_predictor\n        else:\n            raise ValueError(f\"edsteva has no {viz_type} registry !\")\n        return viz_configs[viz_type].get(_viz_config)(self, **kwargs)\n\n    def available_completeness_predictors(self):\n        return list(completeness_predictors.get_all().keys())\n</code></pre>"},{"location":"reference/probes/biology/biology/#edsteva.probes.biology.biology.BiologyProbe.compute_process","title":"compute_process","text":"<pre><code>compute_process(\n    data: Data,\n    care_site_relationship: pd.DataFrame,\n    start_date: datetime,\n    end_date: datetime,\n    source_terminologies: Dict[str, str] = {\n        \"ANALYSES_LABORATOIRE\": \"Analyses Laboratoire\",\n        \"GLIMS_ANABIO\": \"GLIMS.{0,20}Anabio\",\n        \"GLIMS_LOINC\": \"GLIMS.{0,20}LOINC\",\n        \"ANABIO_ITM\": \"ITM - ANABIO\",\n        \"LOINC_ITM\": \"ITM - LOINC\",\n    },\n    mapping: List[Tuple[str, str, str]] = [\n        (\"ANALYSES_LABORATOIRE\", \"GLIMS_ANABIO\", \"Maps to\"),\n        (\"ANALYSES_LABORATOIRE\", \"GLIMS_LOINC\", \"Maps to\"),\n        (\"GLIMS_ANABIO\", \"ANABIO_ITM\", \"Mapped from\"),\n        (\"ANABIO_ITM\", \"LOINC_ITM\", \"Maps to\"),\n    ],\n    concept_codes: Union[bool, List[str]] = None,\n    concepts_sets: Union[str, Dict[str, str]] = {\n        \"Leucocytes\": \"A0174|K3232|H6740|E4358|C9784|C8824|E6953\",\n        \"Plaquettes\": \"E4812|C0326|A1636|A0230|H6751|A1598|G7728|G7727|G7833|A2538|A2539|J4463\",\n        \"Cr\u00e9atinine\": \"E3180|G1974|J1002|A7813|A0094|G1975|J1172|G7834|F9409|F9410|C0697|H4038|F2621\",\n        \"Potassium\": \"A1656|C8757|C8758|A2380|E2073|L5014|F2618|E2337|J1178|A3819|J1181\",\n        \"Sodium\": \"A1772|C8759|C8760|A0262|J1177|F8162|L5013|F2617|K9086|J1180\",\n        \"Chlorure\": \"B5597|F2359|A0079|J1179|F2619|J1182|F2358|A0079|J1179|F2619|J1182\",\n        \"Glucose\": \"A1245|E7961|C8796|H7753|A8029|H7749|A0141|H7323|J7401|F2622|B9553|C7236|E7312|G9557|A7338|H7324|C0565|E9889|A8424|F6235|F5659|F2406\",\n        \"Bicarbonate\": \"A0422|H9622|C6408|F4161\",\n    },\n    care_site_ids: List[int] = None,\n    care_site_short_names: List[str] = None,\n    care_site_levels: Union[bool, str, List[str]] = True,\n    care_sites_sets: Union[str, Dict[str, str]] = None,\n    care_site_specialties: Union[bool, List[str]] = None,\n    specialties_sets: Union[str, Dict[str, str]] = None,\n    stay_types: Union[bool, str, Dict[str, str]] = True,\n    stay_sources: Union[bool, str, Dict[str, str]] = None,\n    length_of_stays: List[float] = [1],\n    provenance_sources: Union[\n        bool, str, Dict[str, str]\n    ] = None,\n    age_ranges: List[int] = None,\n    **kwargs\n)\n</code></pre> <p>Script to be used by <code>compute()</code></p> PARAMETER DESCRIPTION <code>data</code> <p>Instantiated <code>HiveData</code>, <code>PostgresData</code> or <code>LocalData</code></p> <p> TYPE: <code>Data</code> </p> <code>care_site_relationship</code> <p>DataFrame computed in the <code>compute()</code> that gives the hierarchy of the care site structure.</p> <p> TYPE: <code>pd.DataFrame</code> </p> <code>start_date</code> <p>EXAMPLE: <code>\"2019-05-01\"</code></p> <p> TYPE: <code>datetime</code> </p> <code>end_date</code> <p>EXAMPLE: <code>\"2021-07-01\"</code></p> <p> TYPE: <code>datetime</code> </p> <code>source_terminologies</code> <p>Dictionary of regex used to detect terminology in the column <code>vocabulary_id</code>.</p> <p>EXAMPLE: <code>{\"GLIMS_LOINC\": r\"GLIMS.{0,20}LOINC\"}</code></p> <p> TYPE: <code>Dict[str, str]</code> DEFAULT: <code>{'ANALYSES_LABORATOIRE': 'Analyses Laboratoire', 'GLIMS_ANABIO': 'GLIMS.{0,20}Anabio', 'GLIMS_LOINC': 'GLIMS.{0,20}LOINC', 'ANABIO_ITM': 'ITM - ANABIO', 'LOINC_ITM': 'ITM - LOINC'}</code> </p> <code>mapping</code> <p>List of values to filter in the column <code>relationship_id</code> in order to map between 2 terminologies.</p> <p>EXAMPLE: <code>[(\"ANALYSES_LABORATOIRE\", \"GLIMS_ANABIO\", \"Maps to\")]</code></p> <p> TYPE: <code>List[Tuple[str, str, str]]</code> DEFAULT: <code>[('ANALYSES_LABORATOIRE', 'GLIMS_ANABIO', 'Maps to'), ('ANALYSES_LABORATOIRE', 'GLIMS_LOINC', 'Maps to'), ('GLIMS_ANABIO', 'ANABIO_ITM', 'Mapped from'), ('ANABIO_ITM', 'LOINC_ITM', 'Maps to')]</code> </p> <code>concepts_sets</code> <p>EXAMPLE: <code>{\"Cr\u00e9atinine\": \"E3180|G1974|J1002|A7813|A0094|G1975|J1172|G7834|F9409|F9410|C0697|H4038|F2621\", \"Leucocytes\": r\"A0174|K3232|H6740|E4358|C9784|C8824|E6953\"}</code></p> <p> TYPE: <code>Union[str, Dict[str, str]]</code> DEFAULT: <code>{'Leucocytes': 'A0174|K3232|H6740|E4358|C9784|C8824|E6953', 'Plaquettes': 'E4812|C0326|A1636|A0230|H6751|A1598|G7728|G7727|G7833|A2538|A2539|J4463', 'Cr\u00e9atinine': 'E3180|G1974|J1002|A7813|A0094|G1975|J1172|G7834|F9409|F9410|C0697|H4038|F2621', 'Potassium': 'A1656|C8757|C8758|A2380|E2073|L5014|F2618|E2337|J1178|A3819|J1181', 'Sodium': 'A1772|C8759|C8760|A0262|J1177|F8162|L5013|F2617|K9086|J1180', 'Chlorure': 'B5597|F2359|A0079|J1179|F2619|J1182|F2358|A0079|J1179|F2619|J1182', 'Glucose': 'A1245|E7961|C8796|H7753|A8029|H7749|A0141|H7323|J7401|F2622|B9553|C7236|E7312|G9557|A7338|H7324|C0565|E9889|A8424|F6235|F5659|F2406', 'Bicarbonate': 'A0422|H9622|C6408|F4161'}</code> </p> <code>concept_codes</code> <p>EXAMPLE: ['E3180', 'G1974', 'J1002', 'A7813', 'A0094', 'G1975', 'J1172', 'G7834', 'F9409', 'F9410', 'C0697', 'H4038']`</p> <p> TYPE: <code>Union[bool, List[str]]</code> DEFAULT: <code>None</code> </p> <code>care_site_ids</code> <p>EXAMPLE: <code>[8312056386, 8312027648]</code></p> <p> TYPE: <code>List[int]</code> DEFAULT: <code>None</code> </p> <code>care_site_short_names</code> <p>EXAMPLE: <code>[\"HOSPITAL 1\", \"HOSPITAL 2\"]</code></p> <p> TYPE: <code>List[str]</code> DEFAULT: <code>None</code> </p> <code>care_site_levels</code> <p>EXAMPLE: <code>[\"Hospital\", \"Pole\", \"UF\", \"UC\", \"UH\"]</code></p> <p> TYPE: <code>Union[bool, str, List[str]]</code> DEFAULT: <code>True</code> </p> <code>care_sites_sets</code> <p>EXAMPLE: <code>{\"All AP-HP\": \".*\"}</code> or <code>{\"All AP-HP\": \".*\", \"Pediatrics\": r\"debre|trousseau|necker\"}</code></p> <p> TYPE: <code>Union[str, Dict[str, str]]</code> DEFAULT: <code>None</code> </p> <code>care_site_specialties</code> <p>EXAMPLE: <code>[\"CARDIOLOGIE\", \"CHIRURGIE\"]</code></p> <p> TYPE: <code>Union[bool, List[str]]</code> DEFAULT: <code>None</code> </p> <code>specialties_sets</code> <p>EXAMPLE: <code>{\"All\": \".*\"}</code> or <code>{\"All\": \".*\", \"ICU\": r\"REA\\s|USI\\s|SC\\s\"}</code></p> <p> TYPE: <code>Union[str, Dict[str, str]]</code> DEFAULT: <code>None</code> </p> <code>stay_types</code> <p>EXAMPLE: <code>{\"All\": \".*\"}</code> or <code>{\"All\": \".*\", \"Urg_and_consult\": \"urgences|consultation\"}</code> or <code>\"hospitalis\u00e9s</code></p> <p> TYPE: <code>Union[bool, str, Dict[str, str]]</code> DEFAULT: <code>True</code> </p> <code>stay_sources</code> <p>EXAMPLE: <code>{\"All\": \".*\"}, {\"MCO\" : \"MCO\", \"MCO_PSY_SSR\" : \"MCO|Psychiatrie|SSR\"}</code></p> <p> TYPE: <code>Union[bool, str, Dict[str, str]]</code> DEFAULT: <code>None</code> </p> <code>length_of_stays</code> <p>EXAMPLE: <code>[1, 30]</code></p> <p> TYPE: <code>List[float]</code> DEFAULT: <code>[1]</code> </p> <code>provenance_sources</code> <p>EXAMPLE: <code>{\"All\": \".*\"}, {\"urgence\" : \"service d'urgence\"}</code></p> <p> TYPE: <code>Union[bool, str, Dict[str, str]]</code> DEFAULT: <code>None</code> </p> <code>age_ranges</code> <p>EXAMPLE: <code>[18, 64]</code></p> <p> TYPE: <code>List[int]</code> DEFAULT: <code>None</code> </p> Source code in <code>edsteva/probes/biology/biology.py</code> <pre><code>def compute_process(\n    self,\n    data: Data,\n    care_site_relationship: pd.DataFrame,\n    start_date: datetime,\n    end_date: datetime,\n    source_terminologies: Dict[str, str] = {\n        \"ANALYSES_LABORATOIRE\": r\"Analyses Laboratoire\",\n        \"GLIMS_ANABIO\": r\"GLIMS.{0,20}Anabio\",\n        \"GLIMS_LOINC\": r\"GLIMS.{0,20}LOINC\",\n        \"ANABIO_ITM\": r\"ITM - ANABIO\",\n        \"LOINC_ITM\": r\"ITM - LOINC\",\n    },\n    mapping: List[Tuple[str, str, str]] = [\n        (\"ANALYSES_LABORATOIRE\", \"GLIMS_ANABIO\", \"Maps to\"),\n        (\"ANALYSES_LABORATOIRE\", \"GLIMS_LOINC\", \"Maps to\"),\n        (\"GLIMS_ANABIO\", \"ANABIO_ITM\", \"Mapped from\"),\n        (\"ANABIO_ITM\", \"LOINC_ITM\", \"Maps to\"),\n    ],\n    concept_codes: Union[bool, List[str]] = None,\n    concepts_sets: Union[str, Dict[str, str]] = {\n        \"Leucocytes\": \"A0174|K3232|H6740|E4358|C9784|C8824|E6953\",\n        \"Plaquettes\": \"E4812|C0326|A1636|A0230|H6751|A1598|G7728|G7727|G7833|A2538|A2539|J4463\",\n        \"Cr\u00e9atinine\": \"E3180|G1974|J1002|A7813|A0094|G1975|J1172|G7834|F9409|F9410|C0697|H4038|F2621\",\n        \"Potassium\": \"A1656|C8757|C8758|A2380|E2073|L5014|F2618|E2337|J1178|A3819|J1181\",\n        \"Sodium\": \"A1772|C8759|C8760|A0262|J1177|F8162|L5013|F2617|K9086|J1180\",\n        \"Chlorure\": \"B5597|F2359|A0079|J1179|F2619|J1182|F2358|A0079|J1179|F2619|J1182\",\n        \"Glucose\": \"A1245|E7961|C8796|H7753|A8029|H7749|A0141|H7323|J7401|F2622|B9553|C7236|E7312|G9557|A7338|H7324|C0565|E9889|A8424|F6235|F5659|F2406\",\n        \"Bicarbonate\": \"A0422|H9622|C6408|F4161\",\n    },\n    care_site_ids: List[int] = None,\n    care_site_short_names: List[str] = None,\n    care_site_levels: Union[bool, str, List[str]] = True,\n    care_sites_sets: Union[str, Dict[str, str]] = None,\n    care_site_specialties: Union[bool, List[str]] = None,\n    specialties_sets: Union[str, Dict[str, str]] = None,\n    stay_types: Union[bool, str, Dict[str, str]] = True,\n    stay_sources: Union[bool, str, Dict[str, str]] = None,\n    length_of_stays: List[float] = [1],\n    provenance_sources: Union[bool, str, Dict[str, str]] = None,\n    age_ranges: List[int] = None,\n    **kwargs,\n):\n\"\"\"Script to be used by [``compute()``][edsteva.probes.base.BaseProbe.compute]\n\n    Parameters\n    ----------\n    data : Data\n        Instantiated [``HiveData``][edsteva.io.hive.HiveData], [``PostgresData``][edsteva.io.postgres.PostgresData] or [``LocalData``][edsteva.io.files.LocalData]\n    care_site_relationship: pd.DataFrame\n        DataFrame computed in the [``compute()``][edsteva.probes.base.BaseProbe.compute] that gives the hierarchy of the care site structure.\n    start_date: datetime, optional\n        **EXAMPLE**: `\"2019-05-01\"`\n    end_date: datetime, optional\n        **EXAMPLE**: `\"2021-07-01\"`\n    source_terminologies: Dict[str, str], optional\n        Dictionary of regex used to detect terminology in the column `vocabulary_id`.\n\n        **EXAMPLE**: `{\"GLIMS_LOINC\": r\"GLIMS.{0,20}LOINC\"}`\n    mapping: List[Tuple[str, str, str]], optional\n        List of values to filter in the column `relationship_id` in order to map between 2 terminologies.\n\n        **EXAMPLE**: `[(\"ANALYSES_LABORATOIRE\", \"GLIMS_ANABIO\", \"Maps to\")]`\n    concepts_sets: Union[str, Dict[str, str]] , optional\n        **EXAMPLE**: `{\"Cr\u00e9atinine\": \"E3180|G1974|J1002|A7813|A0094|G1975|J1172|G7834|F9409|F9410|C0697|H4038|F2621\", \"Leucocytes\": r\"A0174|K3232|H6740|E4358|C9784|C8824|E6953\"}`\n    concept_codes: Union[bool, List[str]], optional\n        **EXAMPLE**: ['E3180', 'G1974', 'J1002', 'A7813', 'A0094', 'G1975', 'J1172', 'G7834', 'F9409', 'F9410', 'C0697', 'H4038']`\n    care_site_ids : List[int], optional\n        **EXAMPLE**: `[8312056386, 8312027648]`\n    care_site_short_names : List[str], optional\n        **EXAMPLE**: `[\"HOSPITAL 1\", \"HOSPITAL 2\"]`\n    care_site_levels : Union[bool, str, List[str]], optional\n        **EXAMPLE**: `[\"Hospital\", \"Pole\", \"UF\", \"UC\", \"UH\"]`\n    care_sites_sets: Union[str, Dict[str, str]], optional\n        **EXAMPLE**: `{\"All AP-HP\": \".*\"}` or `{\"All AP-HP\": \".*\", \"Pediatrics\": r\"debre|trousseau|necker\"}`\n    care_site_specialties: Union[bool, List[str]], optional\n        **EXAMPLE**: `[\"CARDIOLOGIE\", \"CHIRURGIE\"]`\n    specialties_sets: Union[str, Dict[str, str]], optional\n        **EXAMPLE**: `{\"All\": \".*\"}` or `{\"All\": \".*\", \"ICU\": r\"REA\\s|USI\\s|SC\\s\"}`\n    stay_types: Union[bool, str, Dict[str, str]], optional\n        **EXAMPLE**: `{\"All\": \".*\"}` or `{\"All\": \".*\", \"Urg_and_consult\": \"urgences|consultation\"}` or `\"hospitalis\u00e9s`\n    stay_sources: Union[bool, str, Dict[str, str]], optional\n        **EXAMPLE**: `{\"All\": \".*\"}, {\"MCO\" : \"MCO\", \"MCO_PSY_SSR\" : \"MCO|Psychiatrie|SSR\"}`\n    length_of_stays: List[float], optional\n        **EXAMPLE**: `[1, 30]`\n    provenance_sources: Union[bool, str, Dict[str, str]], optional\n        **EXAMPLE**: `{\"All\": \".*\"}, {\"urgence\" : \"service d'urgence\"}`\n    age_ranges: List[int], optional\n        **EXAMPLE**: `[18, 64]`\n    \"\"\"\n    if not concepts_sets and \"concepts_set\" in self._index:\n        self._index.remove(\"concepts_set\")\n    if not concept_codes:\n        for terminology in self._standard_terminologies:\n            if \"{}_concept_code\".format(terminology) in self._index:\n                self._index.remove(\"{}_concept_code\".format(terminology))\n    if not care_site_levels and \"care_site_level\" in self._index:\n        self._index.remove(\"care_site_level\")\n    if not care_sites_sets and \"care_sites_set\" in self._index:\n        self._index.remove(\"care_sites_set\")\n    if not care_site_specialties and \"care_site_specialty\" in self._index:\n        self._index.remove(\"care_site_specialty\")\n    if not specialties_sets and \"specialties_set\" in self._index:\n        self._index.remove(\"specialties_set\")\n    if not stay_types and \"stay_type\" in self._index:\n        self._index.remove(\"stay_type\")\n    if not stay_sources and \"stay_source\" in self._index:\n        self._index.remove(\"stay_source\")\n    if not length_of_stays and \"length_of_stay\" in self._index:\n        self._index.remove(\"length_of_stay\")\n    if not provenance_sources and \"provenance_source\" in self._index:\n        self._index.remove(\"provenance_source\")\n    if not age_ranges and \"age_range\" in self._index:\n        self._index.remove(\"age_range\")\n    return completeness_predictors.get(self._completeness_predictor)(\n        self,\n        data=data,\n        care_site_relationship=care_site_relationship,\n        start_date=start_date,\n        end_date=end_date,\n        care_site_levels=care_site_levels,\n        stay_types=stay_types,\n        care_site_ids=care_site_ids,\n        care_site_short_names=care_site_short_names,\n        care_site_specialties=care_site_specialties,\n        concept_codes=concept_codes,\n        care_sites_sets=care_sites_sets,\n        specialties_sets=specialties_sets,\n        concepts_sets=concepts_sets,\n        length_of_stays=length_of_stays,\n        source_terminologies=source_terminologies,\n        mapping=mapping,\n        provenance_sources=provenance_sources,\n        stay_sources=stay_sources,\n        age_ranges=age_ranges,\n        **kwargs,\n    )\n</code></pre>"},{"location":"reference/probes/biology/completeness_predictors/","title":"<code>edsteva.probes.biology.completeness_predictors</code>","text":""},{"location":"reference/probes/biology/completeness_predictors/per_measurement/","title":"<code>edsteva.probes.biology.completeness_predictors.per_measurement</code>","text":""},{"location":"reference/probes/biology/completeness_predictors/per_measurement/#edsteva.probes.biology.completeness_predictors.per_measurement.compute_completeness_predictor_per_measurement","title":"compute_completeness_predictor_per_measurement","text":"<pre><code>compute_completeness_predictor_per_measurement(\n    self,\n    data: Data,\n    care_site_relationship: pd.DataFrame,\n    start_date: datetime,\n    end_date: datetime,\n    care_site_levels: Union[bool, str, List[str]],\n    stay_types: Union[bool, str, Dict[str, str]],\n    care_site_ids: List[int],\n    care_site_short_names: List[str],\n    care_site_specialties: Union[bool, List[str]],\n    concept_codes: Union[bool, List[str]],\n    care_sites_sets: Union[str, Dict[str, str]],\n    specialties_sets: Union[str, Dict[str, str]],\n    concepts_sets: Union[str, Dict[str, str]],\n    length_of_stays: List[float],\n    source_terminologies: Dict[str, str],\n    mapping: List[Tuple[str, str, str]],\n    age_ranges: List[int],\n    provenance_sources: Union[bool, str, Dict[str, str]],\n    stay_sources: Union[bool, str, Dict[str, str]],\n    **kwargs\n)\n</code></pre> <p>Script to be used by <code>compute()</code></p> <p>The <code>per_measurement</code> algorithm computes \\(c_(t)\\) the availability of biological measurements:</p> \\[ c(t) = \\frac{n_{biology}(t)}{n_{max}} \\] <p>Where \\(n_{biology}(t)\\) is the number of biological measurements, \\(t\\) is the month and \\(n_{max} = \\max_{t}(n_{biology}(t))\\).</p> Source code in <code>edsteva/probes/biology/completeness_predictors/per_measurement.py</code> <pre><code>def compute_completeness_predictor_per_measurement(\n    self,\n    data: Data,\n    care_site_relationship: pd.DataFrame,\n    start_date: datetime,\n    end_date: datetime,\n    care_site_levels: Union[bool, str, List[str]],\n    stay_types: Union[bool, str, Dict[str, str]],\n    care_site_ids: List[int],\n    care_site_short_names: List[str],\n    care_site_specialties: Union[bool, List[str]],\n    concept_codes: Union[bool, List[str]],\n    care_sites_sets: Union[str, Dict[str, str]],\n    specialties_sets: Union[str, Dict[str, str]],\n    concepts_sets: Union[str, Dict[str, str]],\n    length_of_stays: List[float],\n    source_terminologies: Dict[str, str],\n    mapping: List[Tuple[str, str, str]],\n    age_ranges: List[int],\n    provenance_sources: Union[bool, str, Dict[str, str]],\n    stay_sources: Union[bool, str, Dict[str, str]],\n    **kwargs\n):\nr\"\"\"Script to be used by [``compute()``][edsteva.probes.base.BaseProbe.compute]\n\n    The ``per_measurement`` algorithm computes $c_(t)$ the availability of biological measurements:\n\n    $$\n    c(t) = \\frac{n_{biology}(t)}{n_{max}}\n    $$\n\n    Where $n_{biology}(t)$ is the number of biological measurements, $t$ is the month and $n_{max} = \\max_{t}(n_{biology}(t))$.\n    \"\"\"\n    self._metrics = [\"c\", \"n_measurement\"]\n    check_tables(\n        data=data,\n        required_tables=[\n            \"measurement\",\n            \"concept\",\n            \"concept_relationship\",\n        ],\n    )\n    standard_terminologies = self._standard_terminologies\n    biology_relationship = prepare_biology_relationship(\n        data=data,\n        standard_terminologies=standard_terminologies,\n        source_terminologies=source_terminologies,\n        mapping=mapping,\n    )\n\n    self.biology_relationship = biology_relationship\n    root_terminology = mapping[0][0]\n\n    person = prepare_person(data)\n\n    measurement = prepare_measurement(\n        data=data,\n        biology_relationship=biology_relationship,\n        concept_codes=concept_codes,\n        concepts_sets=concepts_sets,\n        start_date=start_date,\n        end_date=end_date,\n        root_terminology=root_terminology,\n        standard_terminologies=standard_terminologies,\n        per_visit=False,\n    )\n\n    visit_occurrence = prepare_visit_occurrence(\n        data=data,\n        start_date=None,\n        end_date=None,\n        stay_types=stay_types,\n        length_of_stays=length_of_stays,\n        provenance_sources=provenance_sources,\n        stay_sources=stay_sources,\n        person=person,\n        age_ranges=age_ranges,\n    ).drop(columns=[\"visit_occurrence_source_value\", \"date\"])\n\n    care_site = prepare_care_site(\n        data=data,\n        care_site_ids=care_site_ids,\n        care_site_short_names=care_site_short_names,\n        care_site_specialties=care_site_specialties,\n        care_sites_sets=care_sites_sets,\n        specialties_sets=specialties_sets,\n        care_site_relationship=care_site_relationship,\n    )\n\n    hospital_visit = get_hospital_measurements(\n        measurement=measurement,\n        visit_occurrence=visit_occurrence,\n        care_site=care_site,\n    )\n    hospital_name = CARE_SITE_LEVEL_NAMES[\"Hospital\"]\n    biology_predictor_by_level = {hospital_name: hospital_visit}\n\n    if care_site_levels and not hospital_only(care_site_levels=care_site_levels):\n        logger.info(\n            \"Biological measurements are only available at hospital level for now\"\n        )\n        care_site_levels = \"Hospital\"\n\n    biology_predictor = concatenate_predictor_by_level(\n        predictor_by_level=biology_predictor_by_level,\n        care_site_levels=care_site_levels,\n    )\n\n    return compute_completeness(self, biology_predictor)\n</code></pre>"},{"location":"reference/probes/biology/completeness_predictors/per_visit/","title":"<code>edsteva.probes.biology.completeness_predictors.per_visit</code>","text":""},{"location":"reference/probes/biology/completeness_predictors/per_visit/#edsteva.probes.biology.completeness_predictors.per_visit.compute_completeness_predictor_per_visit","title":"compute_completeness_predictor_per_visit","text":"<pre><code>compute_completeness_predictor_per_visit(\n    self,\n    data: Data,\n    care_site_relationship: pd.DataFrame,\n    start_date: datetime,\n    end_date: datetime,\n    care_site_levels: Union[bool, str, List[str]],\n    stay_types: Union[bool, str, Dict[str, str]],\n    care_site_ids: List[int],\n    care_site_short_names: List[str],\n    care_site_specialties: Union[bool, List[str]],\n    concept_codes: Union[bool, List[str]],\n    care_sites_sets: Union[str, Dict[str, str]],\n    specialties_sets: Union[str, Dict[str, str]],\n    concepts_sets: Union[str, Dict[str, str]],\n    length_of_stays: List[float],\n    source_terminologies: Dict[str, str],\n    mapping: List[Tuple[str, str, str]],\n    age_ranges: List[int],\n    provenance_sources: Union[bool, str, Dict[str, str]],\n    stay_sources: Union[bool, str, Dict[str, str]],\n    **kwargs\n)\n</code></pre> <p>Script to be used by <code>compute()</code></p> <p>The <code>per_visit</code> algorithm computes \\(c_(t)\\) the availability of laboratory data related linked to patients' administrative stays:</p> \\[ c(t) = \\frac{n_{with\\,biology}(t)}{n_{visit}(t)} \\] <p>Where \\(n_{visit}(t)\\) is the number of administrative stays, \\(n_{with\\,condition}\\) the number of stays having at least one biological measurement recorded and \\(t\\) is the month.</p> Source code in <code>edsteva/probes/biology/completeness_predictors/per_visit.py</code> <pre><code>def compute_completeness_predictor_per_visit(\n    self,\n    data: Data,\n    care_site_relationship: pd.DataFrame,\n    start_date: datetime,\n    end_date: datetime,\n    care_site_levels: Union[bool, str, List[str]],\n    stay_types: Union[bool, str, Dict[str, str]],\n    care_site_ids: List[int],\n    care_site_short_names: List[str],\n    care_site_specialties: Union[bool, List[str]],\n    concept_codes: Union[bool, List[str]],\n    care_sites_sets: Union[str, Dict[str, str]],\n    specialties_sets: Union[str, Dict[str, str]],\n    concepts_sets: Union[str, Dict[str, str]],\n    length_of_stays: List[float],\n    source_terminologies: Dict[str, str],\n    mapping: List[Tuple[str, str, str]],\n    age_ranges: List[int],\n    provenance_sources: Union[bool, str, Dict[str, str]],\n    stay_sources: Union[bool, str, Dict[str, str]],\n    **kwargs\n):\nr\"\"\"Script to be used by [``compute()``][edsteva.probes.base.BaseProbe.compute]\n\n    The ``per_visit`` algorithm computes $c_(t)$ the availability of laboratory data related linked to patients' administrative stays:\n\n    $$\n    c(t) = \\frac{n_{with\\,biology}(t)}{n_{visit}(t)}\n    $$\n\n    Where $n_{visit}(t)$ is the number of administrative stays, $n_{with\\,condition}$ the number of stays having at least one biological measurement recorded and $t$ is the month.\n    \"\"\"\n    self._metrics = [\"c\", \"n_visit\", \"n_visit_with_measurement\"]\n    check_tables(\n        data=data,\n        required_tables=[\n            \"measurement\",\n            \"concept\",\n            \"concept_relationship\",\n            \"visit_occurrence\",\n        ],\n    )\n    standard_terminologies = self._standard_terminologies\n    biology_relationship = prepare_biology_relationship(\n        data=data,\n        standard_terminologies=standard_terminologies,\n        source_terminologies=source_terminologies,\n        mapping=mapping,\n    )\n\n    self.biology_relationship = biology_relationship\n    root_terminology = mapping[0][0]\n\n    person = prepare_person(data)\n\n    visit_occurrence = prepare_visit_occurrence(\n        data=data,\n        start_date=start_date,\n        end_date=end_date,\n        stay_types=stay_types,\n        length_of_stays=length_of_stays,\n        provenance_sources=provenance_sources,\n        stay_sources=stay_sources,\n        person=person,\n        age_ranges=age_ranges,\n    )\n\n    measurement = prepare_measurement(\n        data=data,\n        biology_relationship=biology_relationship,\n        concept_codes=concept_codes,\n        concepts_sets=concepts_sets,\n        root_terminology=root_terminology,\n        standard_terminologies=standard_terminologies,\n        per_visit=True,\n    )\n\n    care_site = prepare_care_site(\n        data=data,\n        care_site_ids=care_site_ids,\n        care_site_short_names=care_site_short_names,\n        care_site_specialties=care_site_specialties,\n        care_sites_sets=care_sites_sets,\n        specialties_sets=specialties_sets,\n        care_site_relationship=care_site_relationship,\n    )\n\n    hospital_visit = get_hospital_visit(\n        self,\n        measurement=measurement,\n        visit_occurrence=visit_occurrence,\n        care_site=care_site,\n    )\n    hospital_name = CARE_SITE_LEVEL_NAMES[\"Hospital\"]\n    biology_predictor_by_level = {hospital_name: hospital_visit}\n\n    if care_site_levels and not hospital_only(care_site_levels=care_site_levels):\n        logger.info(\n            \"Biological measurements are only available at hospital level for now\"\n        )\n        care_site_levels = \"Hospital\"\n\n    biology_predictor = concatenate_predictor_by_level(\n        predictor_by_level=biology_predictor_by_level,\n        care_site_levels=care_site_levels,\n    )\n\n    return compute_completeness(self, biology_predictor)\n</code></pre>"},{"location":"reference/probes/biology/viz_configs/","title":"<code>edsteva.probes.biology.viz_configs</code>","text":""},{"location":"reference/probes/biology/viz_configs/n_measurement/","title":"<code>edsteva.probes.biology.viz_configs.n_measurement</code>","text":""},{"location":"reference/probes/biology/viz_configs/n_measurement/defaults/","title":"<code>edsteva.probes.biology.viz_configs.n_measurement.defaults</code>","text":""},{"location":"reference/probes/biology/viz_configs/n_measurement/estimates_densities_plot/","title":"<code>edsteva.probes.biology.viz_configs.n_measurement.estimates_densities_plot</code>","text":""},{"location":"reference/probes/biology/viz_configs/n_measurement/normalized_probe_dashboard/","title":"<code>edsteva.probes.biology.viz_configs.n_measurement.normalized_probe_dashboard</code>","text":""},{"location":"reference/probes/biology/viz_configs/n_measurement/normalized_probe_plot/","title":"<code>edsteva.probes.biology.viz_configs.n_measurement.normalized_probe_plot</code>","text":""},{"location":"reference/probes/biology/viz_configs/n_measurement/probe_dashboard/","title":"<code>edsteva.probes.biology.viz_configs.n_measurement.probe_dashboard</code>","text":""},{"location":"reference/probes/biology/viz_configs/n_measurement/probe_plot/","title":"<code>edsteva.probes.biology.viz_configs.n_measurement.probe_plot</code>","text":""},{"location":"reference/probes/biology/viz_configs/per_measurement/","title":"<code>edsteva.probes.biology.viz_configs.per_measurement</code>","text":""},{"location":"reference/probes/biology/viz_configs/per_measurement/defaults/","title":"<code>edsteva.probes.biology.viz_configs.per_measurement.defaults</code>","text":""},{"location":"reference/probes/biology/viz_configs/per_measurement/estimates_densities_plot/","title":"<code>edsteva.probes.biology.viz_configs.per_measurement.estimates_densities_plot</code>","text":""},{"location":"reference/probes/biology/viz_configs/per_measurement/normalized_probe_dashboard/","title":"<code>edsteva.probes.biology.viz_configs.per_measurement.normalized_probe_dashboard</code>","text":""},{"location":"reference/probes/biology/viz_configs/per_measurement/normalized_probe_plot/","title":"<code>edsteva.probes.biology.viz_configs.per_measurement.normalized_probe_plot</code>","text":""},{"location":"reference/probes/biology/viz_configs/per_measurement/probe_dashboard/","title":"<code>edsteva.probes.biology.viz_configs.per_measurement.probe_dashboard</code>","text":""},{"location":"reference/probes/biology/viz_configs/per_measurement/probe_plot/","title":"<code>edsteva.probes.biology.viz_configs.per_measurement.probe_plot</code>","text":""},{"location":"reference/probes/biology/viz_configs/per_visit/","title":"<code>edsteva.probes.biology.viz_configs.per_visit</code>","text":""},{"location":"reference/probes/biology/viz_configs/per_visit/defaults/","title":"<code>edsteva.probes.biology.viz_configs.per_visit.defaults</code>","text":""},{"location":"reference/probes/biology/viz_configs/per_visit/estimates_densities_plot/","title":"<code>edsteva.probes.biology.viz_configs.per_visit.estimates_densities_plot</code>","text":""},{"location":"reference/probes/biology/viz_configs/per_visit/normalized_probe_dashboard/","title":"<code>edsteva.probes.biology.viz_configs.per_visit.normalized_probe_dashboard</code>","text":""},{"location":"reference/probes/biology/viz_configs/per_visit/normalized_probe_plot/","title":"<code>edsteva.probes.biology.viz_configs.per_visit.normalized_probe_plot</code>","text":""},{"location":"reference/probes/biology/viz_configs/per_visit/probe_dashboard/","title":"<code>edsteva.probes.biology.viz_configs.per_visit.probe_dashboard</code>","text":""},{"location":"reference/probes/biology/viz_configs/per_visit/probe_plot/","title":"<code>edsteva.probes.biology.viz_configs.per_visit.probe_plot</code>","text":""},{"location":"reference/probes/condition/","title":"<code>edsteva.probes.condition</code>","text":""},{"location":"reference/probes/condition/condition/","title":"<code>edsteva.probes.condition.condition</code>","text":""},{"location":"reference/probes/condition/condition/#edsteva.probes.condition.condition.ConditionProbe","title":"ConditionProbe","text":"<p>         Bases: <code>BaseProbe</code></p> <p>The <code>ConditionProbe</code> computes \\(c(t)\\) the availability of claim data:</p> PARAMETER DESCRIPTION <code>completeness_predictor</code> <p>Algorithm used to compute the completeness predictor</p> <p>EXAMPLE: <code>\"per_visit_default\"</code></p> <p> TYPE: <code>str</code> DEFAULT: <code>'per_visit_default'</code> </p> ATTRIBUTE DESCRIPTION <code>_completeness_predictor</code> <p>Algorithm used to compute the completeness predictor</p> <p>VALUE: <code>\"per_visit_default\"</code></p> <p> TYPE: <code>str</code> </p> <code>_index</code> <p>Variable from which data is grouped</p> <p>VALUE: <code>[\"care_site_level\", \"stay_type\", \"length_of_stay\", \"care_site_specialty\", \"specialties_set\", \"diag_type\", \"condition_type\", \"source_system\", \"care_site_id\"]</code></p> <p> TYPE: <code>List[str]</code> </p> <code>_viz_config</code> <p>Dictionary of configuration for visualization purpose.</p> <p>VALUE: <code>{}</code></p> <p> TYPE: <code>List[str]</code> </p> Source code in <code>edsteva/probes/condition/condition.py</code> <pre><code>class ConditionProbe(BaseProbe):\nr\"\"\"\n    The [``ConditionProbe``][edsteva.probes.condition.condition.ConditionProbe] computes $c(t)$ the availability of claim data:\n\n    Parameters\n    ----------\n    completeness_predictor: str\n        Algorithm used to compute the completeness predictor\n\n        **EXAMPLE**: ``\"per_visit_default\"``\n\n    Attributes\n    ----------\n    _completeness_predictor: str\n        Algorithm used to compute the completeness predictor\n\n        **VALUE**: ``\"per_visit_default\"``\n    _index: List[str]\n        Variable from which data is grouped\n\n        **VALUE**: ``[\"care_site_level\", \"stay_type\", \"length_of_stay\", \"care_site_specialty\", \"specialties_set\", \"diag_type\", \"condition_type\", \"source_system\", \"care_site_id\"]``\n    _viz_config: List[str]\n        Dictionary of configuration for visualization purpose.\n\n        **VALUE**: ``{}``\n    \"\"\"\n\n    def __init__(\n        self,\n        completeness_predictor: str = \"per_visit_default\",\n    ):\n        self._index = [\n            \"diag_type\",\n            \"condition_type\",\n            \"source_system\",\n            \"care_site_id\",\n            \"care_site_level\",\n            \"care_sites_set\",\n            \"care_site_specialty\",\n            \"specialties_set\",\n            \"stay_type\",\n            \"stay_source\",\n            \"length_of_stay\",\n            \"provenance_source\",\n            \"age_range\",\n        ]\n        super().__init__(\n            completeness_predictor=completeness_predictor,\n            index=self._index,\n        )\n\n    def compute_process(\n        self,\n        data: Data,\n        care_site_relationship: pd.DataFrame,\n        start_date: datetime,\n        end_date: datetime,\n        extra_data: Data = None,\n        diag_types: Union[bool, str, Dict[str, str]] = None,\n        condition_types: Union[bool, str, Dict[str, str]] = None,\n        source_systems: Union[bool, List[str]] = [\"ORBIS\"],\n        care_site_ids: List[int] = None,\n        care_site_short_names: List[str] = None,\n        care_site_levels: Union[bool, str, List[str]] = True,\n        care_sites_sets: Union[str, Dict[str, str]] = None,\n        care_site_specialties: Union[bool, List[str]] = None,\n        specialties_sets: Union[str, Dict[str, str]] = None,\n        stay_types: Union[bool, str, Dict[str, str]] = True,\n        stay_sources: Union[bool, str, Dict[str, str]] = None,\n        length_of_stays: List[float] = None,\n        provenance_sources: Union[bool, str, Dict[str, str]] = None,\n        age_ranges: List[int] = None,\n        **kwargs,\n    ):\n\"\"\"Script to be used by [``compute()``][edsteva.probes.base.BaseProbe.compute]\n\n        Parameters\n        ----------\n        data : Data\n            Instantiated [``HiveData``][edsteva.io.hive.HiveData], [``PostgresData``][edsteva.io.postgres.PostgresData] or [``LocalData``][edsteva.io.files.LocalData]\n        care_site_relationship : pd.DataFrame\n            DataFrame computed in the [``compute()``][edsteva.probes.base.BaseProbe.compute] that gives the hierarchy of the care site structure.\n        start_date : datetime, optional\n            **EXAMPLE**: `\"2019-05-01\"`\n        end_date : datetime, optional\n            **EXAMPLE**: `\"2021-07-01\"`\n        extra_data : Data, optional\n            Instantiated [``HiveData``][edsteva.io.hive.HiveData], [``PostgresData``][edsteva.io.postgres.PostgresData] or [``LocalData``][edsteva.io.files.LocalData]. This is not OMOP-standardized data but data needed to associate note with UF and Pole. If not provided, it will only compute the predictor for hospitals.\n        diag_types: Union[bool, str, Dict[str, str]], optional\n            **EXAMPLE**: `{\"All\": \".*\"}` or `{\"All\": \".*\", \"DP\\DR\": \"DP|DR\"}` or `\"DP\"`\n        condition_types: Union[bool, str, Dict[str, str]], optional\n            **EXAMPLE**: `{\"All\": \".*\"}` or `{\"All\": \".*\", \"Pulmonary_embolism\": \"I26\"}`\n        source_systems: Union[bool, List[str]], optional\n            **EXAMPLE**: `[\"AREM\", \"ORBIS\"]`\n        care_site_ids : List[int], optional\n            **EXAMPLE**: `[8312056386, 8312027648]`\n        care_site_short_names : List[str], optional\n            **EXAMPLE**: `[\"HOSPITAL 1\", \"HOSPITAL 2\"]`\n        care_site_levels : Union[bool, str, List[str]], optional\n            **EXAMPLE**: `[\"Hospital\", \"Pole\", \"UF\", \"UC\", \"UH\"]`\n        care_sites_sets: Union[str, Dict[str, str]], optional\n            **EXAMPLE**: `{\"All AP-HP\": \".*\"}` or `{\"All AP-HP\": \".*\", \"Pediatrics\": r\"debre|trousseau|necker\"}`\n        care_site_specialties: Union[bool, List[str]], optional\n            **EXAMPLE**: `[\"CARDIOLOGIE\", \"CHIRURGIE\"]`\n        specialties_sets: Union[str, Dict[str, str]], optional\n            **EXAMPLE**: `{\"All\": \".*\"}` or `{\"All\": \".*\", \"ICU\": r\"REA\\s|USI\\s|SC\\s\"}`\n        stay_types: Union[bool, str, Dict[str, str]], optional\n            **EXAMPLE**: `{\"All\": \".*\"}` or `{\"All\": \".*\", \"Urg_and_consult\": \"urgences|consultation\"}` or `\"hospitalis\u00e9s`\n        stay_sources: Union[bool, str, Dict[str, str]], optional\n            **EXAMPLE**: `{\"All\": \".*\"}, {\"MCO\" : \"MCO\", \"MCO_PSY_SSR\" : \"MCO|Psychiatrie|SSR\"}`\n        length_of_stays: List[float], optional\n            **EXAMPLE**: `[1, 30]`\n        provenance_sources: Union[bool, str, Dict[str, str]], optional\n            **EXAMPLE**: `{\"All\": \".*\"}, {\"urgence\" : \"service d'urgence\"}`\n        age_ranges: List[int], optional\n            **EXAMPLE**: `[18, 64]`\n        \"\"\"\n        if not diag_types and \"diag_type\" in self._index:\n            self._index.remove(\"diag_type\")\n        if not condition_types and \"condition_type\" in self._index:\n            self._index.remove(\"condition_type\")\n        if not source_systems and \"source_system\" in self._index:\n            self._index.remove(\"source_system\")\n        if not care_site_levels and \"care_site_level\" in self._index:\n            self._index.remove(\"care_site_level\")\n        if not care_sites_sets and \"care_sites_set\" in self._index:\n            self._index.remove(\"care_sites_set\")\n        if not care_site_specialties and \"care_site_specialty\" in self._index:\n            self._index.remove(\"care_site_specialty\")\n        if not specialties_sets and \"specialties_set\" in self._index:\n            self._index.remove(\"specialties_set\")\n        if not stay_types and \"stay_type\" in self._index:\n            self._index.remove(\"stay_type\")\n        if not stay_sources and \"stay_source\" in self._index:\n            self._index.remove(\"stay_source\")\n        if not length_of_stays and \"length_of_stay\" in self._index:\n            self._index.remove(\"length_of_stay\")\n        if not provenance_sources and \"provenance_source\" in self._index:\n            self._index.remove(\"provenance_source\")\n        if not age_ranges and \"age_range\" in self._index:\n            self._index.remove(\"age_range\")\n        return completeness_predictors.get(self._completeness_predictor)(\n            self,\n            data=data,\n            care_site_relationship=care_site_relationship,\n            start_date=start_date,\n            end_date=end_date,\n            care_site_levels=care_site_levels,\n            stay_types=stay_types,\n            care_site_ids=care_site_ids,\n            extra_data=extra_data,\n            care_site_short_names=care_site_short_names,\n            care_site_specialties=care_site_specialties,\n            care_sites_sets=care_sites_sets,\n            specialties_sets=specialties_sets,\n            diag_types=diag_types,\n            provenance_sources=provenance_sources,\n            length_of_stays=length_of_stays,\n            condition_types=condition_types,\n            source_systems=source_systems,\n            stay_sources=stay_sources,\n            age_ranges=age_ranges,\n            **kwargs,\n        )\n\n    def get_viz_config(self, viz_type: str, **kwargs):\n        if viz_type in viz_configs.keys():\n            _viz_config = self._viz_config.get(viz_type)\n            if _viz_config is None:\n                _viz_config = self._completeness_predictor\n        else:\n            raise ValueError(f\"edsteva has no {viz_type} registry !\")\n        return viz_configs[viz_type].get(_viz_config)(self, **kwargs)\n\n    def available_completeness_predictors(self):\n        return list(completeness_predictors.get_all().keys())\n</code></pre>"},{"location":"reference/probes/condition/condition/#edsteva.probes.condition.condition.ConditionProbe.compute_process","title":"compute_process","text":"<pre><code>compute_process(\n    data: Data,\n    care_site_relationship: pd.DataFrame,\n    start_date: datetime,\n    end_date: datetime,\n    extra_data: Data = None,\n    diag_types: Union[bool, str, Dict[str, str]] = None,\n    condition_types: Union[\n        bool, str, Dict[str, str]\n    ] = None,\n    source_systems: Union[bool, List[str]] = [\"ORBIS\"],\n    care_site_ids: List[int] = None,\n    care_site_short_names: List[str] = None,\n    care_site_levels: Union[bool, str, List[str]] = True,\n    care_sites_sets: Union[str, Dict[str, str]] = None,\n    care_site_specialties: Union[bool, List[str]] = None,\n    specialties_sets: Union[str, Dict[str, str]] = None,\n    stay_types: Union[bool, str, Dict[str, str]] = True,\n    stay_sources: Union[bool, str, Dict[str, str]] = None,\n    length_of_stays: List[float] = None,\n    provenance_sources: Union[\n        bool, str, Dict[str, str]\n    ] = None,\n    age_ranges: List[int] = None,\n    **kwargs\n)\n</code></pre> <p>Script to be used by <code>compute()</code></p> PARAMETER DESCRIPTION <code>data</code> <p>Instantiated <code>HiveData</code>, <code>PostgresData</code> or <code>LocalData</code></p> <p> TYPE: <code>Data</code> </p> <code>care_site_relationship</code> <p>DataFrame computed in the <code>compute()</code> that gives the hierarchy of the care site structure.</p> <p> TYPE: <code>pd.DataFrame</code> </p> <code>start_date</code> <p>EXAMPLE: <code>\"2019-05-01\"</code></p> <p> TYPE: <code>datetime</code> </p> <code>end_date</code> <p>EXAMPLE: <code>\"2021-07-01\"</code></p> <p> TYPE: <code>datetime</code> </p> <code>extra_data</code> <p>Instantiated <code>HiveData</code>, <code>PostgresData</code> or <code>LocalData</code>. This is not OMOP-standardized data but data needed to associate note with UF and Pole. If not provided, it will only compute the predictor for hospitals.</p> <p> TYPE: <code>Data</code> DEFAULT: <code>None</code> </p> <code>diag_types</code> <p>EXAMPLE: <code>{\"All\": \".*\"}</code> or <code>{\"All\": \".*\", \"DP\\DR\": \"DP|DR\"}</code> or <code>\"DP\"</code></p> <p> TYPE: <code>Union[bool, str, Dict[str, str]]</code> DEFAULT: <code>None</code> </p> <code>condition_types</code> <p>EXAMPLE: <code>{\"All\": \".*\"}</code> or <code>{\"All\": \".*\", \"Pulmonary_embolism\": \"I26\"}</code></p> <p> TYPE: <code>Union[bool, str, Dict[str, str]]</code> DEFAULT: <code>None</code> </p> <code>source_systems</code> <p>EXAMPLE: <code>[\"AREM\", \"ORBIS\"]</code></p> <p> TYPE: <code>Union[bool, List[str]]</code> DEFAULT: <code>['ORBIS']</code> </p> <code>care_site_ids</code> <p>EXAMPLE: <code>[8312056386, 8312027648]</code></p> <p> TYPE: <code>List[int]</code> DEFAULT: <code>None</code> </p> <code>care_site_short_names</code> <p>EXAMPLE: <code>[\"HOSPITAL 1\", \"HOSPITAL 2\"]</code></p> <p> TYPE: <code>List[str]</code> DEFAULT: <code>None</code> </p> <code>care_site_levels</code> <p>EXAMPLE: <code>[\"Hospital\", \"Pole\", \"UF\", \"UC\", \"UH\"]</code></p> <p> TYPE: <code>Union[bool, str, List[str]]</code> DEFAULT: <code>True</code> </p> <code>care_sites_sets</code> <p>EXAMPLE: <code>{\"All AP-HP\": \".*\"}</code> or <code>{\"All AP-HP\": \".*\", \"Pediatrics\": r\"debre|trousseau|necker\"}</code></p> <p> TYPE: <code>Union[str, Dict[str, str]]</code> DEFAULT: <code>None</code> </p> <code>care_site_specialties</code> <p>EXAMPLE: <code>[\"CARDIOLOGIE\", \"CHIRURGIE\"]</code></p> <p> TYPE: <code>Union[bool, List[str]]</code> DEFAULT: <code>None</code> </p> <code>specialties_sets</code> <p>EXAMPLE: <code>{\"All\": \".*\"}</code> or <code>{\"All\": \".*\", \"ICU\": r\"REA\\s|USI\\s|SC\\s\"}</code></p> <p> TYPE: <code>Union[str, Dict[str, str]]</code> DEFAULT: <code>None</code> </p> <code>stay_types</code> <p>EXAMPLE: <code>{\"All\": \".*\"}</code> or <code>{\"All\": \".*\", \"Urg_and_consult\": \"urgences|consultation\"}</code> or <code>\"hospitalis\u00e9s</code></p> <p> TYPE: <code>Union[bool, str, Dict[str, str]]</code> DEFAULT: <code>True</code> </p> <code>stay_sources</code> <p>EXAMPLE: <code>{\"All\": \".*\"}, {\"MCO\" : \"MCO\", \"MCO_PSY_SSR\" : \"MCO|Psychiatrie|SSR\"}</code></p> <p> TYPE: <code>Union[bool, str, Dict[str, str]]</code> DEFAULT: <code>None</code> </p> <code>length_of_stays</code> <p>EXAMPLE: <code>[1, 30]</code></p> <p> TYPE: <code>List[float]</code> DEFAULT: <code>None</code> </p> <code>provenance_sources</code> <p>EXAMPLE: <code>{\"All\": \".*\"}, {\"urgence\" : \"service d'urgence\"}</code></p> <p> TYPE: <code>Union[bool, str, Dict[str, str]]</code> DEFAULT: <code>None</code> </p> <code>age_ranges</code> <p>EXAMPLE: <code>[18, 64]</code></p> <p> TYPE: <code>List[int]</code> DEFAULT: <code>None</code> </p> Source code in <code>edsteva/probes/condition/condition.py</code> <pre><code>def compute_process(\n    self,\n    data: Data,\n    care_site_relationship: pd.DataFrame,\n    start_date: datetime,\n    end_date: datetime,\n    extra_data: Data = None,\n    diag_types: Union[bool, str, Dict[str, str]] = None,\n    condition_types: Union[bool, str, Dict[str, str]] = None,\n    source_systems: Union[bool, List[str]] = [\"ORBIS\"],\n    care_site_ids: List[int] = None,\n    care_site_short_names: List[str] = None,\n    care_site_levels: Union[bool, str, List[str]] = True,\n    care_sites_sets: Union[str, Dict[str, str]] = None,\n    care_site_specialties: Union[bool, List[str]] = None,\n    specialties_sets: Union[str, Dict[str, str]] = None,\n    stay_types: Union[bool, str, Dict[str, str]] = True,\n    stay_sources: Union[bool, str, Dict[str, str]] = None,\n    length_of_stays: List[float] = None,\n    provenance_sources: Union[bool, str, Dict[str, str]] = None,\n    age_ranges: List[int] = None,\n    **kwargs,\n):\n\"\"\"Script to be used by [``compute()``][edsteva.probes.base.BaseProbe.compute]\n\n    Parameters\n    ----------\n    data : Data\n        Instantiated [``HiveData``][edsteva.io.hive.HiveData], [``PostgresData``][edsteva.io.postgres.PostgresData] or [``LocalData``][edsteva.io.files.LocalData]\n    care_site_relationship : pd.DataFrame\n        DataFrame computed in the [``compute()``][edsteva.probes.base.BaseProbe.compute] that gives the hierarchy of the care site structure.\n    start_date : datetime, optional\n        **EXAMPLE**: `\"2019-05-01\"`\n    end_date : datetime, optional\n        **EXAMPLE**: `\"2021-07-01\"`\n    extra_data : Data, optional\n        Instantiated [``HiveData``][edsteva.io.hive.HiveData], [``PostgresData``][edsteva.io.postgres.PostgresData] or [``LocalData``][edsteva.io.files.LocalData]. This is not OMOP-standardized data but data needed to associate note with UF and Pole. If not provided, it will only compute the predictor for hospitals.\n    diag_types: Union[bool, str, Dict[str, str]], optional\n        **EXAMPLE**: `{\"All\": \".*\"}` or `{\"All\": \".*\", \"DP\\DR\": \"DP|DR\"}` or `\"DP\"`\n    condition_types: Union[bool, str, Dict[str, str]], optional\n        **EXAMPLE**: `{\"All\": \".*\"}` or `{\"All\": \".*\", \"Pulmonary_embolism\": \"I26\"}`\n    source_systems: Union[bool, List[str]], optional\n        **EXAMPLE**: `[\"AREM\", \"ORBIS\"]`\n    care_site_ids : List[int], optional\n        **EXAMPLE**: `[8312056386, 8312027648]`\n    care_site_short_names : List[str], optional\n        **EXAMPLE**: `[\"HOSPITAL 1\", \"HOSPITAL 2\"]`\n    care_site_levels : Union[bool, str, List[str]], optional\n        **EXAMPLE**: `[\"Hospital\", \"Pole\", \"UF\", \"UC\", \"UH\"]`\n    care_sites_sets: Union[str, Dict[str, str]], optional\n        **EXAMPLE**: `{\"All AP-HP\": \".*\"}` or `{\"All AP-HP\": \".*\", \"Pediatrics\": r\"debre|trousseau|necker\"}`\n    care_site_specialties: Union[bool, List[str]], optional\n        **EXAMPLE**: `[\"CARDIOLOGIE\", \"CHIRURGIE\"]`\n    specialties_sets: Union[str, Dict[str, str]], optional\n        **EXAMPLE**: `{\"All\": \".*\"}` or `{\"All\": \".*\", \"ICU\": r\"REA\\s|USI\\s|SC\\s\"}`\n    stay_types: Union[bool, str, Dict[str, str]], optional\n        **EXAMPLE**: `{\"All\": \".*\"}` or `{\"All\": \".*\", \"Urg_and_consult\": \"urgences|consultation\"}` or `\"hospitalis\u00e9s`\n    stay_sources: Union[bool, str, Dict[str, str]], optional\n        **EXAMPLE**: `{\"All\": \".*\"}, {\"MCO\" : \"MCO\", \"MCO_PSY_SSR\" : \"MCO|Psychiatrie|SSR\"}`\n    length_of_stays: List[float], optional\n        **EXAMPLE**: `[1, 30]`\n    provenance_sources: Union[bool, str, Dict[str, str]], optional\n        **EXAMPLE**: `{\"All\": \".*\"}, {\"urgence\" : \"service d'urgence\"}`\n    age_ranges: List[int], optional\n        **EXAMPLE**: `[18, 64]`\n    \"\"\"\n    if not diag_types and \"diag_type\" in self._index:\n        self._index.remove(\"diag_type\")\n    if not condition_types and \"condition_type\" in self._index:\n        self._index.remove(\"condition_type\")\n    if not source_systems and \"source_system\" in self._index:\n        self._index.remove(\"source_system\")\n    if not care_site_levels and \"care_site_level\" in self._index:\n        self._index.remove(\"care_site_level\")\n    if not care_sites_sets and \"care_sites_set\" in self._index:\n        self._index.remove(\"care_sites_set\")\n    if not care_site_specialties and \"care_site_specialty\" in self._index:\n        self._index.remove(\"care_site_specialty\")\n    if not specialties_sets and \"specialties_set\" in self._index:\n        self._index.remove(\"specialties_set\")\n    if not stay_types and \"stay_type\" in self._index:\n        self._index.remove(\"stay_type\")\n    if not stay_sources and \"stay_source\" in self._index:\n        self._index.remove(\"stay_source\")\n    if not length_of_stays and \"length_of_stay\" in self._index:\n        self._index.remove(\"length_of_stay\")\n    if not provenance_sources and \"provenance_source\" in self._index:\n        self._index.remove(\"provenance_source\")\n    if not age_ranges and \"age_range\" in self._index:\n        self._index.remove(\"age_range\")\n    return completeness_predictors.get(self._completeness_predictor)(\n        self,\n        data=data,\n        care_site_relationship=care_site_relationship,\n        start_date=start_date,\n        end_date=end_date,\n        care_site_levels=care_site_levels,\n        stay_types=stay_types,\n        care_site_ids=care_site_ids,\n        extra_data=extra_data,\n        care_site_short_names=care_site_short_names,\n        care_site_specialties=care_site_specialties,\n        care_sites_sets=care_sites_sets,\n        specialties_sets=specialties_sets,\n        diag_types=diag_types,\n        provenance_sources=provenance_sources,\n        length_of_stays=length_of_stays,\n        condition_types=condition_types,\n        source_systems=source_systems,\n        stay_sources=stay_sources,\n        age_ranges=age_ranges,\n        **kwargs,\n    )\n</code></pre>"},{"location":"reference/probes/condition/completeness_predictors/","title":"<code>edsteva.probes.condition.completeness_predictors</code>","text":""},{"location":"reference/probes/condition/completeness_predictors/per_condition/","title":"<code>edsteva.probes.condition.completeness_predictors.per_condition</code>","text":""},{"location":"reference/probes/condition/completeness_predictors/per_condition/#edsteva.probes.condition.completeness_predictors.per_condition.compute_completeness_predictor_per_condition","title":"compute_completeness_predictor_per_condition","text":"<pre><code>compute_completeness_predictor_per_condition(\n    self,\n    data: Data,\n    care_site_relationship: pd.DataFrame,\n    start_date: datetime,\n    end_date: datetime,\n    care_site_levels: Union[bool, str, List[str]],\n    stay_types: Union[bool, str, Dict[str, str]],\n    care_site_ids: List[int],\n    extra_data: Data,\n    care_site_short_names: List[str],\n    care_site_specialties: Union[bool, List[str]],\n    care_sites_sets: Union[str, Dict[str, str]],\n    specialties_sets: Union[str, Dict[str, str]],\n    diag_types: Union[bool, str, Dict[str, str]],\n    condition_types: Union[bool, str, Dict[str, str]],\n    source_systems: Union[bool, List[str]],\n    length_of_stays: List[float],\n    age_ranges: List[int],\n    provenance_sources: Union[bool, str, Dict[str, str]],\n    stay_sources: Union[bool, str, Dict[str, str]],\n    **kwargs\n)\n</code></pre> <p>Script to be used by <code>compute()</code></p> <p>The <code>per_condition</code> algorithm computes \\(c_(t)\\) the availability of claim data as follow:</p> \\[ c(t) = \\frac{n_{condition}(t)}{n_{max}} \\] <p>Where \\(n_{condition}(t)\\) is the number of claim codes (e.g. ICD-10) recorded, \\(t\\) is the month and \\(n_{max} = \\max_{t}(n_{condition}(t))\\).</p> Source code in <code>edsteva/probes/condition/completeness_predictors/per_condition.py</code> <pre><code>def compute_completeness_predictor_per_condition(\n    self,\n    data: Data,\n    care_site_relationship: pd.DataFrame,\n    start_date: datetime,\n    end_date: datetime,\n    care_site_levels: Union[bool, str, List[str]],\n    stay_types: Union[bool, str, Dict[str, str]],\n    care_site_ids: List[int],\n    extra_data: Data,\n    care_site_short_names: List[str],\n    care_site_specialties: Union[bool, List[str]],\n    care_sites_sets: Union[str, Dict[str, str]],\n    specialties_sets: Union[str, Dict[str, str]],\n    diag_types: Union[bool, str, Dict[str, str]],\n    condition_types: Union[bool, str, Dict[str, str]],\n    source_systems: Union[bool, List[str]],\n    length_of_stays: List[float],\n    age_ranges: List[int],\n    provenance_sources: Union[bool, str, Dict[str, str]],\n    stay_sources: Union[bool, str, Dict[str, str]],\n    **kwargs\n):\nr\"\"\"Script to be used by [``compute()``][edsteva.probes.base.BaseProbe.compute]\n\n    The ``per_condition`` algorithm computes $c_(t)$ the availability of claim data as follow:\n\n    $$\n    c(t) = \\frac{n_{condition}(t)}{n_{max}}\n    $$\n\n    Where $n_{condition}(t)$ is the number of claim codes (e.g. ICD-10) recorded, $t$ is the month and $n_{max} = \\max_{t}(n_{condition}(t))$.\n    \"\"\"\n\n    self._metrics = [\"c\", \"n_condition\"]\n    check_tables(data=data, required_tables=[\"condition_occurrence\"])\n\n    person = prepare_person(data)\n\n    visit_occurrence = prepare_visit_occurrence(\n        data=data,\n        stay_types=stay_types,\n        length_of_stays=length_of_stays,\n        provenance_sources=provenance_sources,\n        stay_sources=stay_sources,\n        person=person,\n        age_ranges=age_ranges,\n    ).drop(columns=\"date\")\n\n    condition_occurrence = prepare_condition_occurrence(\n        data=data,\n        extra_data=extra_data,\n        visit_occurrence=visit_occurrence,\n        source_systems=source_systems,\n        diag_types=diag_types,\n        condition_types=condition_types,\n        start_date=start_date,\n        end_date=end_date,\n    )\n\n    care_site = prepare_care_site(\n        data=data,\n        care_site_ids=care_site_ids,\n        care_site_short_names=care_site_short_names,\n        care_site_relationship=care_site_relationship,\n        care_site_specialties=care_site_specialties,\n        care_sites_sets=care_sites_sets,\n        specialties_sets=specialties_sets,\n    )\n\n    hospital_visit = get_hospital_condition(\n        condition_occurrence,\n        visit_occurrence,\n        care_site,\n    )\n    hospital_name = CARE_SITE_LEVEL_NAMES[\"Hospital\"]\n    condition_predictor_by_level = {hospital_name: hospital_visit}\n\n    # UF selection\n    if not hospital_only(care_site_levels=care_site_levels):\n        visit_detail = prepare_visit_detail(\n            data=data,\n            start_date=start_date,\n            end_date=end_date,\n        )\n\n        uf_condition = get_uf_condition(\n            condition_occurrence=condition_occurrence,\n            visit_occurrence=visit_occurrence,\n            visit_detail=visit_detail,\n            care_site=care_site,\n        )\n        uf_name = CARE_SITE_LEVEL_NAMES[\"UF\"]\n        condition_predictor_by_level[uf_name] = uf_condition\n\n        pole_condition = get_pole_condition(\n            uf_condition, care_site, care_site_relationship\n        )\n        pole_name = CARE_SITE_LEVEL_NAMES[\"Pole\"]\n        condition_predictor_by_level[pole_name] = pole_condition\n\n    condition_predictor = concatenate_predictor_by_level(\n        predictor_by_level=condition_predictor_by_level,\n        care_site_levels=care_site_levels,\n    )\n\n    return compute_completeness(self, condition_predictor)\n</code></pre>"},{"location":"reference/probes/condition/completeness_predictors/per_visit/","title":"<code>edsteva.probes.condition.completeness_predictors.per_visit</code>","text":""},{"location":"reference/probes/condition/completeness_predictors/per_visit/#edsteva.probes.condition.completeness_predictors.per_visit.compute_completeness_predictor_per_visit","title":"compute_completeness_predictor_per_visit","text":"<pre><code>compute_completeness_predictor_per_visit(\n    self,\n    data: Data,\n    care_site_relationship: pd.DataFrame,\n    start_date: datetime,\n    end_date: datetime,\n    care_site_levels: Union[bool, str, List[str]],\n    stay_types: Union[bool, str, Dict[str, str]],\n    care_site_ids: List[int],\n    extra_data: Data,\n    care_site_short_names: List[str],\n    care_site_specialties: Union[bool, List[str]],\n    care_sites_sets: Union[str, Dict[str, str]],\n    specialties_sets: Union[str, Dict[str, str]],\n    diag_types: Union[bool, str, Dict[str, str]],\n    condition_types: Union[bool, str, Dict[str, str]],\n    source_systems: Union[bool, List[str]],\n    length_of_stays: List[float],\n    age_ranges: List[int],\n    provenance_sources: Union[bool, str, Dict[str, str]],\n    stay_sources: Union[bool, str, Dict[str, str]],\n    **kwargs\n)\n</code></pre> <p>Script to be used by <code>compute()</code></p> <p>The <code>per_visit</code> algorithm computes \\(c_(t)\\) the availability of claim data linked to patients' administrative stays:</p> \\[ c(t) = \\frac{n_{with\\,condition}(t)}{n_{visit}(t)} \\] <p>Where \\(n_{visit}(t)\\) is the number of administrative stays, \\(n_{with\\,condition}\\) the number of stays having at least one claim code (e.g. ICD-10) recorded and \\(t\\) is the month.</p> Source code in <code>edsteva/probes/condition/completeness_predictors/per_visit.py</code> <pre><code>def compute_completeness_predictor_per_visit(\n    self,\n    data: Data,\n    care_site_relationship: pd.DataFrame,\n    start_date: datetime,\n    end_date: datetime,\n    care_site_levels: Union[bool, str, List[str]],\n    stay_types: Union[bool, str, Dict[str, str]],\n    care_site_ids: List[int],\n    extra_data: Data,\n    care_site_short_names: List[str],\n    care_site_specialties: Union[bool, List[str]],\n    care_sites_sets: Union[str, Dict[str, str]],\n    specialties_sets: Union[str, Dict[str, str]],\n    diag_types: Union[bool, str, Dict[str, str]],\n    condition_types: Union[bool, str, Dict[str, str]],\n    source_systems: Union[bool, List[str]],\n    length_of_stays: List[float],\n    age_ranges: List[int],\n    provenance_sources: Union[bool, str, Dict[str, str]],\n    stay_sources: Union[bool, str, Dict[str, str]],\n    **kwargs\n):\nr\"\"\"Script to be used by [``compute()``][edsteva.probes.base.BaseProbe.compute]\n\n    The ``per_visit`` algorithm computes $c_(t)$ the availability of claim data linked to patients' administrative stays:\n\n    $$\n    c(t) = \\frac{n_{with\\,condition}(t)}{n_{visit}(t)}\n    $$\n\n    Where $n_{visit}(t)$ is the number of administrative stays, $n_{with\\,condition}$ the number of stays having at least one claim code (e.g. ICD-10) recorded and $t$ is the month.\n    \"\"\"\n\n    self._metrics = [\"c\", \"n_visit\", \"n_visit_with_condition\"]\n    check_tables(data=data, required_tables=[\"condition_occurrence\"])\n\n    person = prepare_person(data)\n\n    visit_occurrence = prepare_visit_occurrence(\n        data=data,\n        start_date=start_date,\n        end_date=end_date,\n        stay_types=stay_types,\n        length_of_stays=length_of_stays,\n        provenance_sources=provenance_sources,\n        stay_sources=stay_sources,\n        person=person,\n        age_ranges=age_ranges,\n    )\n\n    condition_occurrence = prepare_condition_occurrence(\n        data=data,\n        extra_data=extra_data,\n        visit_occurrence=visit_occurrence,\n        source_systems=source_systems,\n        diag_types=diag_types,\n        condition_types=condition_types,\n    ).drop(columns=[\"condition_occurrence_id\", \"date\"])\n\n    care_site = prepare_care_site(\n        data=data,\n        care_site_ids=care_site_ids,\n        care_site_short_names=care_site_short_names,\n        care_site_relationship=care_site_relationship,\n        care_site_specialties=care_site_specialties,\n        care_sites_sets=care_sites_sets,\n        specialties_sets=specialties_sets,\n    )\n\n    hospital_visit = get_hospital_visit(\n        condition_occurrence,\n        visit_occurrence,\n        care_site,\n    )\n    hospital_name = CARE_SITE_LEVEL_NAMES[\"Hospital\"]\n    condition_predictor_by_level = {hospital_name: hospital_visit}\n\n    # UF selection\n    if not hospital_only(care_site_levels=care_site_levels):\n        visit_detail = prepare_visit_detail(data, start_date, end_date)\n\n        uf_visit = get_uf_visit(\n            condition_occurrence=condition_occurrence,\n            visit_occurrence=visit_occurrence,\n            visit_detail=visit_detail,\n            care_site=care_site,\n        )\n        uf_name = CARE_SITE_LEVEL_NAMES[\"UF\"]\n        condition_predictor_by_level[uf_name] = uf_visit\n\n        pole_visit = get_pole_visit(\n            uf_visit=uf_visit,\n            care_site=care_site,\n            care_site_relationship=care_site_relationship,\n        )\n        pole_name = CARE_SITE_LEVEL_NAMES[\"Pole\"]\n        condition_predictor_by_level[pole_name] = pole_visit\n\n    condition_predictor = concatenate_predictor_by_level(\n        predictor_by_level=condition_predictor_by_level,\n        care_site_levels=care_site_levels,\n    )\n\n    return compute_completeness(self, condition_predictor)\n</code></pre>"},{"location":"reference/probes/condition/viz_configs/","title":"<code>edsteva.probes.condition.viz_configs</code>","text":""},{"location":"reference/probes/condition/viz_configs/n_condition/","title":"<code>edsteva.probes.condition.viz_configs.n_condition</code>","text":""},{"location":"reference/probes/condition/viz_configs/n_condition/defaults/","title":"<code>edsteva.probes.condition.viz_configs.n_condition.defaults</code>","text":""},{"location":"reference/probes/condition/viz_configs/n_condition/estimates_densities_plot/","title":"<code>edsteva.probes.condition.viz_configs.n_condition.estimates_densities_plot</code>","text":""},{"location":"reference/probes/condition/viz_configs/n_condition/normalized_probe_dashboard/","title":"<code>edsteva.probes.condition.viz_configs.n_condition.normalized_probe_dashboard</code>","text":""},{"location":"reference/probes/condition/viz_configs/n_condition/normalized_probe_plot/","title":"<code>edsteva.probes.condition.viz_configs.n_condition.normalized_probe_plot</code>","text":""},{"location":"reference/probes/condition/viz_configs/n_condition/probe_dashboard/","title":"<code>edsteva.probes.condition.viz_configs.n_condition.probe_dashboard</code>","text":""},{"location":"reference/probes/condition/viz_configs/n_condition/probe_plot/","title":"<code>edsteva.probes.condition.viz_configs.n_condition.probe_plot</code>","text":""},{"location":"reference/probes/condition/viz_configs/per_condition/","title":"<code>edsteva.probes.condition.viz_configs.per_condition</code>","text":""},{"location":"reference/probes/condition/viz_configs/per_condition/defaults/","title":"<code>edsteva.probes.condition.viz_configs.per_condition.defaults</code>","text":""},{"location":"reference/probes/condition/viz_configs/per_condition/estimates_densities_plot/","title":"<code>edsteva.probes.condition.viz_configs.per_condition.estimates_densities_plot</code>","text":""},{"location":"reference/probes/condition/viz_configs/per_condition/normalized_probe_dashboard/","title":"<code>edsteva.probes.condition.viz_configs.per_condition.normalized_probe_dashboard</code>","text":""},{"location":"reference/probes/condition/viz_configs/per_condition/normalized_probe_plot/","title":"<code>edsteva.probes.condition.viz_configs.per_condition.normalized_probe_plot</code>","text":""},{"location":"reference/probes/condition/viz_configs/per_condition/probe_dashboard/","title":"<code>edsteva.probes.condition.viz_configs.per_condition.probe_dashboard</code>","text":""},{"location":"reference/probes/condition/viz_configs/per_condition/probe_plot/","title":"<code>edsteva.probes.condition.viz_configs.per_condition.probe_plot</code>","text":""},{"location":"reference/probes/condition/viz_configs/per_visit/","title":"<code>edsteva.probes.condition.viz_configs.per_visit</code>","text":""},{"location":"reference/probes/condition/viz_configs/per_visit/defaults/","title":"<code>edsteva.probes.condition.viz_configs.per_visit.defaults</code>","text":""},{"location":"reference/probes/condition/viz_configs/per_visit/estimates_densities_plot/","title":"<code>edsteva.probes.condition.viz_configs.per_visit.estimates_densities_plot</code>","text":""},{"location":"reference/probes/condition/viz_configs/per_visit/normalized_probe_dashboard/","title":"<code>edsteva.probes.condition.viz_configs.per_visit.normalized_probe_dashboard</code>","text":""},{"location":"reference/probes/condition/viz_configs/per_visit/normalized_probe_plot/","title":"<code>edsteva.probes.condition.viz_configs.per_visit.normalized_probe_plot</code>","text":""},{"location":"reference/probes/condition/viz_configs/per_visit/probe_dashboard/","title":"<code>edsteva.probes.condition.viz_configs.per_visit.probe_dashboard</code>","text":""},{"location":"reference/probes/condition/viz_configs/per_visit/probe_plot/","title":"<code>edsteva.probes.condition.viz_configs.per_visit.probe_plot</code>","text":""},{"location":"reference/probes/note/","title":"<code>edsteva.probes.note</code>","text":""},{"location":"reference/probes/note/note/","title":"<code>edsteva.probes.note.note</code>","text":""},{"location":"reference/probes/note/note/#edsteva.probes.note.note.NoteProbe","title":"NoteProbe","text":"<p>         Bases: <code>BaseProbe</code></p> <p>The <code>NoteProbe</code> computes \\(c(t)\\) the availability of clinical documents</p> PARAMETER DESCRIPTION <code>completeness_predictor</code> <p>Algorithm used to compute the completeness predictor</p> <p>EXAMPLE: <code>\"per_visit_default\"</code></p> <p> TYPE: <code>str</code> DEFAULT: <code>'per_visit_default'</code> </p> ATTRIBUTE DESCRIPTION <code>_completeness_predictor</code> <p>Algorithm used to compute the completeness predictor</p> <p>VALUE: <code>\"per_visit_default\"</code></p> <p> TYPE: <code>str</code> </p> <code>_index</code> <p>Variable from which data is grouped</p> <p>VALUE: [\"care_site_level\", \"stay_type\", \"length_of_stay\", \"note_type\", \"care_site_id\", \"care_site_specialty\", \"specialties_set\"]``</p> <p> TYPE: <code>List[str]</code> </p> <code>_viz_config</code> <p>Dictionary of configuration for visualization purpose.</p> <p>VALUE: <code>{}</code></p> <p> TYPE: <code>List[str]</code> </p> Source code in <code>edsteva/probes/note/note.py</code> <pre><code>class NoteProbe(BaseProbe):\nr\"\"\"\n    The ``NoteProbe`` computes $c(t)$ the availability of clinical documents\n\n    Parameters\n    ----------\n    completeness_predictor: str\n        Algorithm used to compute the completeness predictor\n\n        **EXAMPLE**: ``\"per_visit_default\"``\n\n    Attributes\n    ----------\n    _completeness_predictor: str\n        Algorithm used to compute the completeness predictor\n\n        **VALUE**: ``\"per_visit_default\"``\n    _index: List[str]\n        Variable from which data is grouped\n\n        **VALUE**: [\"care_site_level\", \"stay_type\", \"length_of_stay\", \"note_type\", \"care_site_id\", \"care_site_specialty\", \"specialties_set\"]``\n    _viz_config: List[str]\n        Dictionary of configuration for visualization purpose.\n\n        **VALUE**: ``{}``\n    \"\"\"\n\n    def __init__(\n        self,\n        completeness_predictor: str = \"per_visit_default\",\n    ):\n        self._index = [\n            \"note_type\",\n            \"care_site_id\",\n            \"care_site_level\",\n            \"care_sites_set\",\n            \"care_site_specialty\",\n            \"specialties_set\",\n            \"stay_type\",\n            \"stay_source\",\n            \"length_of_stay\",\n            \"provenance_source\",\n            \"age_range\",\n        ]\n        super().__init__(\n            completeness_predictor=completeness_predictor,\n            index=self._index,\n        )\n\n    def compute_process(\n        self,\n        data: Data,\n        care_site_relationship: pd.DataFrame,\n        start_date: datetime,\n        end_date: datetime,\n        note_types: Union[bool, str, Dict[str, str]] = {\n            \"Urgence\": \"urge\",\n            \"Ordonnance\": \"ordo\",\n            \"CRH\": \"crh\",\n        },\n        extra_data: Data = None,\n        care_site_ids: List[int] = None,\n        care_site_short_names: List[str] = None,\n        care_site_levels: Union[bool, str, List[str]] = True,\n        care_sites_sets: Union[str, Dict[str, str]] = None,\n        care_site_specialties: Union[bool, List[str]] = None,\n        specialties_sets: Union[str, Dict[str, str]] = None,\n        stay_types: Union[bool, str, Dict[str, str]] = True,\n        stay_sources: Union[bool, str, Dict[str, str]] = None,\n        length_of_stays: List[float] = None,\n        provenance_sources: Union[bool, str, Dict[str, str]] = None,\n        age_ranges: List[int] = None,\n        **kwargs,\n    ):\n\"\"\"Script to be used by [``compute()``][edsteva.probes.base.BaseProbe.compute]\n\n        Parameters\n        ----------\n        data : Data\n            Instantiated [``HiveData``][edsteva.io.hive.HiveData], [``PostgresData``][edsteva.io.postgres.PostgresData] or [``LocalData``][edsteva.io.files.LocalData]\n        care_site_relationship : pd.DataFrame\n            DataFrame computed in the [``compute()``][edsteva.probes.base.BaseProbe.compute] that gives the hierarchy of the care site structure.\n        start_date : datetime, optional\n            **EXAMPLE**: `\"2019-05-01\"`\n        end_date : datetime, optional\n            **EXAMPLE**: `\"2021-07-01\"`\n        note_types: Union[bool, str, Dict[str, str]], optional\n            **EXAMPLE**: `{\"All\": \".*\"}` or `{\"CRH\": \"crh\", \"Urgence\": \"urge\"}`\n        extra_data : Data, optional\n            Instantiated [``HiveData``][edsteva.io.hive.HiveData], [``PostgresData``][edsteva.io.postgres.PostgresData] or [``LocalData``][edsteva.io.files.LocalData]. This is not OMOP-standardized data but data needed to associate note with UF and Pole. If not provided, it will only compute the predictor for hospitals.\n        care_site_ids : List[int], optional\n            **EXAMPLE**: `[8312056386, 8312027648]`\n        care_site_short_names : List[str], optional\n            **EXAMPLE**: `[\"HOSPITAL 1\", \"HOSPITAL 2\"]`\n        care_site_levels : Union[bool, str, List[str]], optional\n            **EXAMPLE**: `[\"Hospital\", \"Pole\", \"UF\", \"UC\", \"UH\"]`\n        care_sites_sets: Union[str, Dict[str, str]], optional\n            **EXAMPLE**: `{\"All AP-HP\": \".*\"}` or `{\"All AP-HP\": \".*\", \"Pediatrics\": r\"debre|trousseau|necker\"}`\n        care_site_specialties: Union[bool, List[str]], optional\n            **EXAMPLE**: `[\"CARDIOLOGIE\", \"CHIRURGIE\"]`\n        specialties_sets: Union[str, Dict[str, str]], optional\n            **EXAMPLE**: `{\"All\": \".*\"}` or `{\"All\": \".*\", \"ICU\": r\"REA\\s|USI\\s|SC\\s\"}`\n        stay_types: Union[bool, str, Dict[str, str]], optional\n            **EXAMPLE**: `{\"All\": \".*\"}` or `{\"All\": \".*\", \"Urg_and_consult\": \"urgences|consultation\"}` or `\"hospitalis\u00e9s`\n        stay_sources: Union[bool, str, Dict[str, str]], optional\n            **EXAMPLE**: `{\"All\": \".*\"}, {\"MCO\" : \"MCO\", \"MCO_PSY_SSR\" : \"MCO|Psychiatrie|SSR\"}`\n        length_of_stays: List[float], optional\n            **EXAMPLE**: `[1, 30]`\n        provenance_sources: Union[bool, str, Dict[str, str]], optional\n            **EXAMPLE**: `{\"All\": \".*\"}, {\"urgence\" : \"service d'urgence\"}`\n        age_ranges: List[int], optional\n            **EXAMPLE**: `[18, 64]`\n        \"\"\"\n        if not note_types and \"note_type\" in self._index:\n            self._index.remove(\"note_type\")\n        if not care_site_levels and \"care_site_level\" in self._index:\n            self._index.remove(\"care_site_level\")\n        if not care_sites_sets and \"care_sites_set\" in self._index:\n            self._index.remove(\"care_sites_set\")\n        if not care_site_specialties and \"care_site_specialty\" in self._index:\n            self._index.remove(\"care_site_specialty\")\n        if not specialties_sets and \"specialties_set\" in self._index:\n            self._index.remove(\"specialties_set\")\n        if not stay_types and \"stay_type\" in self._index:\n            self._index.remove(\"stay_type\")\n        if not stay_sources and \"stay_source\" in self._index:\n            self._index.remove(\"stay_source\")\n        if not length_of_stays and \"length_of_stay\" in self._index:\n            self._index.remove(\"length_of_stay\")\n        if not provenance_sources and \"provenance_source\" in self._index:\n            self._index.remove(\"provenance_source\")\n        if not age_ranges and \"age_range\" in self._index:\n            self._index.remove(\"age_range\")\n        return completeness_predictors.get(self._completeness_predictor)(\n            self,\n            data=data,\n            care_site_relationship=care_site_relationship,\n            start_date=start_date,\n            end_date=end_date,\n            care_site_levels=care_site_levels,\n            stay_types=stay_types,\n            care_site_ids=care_site_ids,\n            extra_data=extra_data,\n            care_site_short_names=care_site_short_names,\n            care_site_specialties=care_site_specialties,\n            care_sites_sets=care_sites_sets,\n            specialties_sets=specialties_sets,\n            note_types=note_types,\n            length_of_stays=length_of_stays,\n            provenance_sources=provenance_sources,\n            stay_sources=stay_sources,\n            age_ranges=age_ranges,\n            **kwargs,\n        )\n\n    def get_viz_config(self, viz_type: str, **kwargs):\n        if viz_type in viz_configs.keys():\n            _viz_config = self._viz_config.get(viz_type)\n            if _viz_config is None:\n                _viz_config = self._completeness_predictor\n        else:\n            raise ValueError(f\"edsteva has no {viz_type} registry !\")\n        return viz_configs[viz_type].get(_viz_config)(self, **kwargs)\n\n    def available_completeness_predictors(self):\n        return list(completeness_predictors.get_all().keys())\n</code></pre>"},{"location":"reference/probes/note/note/#edsteva.probes.note.note.NoteProbe.compute_process","title":"compute_process","text":"<pre><code>compute_process(\n    data: Data,\n    care_site_relationship: pd.DataFrame,\n    start_date: datetime,\n    end_date: datetime,\n    note_types: Union[bool, str, Dict[str, str]] = {\n        \"Urgence\": \"urge\",\n        \"Ordonnance\": \"ordo\",\n        \"CRH\": \"crh\",\n    },\n    extra_data: Data = None,\n    care_site_ids: List[int] = None,\n    care_site_short_names: List[str] = None,\n    care_site_levels: Union[bool, str, List[str]] = True,\n    care_sites_sets: Union[str, Dict[str, str]] = None,\n    care_site_specialties: Union[bool, List[str]] = None,\n    specialties_sets: Union[str, Dict[str, str]] = None,\n    stay_types: Union[bool, str, Dict[str, str]] = True,\n    stay_sources: Union[bool, str, Dict[str, str]] = None,\n    length_of_stays: List[float] = None,\n    provenance_sources: Union[\n        bool, str, Dict[str, str]\n    ] = None,\n    age_ranges: List[int] = None,\n    **kwargs\n)\n</code></pre> <p>Script to be used by <code>compute()</code></p> PARAMETER DESCRIPTION <code>data</code> <p>Instantiated <code>HiveData</code>, <code>PostgresData</code> or <code>LocalData</code></p> <p> TYPE: <code>Data</code> </p> <code>care_site_relationship</code> <p>DataFrame computed in the <code>compute()</code> that gives the hierarchy of the care site structure.</p> <p> TYPE: <code>pd.DataFrame</code> </p> <code>start_date</code> <p>EXAMPLE: <code>\"2019-05-01\"</code></p> <p> TYPE: <code>datetime</code> </p> <code>end_date</code> <p>EXAMPLE: <code>\"2021-07-01\"</code></p> <p> TYPE: <code>datetime</code> </p> <code>note_types</code> <p>EXAMPLE: <code>{\"All\": \".*\"}</code> or <code>{\"CRH\": \"crh\", \"Urgence\": \"urge\"}</code></p> <p> TYPE: <code>Union[bool, str, Dict[str, str]]</code> DEFAULT: <code>{'Urgence': 'urge', 'Ordonnance': 'ordo', 'CRH': 'crh'}</code> </p> <code>extra_data</code> <p>Instantiated <code>HiveData</code>, <code>PostgresData</code> or <code>LocalData</code>. This is not OMOP-standardized data but data needed to associate note with UF and Pole. If not provided, it will only compute the predictor for hospitals.</p> <p> TYPE: <code>Data</code> DEFAULT: <code>None</code> </p> <code>care_site_ids</code> <p>EXAMPLE: <code>[8312056386, 8312027648]</code></p> <p> TYPE: <code>List[int]</code> DEFAULT: <code>None</code> </p> <code>care_site_short_names</code> <p>EXAMPLE: <code>[\"HOSPITAL 1\", \"HOSPITAL 2\"]</code></p> <p> TYPE: <code>List[str]</code> DEFAULT: <code>None</code> </p> <code>care_site_levels</code> <p>EXAMPLE: <code>[\"Hospital\", \"Pole\", \"UF\", \"UC\", \"UH\"]</code></p> <p> TYPE: <code>Union[bool, str, List[str]]</code> DEFAULT: <code>True</code> </p> <code>care_sites_sets</code> <p>EXAMPLE: <code>{\"All AP-HP\": \".*\"}</code> or <code>{\"All AP-HP\": \".*\", \"Pediatrics\": r\"debre|trousseau|necker\"}</code></p> <p> TYPE: <code>Union[str, Dict[str, str]]</code> DEFAULT: <code>None</code> </p> <code>care_site_specialties</code> <p>EXAMPLE: <code>[\"CARDIOLOGIE\", \"CHIRURGIE\"]</code></p> <p> TYPE: <code>Union[bool, List[str]]</code> DEFAULT: <code>None</code> </p> <code>specialties_sets</code> <p>EXAMPLE: <code>{\"All\": \".*\"}</code> or <code>{\"All\": \".*\", \"ICU\": r\"REA\\s|USI\\s|SC\\s\"}</code></p> <p> TYPE: <code>Union[str, Dict[str, str]]</code> DEFAULT: <code>None</code> </p> <code>stay_types</code> <p>EXAMPLE: <code>{\"All\": \".*\"}</code> or <code>{\"All\": \".*\", \"Urg_and_consult\": \"urgences|consultation\"}</code> or <code>\"hospitalis\u00e9s</code></p> <p> TYPE: <code>Union[bool, str, Dict[str, str]]</code> DEFAULT: <code>True</code> </p> <code>stay_sources</code> <p>EXAMPLE: <code>{\"All\": \".*\"}, {\"MCO\" : \"MCO\", \"MCO_PSY_SSR\" : \"MCO|Psychiatrie|SSR\"}</code></p> <p> TYPE: <code>Union[bool, str, Dict[str, str]]</code> DEFAULT: <code>None</code> </p> <code>length_of_stays</code> <p>EXAMPLE: <code>[1, 30]</code></p> <p> TYPE: <code>List[float]</code> DEFAULT: <code>None</code> </p> <code>provenance_sources</code> <p>EXAMPLE: <code>{\"All\": \".*\"}, {\"urgence\" : \"service d'urgence\"}</code></p> <p> TYPE: <code>Union[bool, str, Dict[str, str]]</code> DEFAULT: <code>None</code> </p> <code>age_ranges</code> <p>EXAMPLE: <code>[18, 64]</code></p> <p> TYPE: <code>List[int]</code> DEFAULT: <code>None</code> </p> Source code in <code>edsteva/probes/note/note.py</code> <pre><code>def compute_process(\n    self,\n    data: Data,\n    care_site_relationship: pd.DataFrame,\n    start_date: datetime,\n    end_date: datetime,\n    note_types: Union[bool, str, Dict[str, str]] = {\n        \"Urgence\": \"urge\",\n        \"Ordonnance\": \"ordo\",\n        \"CRH\": \"crh\",\n    },\n    extra_data: Data = None,\n    care_site_ids: List[int] = None,\n    care_site_short_names: List[str] = None,\n    care_site_levels: Union[bool, str, List[str]] = True,\n    care_sites_sets: Union[str, Dict[str, str]] = None,\n    care_site_specialties: Union[bool, List[str]] = None,\n    specialties_sets: Union[str, Dict[str, str]] = None,\n    stay_types: Union[bool, str, Dict[str, str]] = True,\n    stay_sources: Union[bool, str, Dict[str, str]] = None,\n    length_of_stays: List[float] = None,\n    provenance_sources: Union[bool, str, Dict[str, str]] = None,\n    age_ranges: List[int] = None,\n    **kwargs,\n):\n\"\"\"Script to be used by [``compute()``][edsteva.probes.base.BaseProbe.compute]\n\n    Parameters\n    ----------\n    data : Data\n        Instantiated [``HiveData``][edsteva.io.hive.HiveData], [``PostgresData``][edsteva.io.postgres.PostgresData] or [``LocalData``][edsteva.io.files.LocalData]\n    care_site_relationship : pd.DataFrame\n        DataFrame computed in the [``compute()``][edsteva.probes.base.BaseProbe.compute] that gives the hierarchy of the care site structure.\n    start_date : datetime, optional\n        **EXAMPLE**: `\"2019-05-01\"`\n    end_date : datetime, optional\n        **EXAMPLE**: `\"2021-07-01\"`\n    note_types: Union[bool, str, Dict[str, str]], optional\n        **EXAMPLE**: `{\"All\": \".*\"}` or `{\"CRH\": \"crh\", \"Urgence\": \"urge\"}`\n    extra_data : Data, optional\n        Instantiated [``HiveData``][edsteva.io.hive.HiveData], [``PostgresData``][edsteva.io.postgres.PostgresData] or [``LocalData``][edsteva.io.files.LocalData]. This is not OMOP-standardized data but data needed to associate note with UF and Pole. If not provided, it will only compute the predictor for hospitals.\n    care_site_ids : List[int], optional\n        **EXAMPLE**: `[8312056386, 8312027648]`\n    care_site_short_names : List[str], optional\n        **EXAMPLE**: `[\"HOSPITAL 1\", \"HOSPITAL 2\"]`\n    care_site_levels : Union[bool, str, List[str]], optional\n        **EXAMPLE**: `[\"Hospital\", \"Pole\", \"UF\", \"UC\", \"UH\"]`\n    care_sites_sets: Union[str, Dict[str, str]], optional\n        **EXAMPLE**: `{\"All AP-HP\": \".*\"}` or `{\"All AP-HP\": \".*\", \"Pediatrics\": r\"debre|trousseau|necker\"}`\n    care_site_specialties: Union[bool, List[str]], optional\n        **EXAMPLE**: `[\"CARDIOLOGIE\", \"CHIRURGIE\"]`\n    specialties_sets: Union[str, Dict[str, str]], optional\n        **EXAMPLE**: `{\"All\": \".*\"}` or `{\"All\": \".*\", \"ICU\": r\"REA\\s|USI\\s|SC\\s\"}`\n    stay_types: Union[bool, str, Dict[str, str]], optional\n        **EXAMPLE**: `{\"All\": \".*\"}` or `{\"All\": \".*\", \"Urg_and_consult\": \"urgences|consultation\"}` or `\"hospitalis\u00e9s`\n    stay_sources: Union[bool, str, Dict[str, str]], optional\n        **EXAMPLE**: `{\"All\": \".*\"}, {\"MCO\" : \"MCO\", \"MCO_PSY_SSR\" : \"MCO|Psychiatrie|SSR\"}`\n    length_of_stays: List[float], optional\n        **EXAMPLE**: `[1, 30]`\n    provenance_sources: Union[bool, str, Dict[str, str]], optional\n        **EXAMPLE**: `{\"All\": \".*\"}, {\"urgence\" : \"service d'urgence\"}`\n    age_ranges: List[int], optional\n        **EXAMPLE**: `[18, 64]`\n    \"\"\"\n    if not note_types and \"note_type\" in self._index:\n        self._index.remove(\"note_type\")\n    if not care_site_levels and \"care_site_level\" in self._index:\n        self._index.remove(\"care_site_level\")\n    if not care_sites_sets and \"care_sites_set\" in self._index:\n        self._index.remove(\"care_sites_set\")\n    if not care_site_specialties and \"care_site_specialty\" in self._index:\n        self._index.remove(\"care_site_specialty\")\n    if not specialties_sets and \"specialties_set\" in self._index:\n        self._index.remove(\"specialties_set\")\n    if not stay_types and \"stay_type\" in self._index:\n        self._index.remove(\"stay_type\")\n    if not stay_sources and \"stay_source\" in self._index:\n        self._index.remove(\"stay_source\")\n    if not length_of_stays and \"length_of_stay\" in self._index:\n        self._index.remove(\"length_of_stay\")\n    if not provenance_sources and \"provenance_source\" in self._index:\n        self._index.remove(\"provenance_source\")\n    if not age_ranges and \"age_range\" in self._index:\n        self._index.remove(\"age_range\")\n    return completeness_predictors.get(self._completeness_predictor)(\n        self,\n        data=data,\n        care_site_relationship=care_site_relationship,\n        start_date=start_date,\n        end_date=end_date,\n        care_site_levels=care_site_levels,\n        stay_types=stay_types,\n        care_site_ids=care_site_ids,\n        extra_data=extra_data,\n        care_site_short_names=care_site_short_names,\n        care_site_specialties=care_site_specialties,\n        care_sites_sets=care_sites_sets,\n        specialties_sets=specialties_sets,\n        note_types=note_types,\n        length_of_stays=length_of_stays,\n        provenance_sources=provenance_sources,\n        stay_sources=stay_sources,\n        age_ranges=age_ranges,\n        **kwargs,\n    )\n</code></pre>"},{"location":"reference/probes/note/completeness_predictors/","title":"<code>edsteva.probes.note.completeness_predictors</code>","text":""},{"location":"reference/probes/note/completeness_predictors/per_note/","title":"<code>edsteva.probes.note.completeness_predictors.per_note</code>","text":""},{"location":"reference/probes/note/completeness_predictors/per_note/#edsteva.probes.note.completeness_predictors.per_note.compute_completeness_predictor_per_note","title":"compute_completeness_predictor_per_note","text":"<pre><code>compute_completeness_predictor_per_note(\n    self,\n    data: Data,\n    care_site_relationship: pd.DataFrame,\n    start_date: datetime,\n    end_date: datetime,\n    care_site_levels: Union[bool, str, List[str]],\n    stay_types: Union[bool, str, Dict[str, str]],\n    care_site_ids: List[int],\n    care_site_short_names: List[str],\n    care_site_specialties: Union[bool, List[str]],\n    care_sites_sets: Union[str, Dict[str, str]],\n    specialties_sets: Union[str, Dict[str, str]],\n    extra_data: Data,\n    length_of_stays: List[float],\n    note_types: Union[bool, str, Dict[str, str]],\n    age_ranges: List[int],\n    provenance_sources: Union[bool, str, Dict[str, str]],\n    stay_sources: Union[bool, str, Dict[str, str]],\n    **kwargs\n)\n</code></pre> <p>Script to be used by <code>compute()</code></p> <p>The <code>per_note</code> algorithm computes \\(c_(t)\\) the availability of clinical documents as follow:</p> \\[ c(t) = \\frac{n_{note}(t)}{n_{max}} \\] <p>Where \\(n_{note}(t)\\) is the number of clinical documents, \\(t\\) is the month and \\(n_{max} = \\max_{t}(n_{note}(t))\\).</p> Source code in <code>edsteva/probes/note/completeness_predictors/per_note.py</code> <pre><code>def compute_completeness_predictor_per_note(\n    self,\n    data: Data,\n    care_site_relationship: pd.DataFrame,\n    start_date: datetime,\n    end_date: datetime,\n    care_site_levels: Union[bool, str, List[str]],\n    stay_types: Union[bool, str, Dict[str, str]],\n    care_site_ids: List[int],\n    care_site_short_names: List[str],\n    care_site_specialties: Union[bool, List[str]],\n    care_sites_sets: Union[str, Dict[str, str]],\n    specialties_sets: Union[str, Dict[str, str]],\n    extra_data: Data,\n    length_of_stays: List[float],\n    note_types: Union[bool, str, Dict[str, str]],\n    age_ranges: List[int],\n    provenance_sources: Union[bool, str, Dict[str, str]],\n    stay_sources: Union[bool, str, Dict[str, str]],\n    **kwargs\n):\nr\"\"\"Script to be used by [``compute()``][edsteva.probes.base.BaseProbe.compute]\n\n    The ``per_note`` algorithm computes $c_(t)$ the availability of clinical documents as follow:\n\n    $$\n    c(t) = \\frac{n_{note}(t)}{n_{max}}\n    $$\n\n    Where $n_{note}(t)$ is the number of clinical documents, $t$ is the month and $n_{max} = \\max_{t}(n_{note}(t))$.\n    \"\"\"\n    self._metrics = [\"c\", \"n_note\"]\n    check_tables(data=data, required_tables=[\"note\"])\n\n    note = prepare_note(\n        data=data,\n        start_date=start_date,\n        end_date=end_date,\n        note_types=note_types,\n    )\n\n    person = prepare_person(data)\n\n    visit_occurrence = prepare_visit_occurrence(\n        data=data,\n        stay_types=stay_types,\n        stay_sources=stay_sources,\n        length_of_stays=length_of_stays,\n        provenance_sources=provenance_sources,\n        person=person,\n        age_ranges=age_ranges,\n    ).drop(columns=[\"visit_occurrence_source_value\", \"date\"])\n\n    care_site = prepare_care_site(\n        data=data,\n        care_site_ids=care_site_ids,\n        care_site_short_names=care_site_short_names,\n        care_site_relationship=care_site_relationship,\n        care_site_specialties=care_site_specialties,\n        care_sites_sets=care_sites_sets,\n        specialties_sets=specialties_sets,\n    )\n\n    note_hospital = get_hospital_note(note, visit_occurrence, care_site)\n    hospital_name = CARE_SITE_LEVEL_NAMES[\"Hospital\"]\n    note_predictor_by_level = {hospital_name: note_hospital}\n\n    # UF selection\n    if not hospital_only(care_site_levels=care_site_levels):\n        if extra_data:  # pragma: no cover\n            note_uf, note_uc, note_uh = get_note_detail(\n                extra_data,\n                note,\n                visit_occurrence,\n                care_site,\n            )\n            uf_name = CARE_SITE_LEVEL_NAMES[\"UF\"]\n            note_predictor_by_level[uf_name] = note_uf\n            uc_name = CARE_SITE_LEVEL_NAMES[\"UC\"]\n            note_predictor_by_level[uc_name] = note_uc\n            uh_name = CARE_SITE_LEVEL_NAMES[\"UH\"]\n            note_predictor_by_level[uh_name] = note_uh\n\n            note_pole = get_pole_note(note_uf, care_site, care_site_relationship)\n            pole_name = CARE_SITE_LEVEL_NAMES[\"Pole\"]\n            note_predictor_by_level[pole_name] = note_pole\n        else:\n            logger.info(\"Note data are only available at hospital level\")\n            care_site_levels = [\"Hospital\"]\n\n    # Concatenate all predictors\n    note_predictor = concatenate_predictor_by_level(\n        predictor_by_level=note_predictor_by_level,\n        care_site_levels=care_site_levels,\n    )\n\n    if is_koalas(note_predictor):\n        note_predictor.spark.cache()\n\n    return compute_completeness(self, note_predictor)\n</code></pre>"},{"location":"reference/probes/note/completeness_predictors/per_visit/","title":"<code>edsteva.probes.note.completeness_predictors.per_visit</code>","text":""},{"location":"reference/probes/note/completeness_predictors/per_visit/#edsteva.probes.note.completeness_predictors.per_visit.compute_completeness_predictor_per_visit","title":"compute_completeness_predictor_per_visit","text":"<pre><code>compute_completeness_predictor_per_visit(\n    self,\n    data: Data,\n    care_site_relationship: pd.DataFrame,\n    start_date: datetime,\n    end_date: datetime,\n    care_site_levels: Union[bool, str, List[str]],\n    stay_types: Union[bool, str, Dict[str, str]],\n    care_site_ids: List[int],\n    care_site_short_names: List[str],\n    care_site_specialties: Union[bool, List[str]],\n    care_sites_sets: Union[str, Dict[str, str]],\n    specialties_sets: Union[str, Dict[str, str]],\n    extra_data: Data,\n    length_of_stays: List[float],\n    note_types: Union[bool, str, Dict[str, str]],\n    age_ranges: List[int],\n    provenance_sources: Union[bool, str, Dict[str, str]],\n    stay_sources: Union[bool, str, Dict[str, str]],\n    **kwargs\n)\n</code></pre> <p>Script to be used by <code>compute()</code></p> <p>The <code>per_visit</code> algorithm computes \\(c_(t)\\) the availability of clinical documents linked to patients' administrative stays:</p> \\[ c(t) = \\frac{n_{with\\,doc}(t)}{n_{visit}(t)} \\] <p>Where \\(n_{visit}(t)\\) is the number of administrative stays, \\(n_{with\\,doc}\\) the number of visits having at least one document and \\(t\\) is the month.</p> Source code in <code>edsteva/probes/note/completeness_predictors/per_visit.py</code> <pre><code>def compute_completeness_predictor_per_visit(\n    self,\n    data: Data,\n    care_site_relationship: pd.DataFrame,\n    start_date: datetime,\n    end_date: datetime,\n    care_site_levels: Union[bool, str, List[str]],\n    stay_types: Union[bool, str, Dict[str, str]],\n    care_site_ids: List[int],\n    care_site_short_names: List[str],\n    care_site_specialties: Union[bool, List[str]],\n    care_sites_sets: Union[str, Dict[str, str]],\n    specialties_sets: Union[str, Dict[str, str]],\n    extra_data: Data,\n    length_of_stays: List[float],\n    note_types: Union[bool, str, Dict[str, str]],\n    age_ranges: List[int],\n    provenance_sources: Union[bool, str, Dict[str, str]],\n    stay_sources: Union[bool, str, Dict[str, str]],\n    **kwargs\n):\nr\"\"\"Script to be used by [``compute()``][edsteva.probes.base.BaseProbe.compute]\n\n    The ``per_visit`` algorithm computes $c_(t)$ the availability of clinical documents linked to patients' administrative stays:\n\n    $$\n    c(t) = \\frac{n_{with\\,doc}(t)}{n_{visit}(t)}\n    $$\n\n    Where $n_{visit}(t)$ is the number of administrative stays, $n_{with\\,doc}$ the number of visits having at least one document and $t$ is the month.\n    \"\"\"\n\n    self._metrics = [\"c\", \"n_visit\", \"n_visit_with_note\"]\n    check_tables(data=data, required_tables=[\"note\"])\n\n    person = prepare_person(data)\n\n    visit_occurrence = prepare_visit_occurrence(\n        data=data,\n        start_date=start_date,\n        end_date=end_date,\n        stay_types=stay_types,\n        length_of_stays=length_of_stays,\n        provenance_sources=provenance_sources,\n        stay_sources=stay_sources,\n        person=person,\n        age_ranges=age_ranges,\n    )\n\n    care_site = prepare_care_site(\n        data=data,\n        care_site_ids=care_site_ids,\n        care_site_short_names=care_site_short_names,\n        care_site_relationship=care_site_relationship,\n        care_site_specialties=care_site_specialties,\n        care_sites_sets=care_sites_sets,\n        specialties_sets=specialties_sets,\n    )\n\n    note = prepare_note(data, note_types)\n\n    hospital_visit = get_hospital_visit(note, visit_occurrence, care_site)\n    hospital_name = CARE_SITE_LEVEL_NAMES[\"Hospital\"]\n    note_predictor_by_level = {hospital_name: hospital_visit}\n\n    # UF selection\n    if not hospital_only(care_site_levels=care_site_levels):\n        if extra_data:  # pragma: no cover\n            visit_detail = prepare_visit_detail(data, start_date, end_date)\n\n            uf_visit, uc_visit, uh_visit = get_visit_detail(\n                extra_data=extra_data,\n                note=note,\n                visit_occurrence=visit_occurrence,\n                visit_detail=visit_detail,\n                care_site=care_site,\n            )\n            uf_name = CARE_SITE_LEVEL_NAMES[\"UF\"]\n            note_predictor_by_level[uf_name] = uf_visit\n            uc_name = CARE_SITE_LEVEL_NAMES[\"UC\"]\n            note_predictor_by_level[uc_name] = uc_visit\n            uh_name = CARE_SITE_LEVEL_NAMES[\"UH\"]\n            note_predictor_by_level[uh_name] = uh_visit\n\n            pole_visit = get_pole_visit(uf_visit, care_site, care_site_relationship)\n            pole_name = CARE_SITE_LEVEL_NAMES[\"Pole\"]\n            note_predictor_by_level[pole_name] = pole_visit\n        else:\n            logger.info(\"Note data are only available at hospital level\")\n            care_site_levels = [\"Hospital\"]\n\n    # Concatenate all predictors\n    note_predictor = concatenate_predictor_by_level(\n        predictor_by_level=note_predictor_by_level,\n        care_site_levels=care_site_levels,\n    )\n\n    if is_koalas(note_predictor):\n        note_predictor.spark.cache()\n\n    return compute_completeness(self, note_predictor)\n</code></pre>"},{"location":"reference/probes/note/viz_configs/","title":"<code>edsteva.probes.note.viz_configs</code>","text":""},{"location":"reference/probes/note/viz_configs/n_note/","title":"<code>edsteva.probes.note.viz_configs.n_note</code>","text":""},{"location":"reference/probes/note/viz_configs/n_note/defaults/","title":"<code>edsteva.probes.note.viz_configs.n_note.defaults</code>","text":""},{"location":"reference/probes/note/viz_configs/n_note/estimates_densities_plot/","title":"<code>edsteva.probes.note.viz_configs.n_note.estimates_densities_plot</code>","text":""},{"location":"reference/probes/note/viz_configs/n_note/normalized_probe_dashboard/","title":"<code>edsteva.probes.note.viz_configs.n_note.normalized_probe_dashboard</code>","text":""},{"location":"reference/probes/note/viz_configs/n_note/normalized_probe_plot/","title":"<code>edsteva.probes.note.viz_configs.n_note.normalized_probe_plot</code>","text":""},{"location":"reference/probes/note/viz_configs/n_note/probe_dashboard/","title":"<code>edsteva.probes.note.viz_configs.n_note.probe_dashboard</code>","text":""},{"location":"reference/probes/note/viz_configs/n_note/probe_plot/","title":"<code>edsteva.probes.note.viz_configs.n_note.probe_plot</code>","text":""},{"location":"reference/probes/note/viz_configs/per_note/","title":"<code>edsteva.probes.note.viz_configs.per_note</code>","text":""},{"location":"reference/probes/note/viz_configs/per_note/defaults/","title":"<code>edsteva.probes.note.viz_configs.per_note.defaults</code>","text":""},{"location":"reference/probes/note/viz_configs/per_note/estimates_densities_plot/","title":"<code>edsteva.probes.note.viz_configs.per_note.estimates_densities_plot</code>","text":""},{"location":"reference/probes/note/viz_configs/per_note/normalized_probe_dashboard/","title":"<code>edsteva.probes.note.viz_configs.per_note.normalized_probe_dashboard</code>","text":""},{"location":"reference/probes/note/viz_configs/per_note/normalized_probe_plot/","title":"<code>edsteva.probes.note.viz_configs.per_note.normalized_probe_plot</code>","text":""},{"location":"reference/probes/note/viz_configs/per_note/probe_dashboard/","title":"<code>edsteva.probes.note.viz_configs.per_note.probe_dashboard</code>","text":""},{"location":"reference/probes/note/viz_configs/per_note/probe_plot/","title":"<code>edsteva.probes.note.viz_configs.per_note.probe_plot</code>","text":""},{"location":"reference/probes/note/viz_configs/per_visit/","title":"<code>edsteva.probes.note.viz_configs.per_visit</code>","text":""},{"location":"reference/probes/note/viz_configs/per_visit/defaults/","title":"<code>edsteva.probes.note.viz_configs.per_visit.defaults</code>","text":""},{"location":"reference/probes/note/viz_configs/per_visit/estimates_densities_plot/","title":"<code>edsteva.probes.note.viz_configs.per_visit.estimates_densities_plot</code>","text":""},{"location":"reference/probes/note/viz_configs/per_visit/normalized_probe_dashboard/","title":"<code>edsteva.probes.note.viz_configs.per_visit.normalized_probe_dashboard</code>","text":""},{"location":"reference/probes/note/viz_configs/per_visit/normalized_probe_plot/","title":"<code>edsteva.probes.note.viz_configs.per_visit.normalized_probe_plot</code>","text":""},{"location":"reference/probes/note/viz_configs/per_visit/probe_dashboard/","title":"<code>edsteva.probes.note.viz_configs.per_visit.probe_dashboard</code>","text":""},{"location":"reference/probes/note/viz_configs/per_visit/probe_plot/","title":"<code>edsteva.probes.note.viz_configs.per_visit.probe_plot</code>","text":""},{"location":"reference/probes/utils/","title":"<code>edsteva.probes.utils</code>","text":""},{"location":"reference/probes/utils/filter_df/","title":"<code>edsteva.probes.utils.filter_df</code>","text":""},{"location":"reference/probes/utils/prepare_df/","title":"<code>edsteva.probes.utils.prepare_df</code>","text":""},{"location":"reference/probes/utils/prepare_df/#edsteva.probes.utils.prepare_df.prepare_care_site_relationship","title":"prepare_care_site_relationship","text":"<pre><code>prepare_care_site_relationship(data: Data) -&gt; pd.DataFrame\n</code></pre> <p>Computes hierarchical care site structure</p> PARAMETER DESCRIPTION <code>data</code> <p>Instantiated <code>HiveData</code>, <code>PostgresData</code> or <code>LocalData</code></p> <p> TYPE: <code>Data</code> </p>"},{"location":"reference/probes/utils/prepare_df/#edsteva.probes.utils.prepare_df.prepare_care_site_relationship--example","title":"Example","text":"care_site_id care_site_level care_site_short_name parent_care_site_id parent_care_site_level parent_care_site_short_name 8312056386 Unit\u00e9 Fonctionnelle (UF) UF A 8312027648 P\u00f4le/DMU Pole A 8312022130 P\u00f4le/DMU Pole B 8312033550 H\u00f4pital Hospital A 8312016782 Service/D\u00e9partement Service A 8312033550 H\u00f4pital Hospital A 8312010155 Unit\u00e9 Fonctionnelle (UF) UF B 8312022130 P\u00f4le/DMU Pole B 8312067829 Unit\u00e9 de consultation (UC) UC A 8312051097 Unit\u00e9 de consultation (UC) UC B Source code in <code>edsteva/probes/utils/prepare_df.py</code> <pre><code>def prepare_care_site_relationship(data: Data) -&gt; pd.DataFrame:\n\"\"\"Computes hierarchical care site structure\n\n    Parameters\n    ----------\n    data : Data\n        Instantiated [``HiveData``][edsteva.io.hive.HiveData], [``PostgresData``][edsteva.io.postgres.PostgresData] or [``LocalData``][edsteva.io.files.LocalData]\n\n    Example\n    -------\n\n    | care_site_id | care_site_level            | care_site_short_name | parent_care_site_id | parent_care_site_level     | parent_care_site_short_name |\n    | :----------- | :------------------------- | :------------------- | :------------------ | :------------------------- | :-------------------------- |\n    | 8312056386   | Unit\u00e9 Fonctionnelle (UF)   | UF A                 | 8312027648          | P\u00f4le/DMU                   | Pole A                      |\n    | 8312022130   | P\u00f4le/DMU                   | Pole B               | 8312033550          | H\u00f4pital                    | Hospital A                  |\n    | 8312016782   | Service/D\u00e9partement        | Service A            | 8312033550          | H\u00f4pital                    | Hospital A                  |\n    | 8312010155   | Unit\u00e9 Fonctionnelle (UF)   | UF B                 | 8312022130          | P\u00f4le/DMU                   | Pole B                      |\n    | 8312067829   | Unit\u00e9 de consultation (UC) | UC A                 | 8312051097          | Unit\u00e9 de consultation (UC) | UC B                        |\n\n    \"\"\"\n    fact_relationship = data.fact_relationship[\n        [\n            \"fact_id_1\",\n            \"fact_id_2\",\n            \"domain_concept_id_1\",\n            \"relationship_concept_id\",\n        ]\n    ]\n    fact_relationship = to(\"pandas\", fact_relationship)\n\n    care_site_relationship = fact_relationship[\n        (fact_relationship[\"domain_concept_id_1\"] == 57)  # Care_site domain\n        &amp; (fact_relationship[\"relationship_concept_id\"] == 46233688)  # Included in\n    ]\n    care_site_relationship = care_site_relationship.drop(\n        columns=[\"domain_concept_id_1\", \"relationship_concept_id\"]\n    )\n    care_site_relationship = care_site_relationship.rename(\n        columns={\"fact_id_1\": \"care_site_id\", \"fact_id_2\": \"parent_care_site_id\"}\n    )\n\n    care_site = data.care_site[\n        [\n            \"care_site_id\",\n            \"care_site_type_source_value\",\n            \"care_site_short_name\",\n            \"place_of_service_source_value\",\n        ]\n    ]\n    care_site = to(\"pandas\", care_site)\n    care_site = care_site.rename(\n        columns={\n            \"care_site_type_source_value\": \"care_site_level\",\n            \"place_of_service_source_value\": \"care_site_specialty\",\n        }\n    )\n    care_site_relationship = care_site.merge(\n        care_site_relationship, on=\"care_site_id\", how=\"left\"\n    )\n\n    parent_care_site = care_site.rename(\n        columns={\n            \"care_site_level\": \"parent_care_site_level\",\n            \"care_site_id\": \"parent_care_site_id\",\n            \"care_site_short_name\": \"parent_care_site_short_name\",\n            \"care_site_specialty\": \"parent_care_site_specialty\",\n        }\n    )\n    logger.debug(\"Create care site relationship to link UC to UF and UF to Pole\")\n\n    return care_site_relationship.merge(\n        parent_care_site, on=\"parent_care_site_id\", how=\"left\"\n    )\n</code></pre>"},{"location":"reference/probes/utils/prepare_df/#edsteva.probes.utils.prepare_df.prepare_biology_relationship","title":"prepare_biology_relationship","text":"<pre><code>prepare_biology_relationship(\n    data: Data,\n    standard_terminologies: List[str],\n    source_terminologies: Dict[str, str],\n    mapping: List[Tuple[str, str, str]],\n) -&gt; pd.DataFrame\n</code></pre> <p>Computes biology relationship</p> PARAMETER DESCRIPTION <code>data</code> <p>Instantiated <code>HiveData</code>, <code>PostgresData</code> or <code>LocalData</code></p> <p> TYPE: <code>Data</code> </p>"},{"location":"reference/probes/utils/prepare_df/#edsteva.probes.utils.prepare_df.prepare_biology_relationship--example","title":"Example","text":"care_site_id care_site_level care_site_short_name parent_care_site_id parent_care_site_level parent_care_site_short_name 8312056386 Unit\u00e9 Fonctionnelle (UF) UF A 8312027648 P\u00f4le/DMU Pole A 8312022130 P\u00f4le/DMU Pole B 8312033550 H\u00f4pital Hospital A 8312016782 Service/D\u00e9partement Service A 8312033550 H\u00f4pital Hospital A 8312010155 Unit\u00e9 Fonctionnelle (UF) UF B 8312022130 P\u00f4le/DMU Pole B 8312067829 Unit\u00e9 de consultation (UC) UC A 8312051097 Unit\u00e9 de consultation (UC) UC B Source code in <code>edsteva/probes/utils/prepare_df.py</code> <pre><code>def prepare_biology_relationship(\n    data: Data,\n    standard_terminologies: List[str],\n    source_terminologies: Dict[str, str],\n    mapping: List[Tuple[str, str, str]],\n) -&gt; pd.DataFrame:\n\"\"\"Computes biology relationship\n\n    Parameters\n    ----------\n    data : Data\n        Instantiated [``HiveData``][edsteva.io.hive.HiveData], [``PostgresData``][edsteva.io.postgres.PostgresData] or [``LocalData``][edsteva.io.files.LocalData]\n\n    Example\n    -------\n\n    | care_site_id | care_site_level            | care_site_short_name | parent_care_site_id | parent_care_site_level     | parent_care_site_short_name |\n    | :----------- | :------------------------- | :------------------- | :------------------ | :------------------------- | :-------------------------- |\n    | 8312056386   | Unit\u00e9 Fonctionnelle (UF)   | UF A                 | 8312027648          | P\u00f4le/DMU                   | Pole A                      |\n    | 8312022130   | P\u00f4le/DMU                   | Pole B               | 8312033550          | H\u00f4pital                    | Hospital A                  |\n    | 8312016782   | Service/D\u00e9partement        | Service A            | 8312033550          | H\u00f4pital                    | Hospital A                  |\n    | 8312010155   | Unit\u00e9 Fonctionnelle (UF)   | UF B                 | 8312022130          | P\u00f4le/DMU                   | Pole B                      |\n    | 8312067829   | Unit\u00e9 de consultation (UC) | UC A                 | 8312051097          | Unit\u00e9 de consultation (UC) | UC B                        |\n\n    \"\"\"\n\n    logger.debug(\n        \"Create biology relationship to link ANALYSES LABORATOIRE to ANABIO to LOINC\"\n    )\n\n    check_tables(data=data, required_tables=[\"concept\", \"concept_relationship\"])\n    concept_columns = [\n        \"concept_id\",\n        \"concept_name\",\n        \"concept_code\",\n        \"vocabulary_id\",\n    ]\n\n    concept_relationship_columns = [\n        \"concept_id_1\",\n        \"concept_id_2\",\n        \"relationship_id\",\n    ]\n    check_columns(\n        data.concept,\n        required_columns=concept_columns,\n        df_name=\"concept\",\n    )\n\n    check_columns(\n        data.concept_relationship,\n        required_columns=concept_relationship_columns,\n        df_name=\"concept_relationship\",\n    )\n    concept = to(\"pandas\", data.concept[concept_columns])\n    concept_relationship = to(\n        \"pandas\", data.concept_relationship[concept_relationship_columns]\n    )\n    concept_by_terminology = {}\n    for terminology, regex in source_terminologies.items():\n        concept_by_terminology[terminology] = (\n            concept[concept.vocabulary_id.str.contains(regex)]\n            .rename(\n                columns={\n                    \"concept_id\": \"{}_concept_id\".format(terminology),\n                    \"concept_name\": \"{}_concept_name\".format(terminology),\n                    \"concept_code\": \"{}_concept_code\".format(terminology),\n                }\n            )\n            .drop(columns=\"vocabulary_id\")\n        )\n    root_terminology = mapping[0][0]\n    biology_relationship = concept_by_terminology[root_terminology]\n    for source, target, relationship_id in mapping:\n        relationship = concept_relationship.rename(\n            columns={\n                \"concept_id_1\": \"{}_concept_id\".format(source),\n                \"concept_id_2\": \"{}_concept_id\".format(target),\n            }\n        )[concept_relationship.relationship_id == relationship_id].drop(\n            columns=\"relationship_id\"\n        )\n        relationship = relationship.merge(\n            concept_by_terminology[target], on=\"{}_concept_id\".format(target)\n        )\n        biology_relationship = biology_relationship.merge(\n            relationship, on=\"{}_concept_id\".format(source), how=\"left\"\n        )\n\n    # Get ITM code in priority and if not get GLIMS code\n    for standard_terminology in standard_terminologies:\n        biology_relationship[\n            \"{}_concept_code\".format(standard_terminology)\n        ] = biology_relationship[\n            \"{}_ITM_concept_code\".format(standard_terminology)\n        ].mask(\n            biology_relationship[\n                \"{}_ITM_concept_code\".format(standard_terminology)\n            ].isna(),\n            biology_relationship[\"GLIMS_{}_concept_code\".format(standard_terminology)],\n        )\n        biology_relationship[\n            \"{}_concept_name\".format(standard_terminology)\n        ] = biology_relationship[\n            \"{}_ITM_concept_name\".format(standard_terminology)\n        ].mask(\n            biology_relationship[\n                \"{}_ITM_concept_name\".format(standard_terminology)\n            ].isna(),\n            biology_relationship[\"GLIMS_{}_concept_name\".format(standard_terminology)],\n        )\n\n        biology_relationship[\"{}_vocabulary\".format(standard_terminology)] = \"ITM\"\n        biology_relationship[\n            \"{}_vocabulary\".format(standard_terminology)\n        ] = biology_relationship[\"{}_vocabulary\".format(standard_terminology)].mask(\n            biology_relationship[\n                \"{}_ITM_concept_code\".format(standard_terminology)\n            ].isna(),\n            \"GLIMS\",\n        )\n\n    return biology_relationship\n</code></pre>"},{"location":"reference/probes/utils/utils/","title":"<code>edsteva.probes.utils.utils</code>","text":""},{"location":"reference/probes/visit/","title":"<code>edsteva.probes.visit</code>","text":""},{"location":"reference/probes/visit/visit/","title":"<code>edsteva.probes.visit.visit</code>","text":""},{"location":"reference/probes/visit/visit/#edsteva.probes.visit.visit.VisitProbe","title":"VisitProbe","text":"<p>         Bases: <code>BaseProbe</code></p> <p>The <code>VisitProbe</code> computes \\(c_(t)\\) the availability of administrative data according to time:</p> PARAMETER DESCRIPTION <code>completeness_predictor</code> <p>Algorithm used to compute the completeness predictor</p> <p>EXAMPLE: <code>\"per_visit_default\"</code></p> <p> TYPE: <code>str</code> DEFAULT: <code>'per_visit_default'</code> </p> ATTRIBUTE DESCRIPTION <code>_completeness_predictor</code> <p>Algorithm used to compute the completeness predictor</p> <p>VALUE: <code>\"per_visit_default\"</code></p> <p> TYPE: <code>str</code> </p> <code>_index</code> <p>Variable from which data is grouped</p> <p>VALUE: <code>[\"care_site_level\", \"stay_type\", \"length_of_stay\", \"care_site_id\"]</code></p> <p> TYPE: <code>List[str]</code> </p> <code>_viz_config</code> <p>Dictionary of configuration for visualization purpose.</p> <p>VALUE: <code>{}</code></p> <p> TYPE: <code>List[str]</code> </p> Source code in <code>edsteva/probes/visit/visit.py</code> <pre><code>class VisitProbe(BaseProbe):\nr\"\"\"\n    The ``VisitProbe`` computes $c_(t)$ the availability of administrative data according to time:\n\n    Parameters\n    ----------\n    completeness_predictor: str\n        Algorithm used to compute the completeness predictor\n\n        **EXAMPLE**: ``\"per_visit_default\"``\n\n    Attributes\n    ----------\n    _completeness_predictor: str\n        Algorithm used to compute the completeness predictor\n\n        **VALUE**: ``\"per_visit_default\"``\n    _index: List[str]\n        Variable from which data is grouped\n\n        **VALUE**: ``[\"care_site_level\", \"stay_type\", \"length_of_stay\", \"care_site_id\"]``\n    _viz_config: List[str]\n        Dictionary of configuration for visualization purpose.\n\n        **VALUE**: ``{}``\n    \"\"\"\n\n    def __init__(\n        self,\n        completeness_predictor: str = \"per_visit_default\",\n    ):\n        self._index = [\n            \"care_site_id\",\n            \"care_site_level\",\n            \"care_sites_set\",\n            \"care_site_specialty\",\n            \"specialties_set\",\n            \"stay_type\",\n            \"stay_source\",\n            \"length_of_stay\",\n            \"provenance_source\",\n            \"age_range\",\n        ]\n        super().__init__(\n            completeness_predictor=completeness_predictor,\n            index=self._index,\n        )\n\n    def compute_process(\n        self,\n        data: Data,\n        care_site_relationship: pd.DataFrame,\n        start_date: datetime,\n        end_date: datetime,\n        care_site_ids: List[int] = None,\n        care_site_short_names: List[str] = None,\n        care_site_levels: Union[bool, str, List[str]] = True,\n        care_sites_sets: Union[str, Dict[str, str]] = None,\n        care_site_specialties: Union[bool, List[str]] = None,\n        specialties_sets: Union[str, Dict[str, str]] = None,\n        stay_types: Union[bool, str, Dict[str, str]] = True,\n        stay_sources: Union[bool, str, Dict[str, str]] = None,\n        length_of_stays: List[float] = None,\n        provenance_sources: Union[bool, str, Dict[str, str]] = None,\n        age_ranges: List[int] = None,\n        **kwargs,\n    ):\n\"\"\"Script to be used by [``compute()``][edsteva.probes.base.BaseProbe.compute]\n\n        Parameters\n        ----------\n        data : Data\n            Instantiated [``HiveData``][edsteva.io.hive.HiveData], [``PostgresData``][edsteva.io.postgres.PostgresData] or [``LocalData``][edsteva.io.files.LocalData]\n        care_site_relationship : pd.DataFrame\n            DataFrame computed in the [``compute()``][edsteva.probes.base.BaseProbe.compute] that gives the hierarchy of the care site structure.\n        start_date : datetime, optional\n            **EXAMPLE**: `\"2019-05-01\"`\n        end_date : datetime, optional\n            **EXAMPLE**: `\"2021-07-01\"`\n        care_site_ids : List[int], optional\n            **EXAMPLE**: `[8312056386, 8312027648]`\n        care_site_short_names : List[str], optional\n            **EXAMPLE**: `[\"HOSPITAL 1\", \"HOSPITAL 2\"]`\n        care_site_levels : Union[bool, str, List[str]], optional\n            **EXAMPLE**: `[\"Hospital\", \"Pole\", \"UF\", \"UC\", \"UH\"]`\n        care_sites_sets: Union[str, Dict[str, str]], optional\n            **EXAMPLE**: `{\"All AP-HP\": \".*\"}` or `{\"All AP-HP\": \".*\", \"Pediatrics\": r\"debre|trousseau|necker\"}`\n        care_site_specialties: Union[bool, List[str]], optional\n            **EXAMPLE**: `[\"CARDIOLOGIE\", \"CHIRURGIE\"]`\n        specialties_sets: Union[str, Dict[str, str]], optional\n            **EXAMPLE**: `{\"All\": \".*\"}` or `{\"All\": \".*\", \"ICU\": r\"REA\\s|USI\\s|SC\\s\"}`\n        stay_types: Union[bool, str, Dict[str, str]], optional\n            **EXAMPLE**: `{\"All\": \".*\"}` or `{\"All\": \".*\", \"Urg_and_consult\": \"urgences|consultation\"}` or `\"hospitalis\u00e9s`\n        stay_sources: Union[bool, str, Dict[str, str]], optional\n            **EXAMPLE**: `{\"All\": \".*\"}, {\"MCO\" : \"MCO\", \"MCO_PSY_SSR\" : \"MCO|Psychiatrie|SSR\"}`\n        length_of_stays: List[float], optional\n            **EXAMPLE**: `[1, 30]`\n        provenance_sources: Union[bool, str, Dict[str, str]], optional\n            **EXAMPLE**: `{\"All\": \".*\"}, {\"urgence\" : \"service d'urgence\"}`\n        age_ranges: List[int], optional\n            **EXAMPLE**: `[18, 64]`\n        \"\"\"\n        if not care_site_levels and \"care_site_level\" in self._index:\n            self._index.remove(\"care_site_level\")\n        if not care_sites_sets and \"care_sites_set\" in self._index:\n            self._index.remove(\"care_sites_set\")\n        if not care_site_specialties and \"care_site_specialty\" in self._index:\n            self._index.remove(\"care_site_specialty\")\n        if not specialties_sets and \"specialties_set\" in self._index:\n            self._index.remove(\"specialties_set\")\n        if not stay_types and \"stay_type\" in self._index:\n            self._index.remove(\"stay_type\")\n        if not stay_sources and \"stay_source\" in self._index:\n            self._index.remove(\"stay_source\")\n        if not length_of_stays and \"length_of_stay\" in self._index:\n            self._index.remove(\"length_of_stay\")\n        if not provenance_sources and \"provenance_source\" in self._index:\n            self._index.remove(\"provenance_source\")\n        if not age_ranges and \"age_range\" in self._index:\n            self._index.remove(\"age_range\")\n        return completeness_predictors.get(self._completeness_predictor)(\n            self,\n            data=data,\n            care_site_relationship=care_site_relationship,\n            start_date=start_date,\n            end_date=end_date,\n            care_site_levels=care_site_levels,\n            stay_types=stay_types,\n            care_site_ids=care_site_ids,\n            care_site_short_names=care_site_short_names,\n            care_site_specialties=care_site_specialties,\n            care_sites_sets=care_sites_sets,\n            specialties_sets=specialties_sets,\n            length_of_stays=length_of_stays,\n            provenance_sources=provenance_sources,\n            stay_sources=stay_sources,\n            age_ranges=age_ranges,\n            **kwargs,\n        )\n\n    def get_viz_config(self, viz_type: str, **kwargs):\n        if viz_type in viz_configs.keys():\n            _viz_config = self._viz_config.get(viz_type)\n            if _viz_config is None:\n                _viz_config = self._completeness_predictor\n        else:\n            raise ValueError(f\"edsteva has no {viz_type} registry !\")\n        return viz_configs[viz_type].get(_viz_config)(self, **kwargs)\n\n    def available_completeness_predictors(self):\n        return list(completeness_predictors.get_all().keys())\n</code></pre>"},{"location":"reference/probes/visit/visit/#edsteva.probes.visit.visit.VisitProbe.compute_process","title":"compute_process","text":"<pre><code>compute_process(\n    data: Data,\n    care_site_relationship: pd.DataFrame,\n    start_date: datetime,\n    end_date: datetime,\n    care_site_ids: List[int] = None,\n    care_site_short_names: List[str] = None,\n    care_site_levels: Union[bool, str, List[str]] = True,\n    care_sites_sets: Union[str, Dict[str, str]] = None,\n    care_site_specialties: Union[bool, List[str]] = None,\n    specialties_sets: Union[str, Dict[str, str]] = None,\n    stay_types: Union[bool, str, Dict[str, str]] = True,\n    stay_sources: Union[bool, str, Dict[str, str]] = None,\n    length_of_stays: List[float] = None,\n    provenance_sources: Union[\n        bool, str, Dict[str, str]\n    ] = None,\n    age_ranges: List[int] = None,\n    **kwargs\n)\n</code></pre> <p>Script to be used by <code>compute()</code></p> PARAMETER DESCRIPTION <code>data</code> <p>Instantiated <code>HiveData</code>, <code>PostgresData</code> or <code>LocalData</code></p> <p> TYPE: <code>Data</code> </p> <code>care_site_relationship</code> <p>DataFrame computed in the <code>compute()</code> that gives the hierarchy of the care site structure.</p> <p> TYPE: <code>pd.DataFrame</code> </p> <code>start_date</code> <p>EXAMPLE: <code>\"2019-05-01\"</code></p> <p> TYPE: <code>datetime</code> </p> <code>end_date</code> <p>EXAMPLE: <code>\"2021-07-01\"</code></p> <p> TYPE: <code>datetime</code> </p> <code>care_site_ids</code> <p>EXAMPLE: <code>[8312056386, 8312027648]</code></p> <p> TYPE: <code>List[int]</code> DEFAULT: <code>None</code> </p> <code>care_site_short_names</code> <p>EXAMPLE: <code>[\"HOSPITAL 1\", \"HOSPITAL 2\"]</code></p> <p> TYPE: <code>List[str]</code> DEFAULT: <code>None</code> </p> <code>care_site_levels</code> <p>EXAMPLE: <code>[\"Hospital\", \"Pole\", \"UF\", \"UC\", \"UH\"]</code></p> <p> TYPE: <code>Union[bool, str, List[str]]</code> DEFAULT: <code>True</code> </p> <code>care_sites_sets</code> <p>EXAMPLE: <code>{\"All AP-HP\": \".*\"}</code> or <code>{\"All AP-HP\": \".*\", \"Pediatrics\": r\"debre|trousseau|necker\"}</code></p> <p> TYPE: <code>Union[str, Dict[str, str]]</code> DEFAULT: <code>None</code> </p> <code>care_site_specialties</code> <p>EXAMPLE: <code>[\"CARDIOLOGIE\", \"CHIRURGIE\"]</code></p> <p> TYPE: <code>Union[bool, List[str]]</code> DEFAULT: <code>None</code> </p> <code>specialties_sets</code> <p>EXAMPLE: <code>{\"All\": \".*\"}</code> or <code>{\"All\": \".*\", \"ICU\": r\"REA\\s|USI\\s|SC\\s\"}</code></p> <p> TYPE: <code>Union[str, Dict[str, str]]</code> DEFAULT: <code>None</code> </p> <code>stay_types</code> <p>EXAMPLE: <code>{\"All\": \".*\"}</code> or <code>{\"All\": \".*\", \"Urg_and_consult\": \"urgences|consultation\"}</code> or <code>\"hospitalis\u00e9s</code></p> <p> TYPE: <code>Union[bool, str, Dict[str, str]]</code> DEFAULT: <code>True</code> </p> <code>stay_sources</code> <p>EXAMPLE: <code>{\"All\": \".*\"}, {\"MCO\" : \"MCO\", \"MCO_PSY_SSR\" : \"MCO|Psychiatrie|SSR\"}</code></p> <p> TYPE: <code>Union[bool, str, Dict[str, str]]</code> DEFAULT: <code>None</code> </p> <code>length_of_stays</code> <p>EXAMPLE: <code>[1, 30]</code></p> <p> TYPE: <code>List[float]</code> DEFAULT: <code>None</code> </p> <code>provenance_sources</code> <p>EXAMPLE: <code>{\"All\": \".*\"}, {\"urgence\" : \"service d'urgence\"}</code></p> <p> TYPE: <code>Union[bool, str, Dict[str, str]]</code> DEFAULT: <code>None</code> </p> <code>age_ranges</code> <p>EXAMPLE: <code>[18, 64]</code></p> <p> TYPE: <code>List[int]</code> DEFAULT: <code>None</code> </p> Source code in <code>edsteva/probes/visit/visit.py</code> <pre><code>def compute_process(\n    self,\n    data: Data,\n    care_site_relationship: pd.DataFrame,\n    start_date: datetime,\n    end_date: datetime,\n    care_site_ids: List[int] = None,\n    care_site_short_names: List[str] = None,\n    care_site_levels: Union[bool, str, List[str]] = True,\n    care_sites_sets: Union[str, Dict[str, str]] = None,\n    care_site_specialties: Union[bool, List[str]] = None,\n    specialties_sets: Union[str, Dict[str, str]] = None,\n    stay_types: Union[bool, str, Dict[str, str]] = True,\n    stay_sources: Union[bool, str, Dict[str, str]] = None,\n    length_of_stays: List[float] = None,\n    provenance_sources: Union[bool, str, Dict[str, str]] = None,\n    age_ranges: List[int] = None,\n    **kwargs,\n):\n\"\"\"Script to be used by [``compute()``][edsteva.probes.base.BaseProbe.compute]\n\n    Parameters\n    ----------\n    data : Data\n        Instantiated [``HiveData``][edsteva.io.hive.HiveData], [``PostgresData``][edsteva.io.postgres.PostgresData] or [``LocalData``][edsteva.io.files.LocalData]\n    care_site_relationship : pd.DataFrame\n        DataFrame computed in the [``compute()``][edsteva.probes.base.BaseProbe.compute] that gives the hierarchy of the care site structure.\n    start_date : datetime, optional\n        **EXAMPLE**: `\"2019-05-01\"`\n    end_date : datetime, optional\n        **EXAMPLE**: `\"2021-07-01\"`\n    care_site_ids : List[int], optional\n        **EXAMPLE**: `[8312056386, 8312027648]`\n    care_site_short_names : List[str], optional\n        **EXAMPLE**: `[\"HOSPITAL 1\", \"HOSPITAL 2\"]`\n    care_site_levels : Union[bool, str, List[str]], optional\n        **EXAMPLE**: `[\"Hospital\", \"Pole\", \"UF\", \"UC\", \"UH\"]`\n    care_sites_sets: Union[str, Dict[str, str]], optional\n        **EXAMPLE**: `{\"All AP-HP\": \".*\"}` or `{\"All AP-HP\": \".*\", \"Pediatrics\": r\"debre|trousseau|necker\"}`\n    care_site_specialties: Union[bool, List[str]], optional\n        **EXAMPLE**: `[\"CARDIOLOGIE\", \"CHIRURGIE\"]`\n    specialties_sets: Union[str, Dict[str, str]], optional\n        **EXAMPLE**: `{\"All\": \".*\"}` or `{\"All\": \".*\", \"ICU\": r\"REA\\s|USI\\s|SC\\s\"}`\n    stay_types: Union[bool, str, Dict[str, str]], optional\n        **EXAMPLE**: `{\"All\": \".*\"}` or `{\"All\": \".*\", \"Urg_and_consult\": \"urgences|consultation\"}` or `\"hospitalis\u00e9s`\n    stay_sources: Union[bool, str, Dict[str, str]], optional\n        **EXAMPLE**: `{\"All\": \".*\"}, {\"MCO\" : \"MCO\", \"MCO_PSY_SSR\" : \"MCO|Psychiatrie|SSR\"}`\n    length_of_stays: List[float], optional\n        **EXAMPLE**: `[1, 30]`\n    provenance_sources: Union[bool, str, Dict[str, str]], optional\n        **EXAMPLE**: `{\"All\": \".*\"}, {\"urgence\" : \"service d'urgence\"}`\n    age_ranges: List[int], optional\n        **EXAMPLE**: `[18, 64]`\n    \"\"\"\n    if not care_site_levels and \"care_site_level\" in self._index:\n        self._index.remove(\"care_site_level\")\n    if not care_sites_sets and \"care_sites_set\" in self._index:\n        self._index.remove(\"care_sites_set\")\n    if not care_site_specialties and \"care_site_specialty\" in self._index:\n        self._index.remove(\"care_site_specialty\")\n    if not specialties_sets and \"specialties_set\" in self._index:\n        self._index.remove(\"specialties_set\")\n    if not stay_types and \"stay_type\" in self._index:\n        self._index.remove(\"stay_type\")\n    if not stay_sources and \"stay_source\" in self._index:\n        self._index.remove(\"stay_source\")\n    if not length_of_stays and \"length_of_stay\" in self._index:\n        self._index.remove(\"length_of_stay\")\n    if not provenance_sources and \"provenance_source\" in self._index:\n        self._index.remove(\"provenance_source\")\n    if not age_ranges and \"age_range\" in self._index:\n        self._index.remove(\"age_range\")\n    return completeness_predictors.get(self._completeness_predictor)(\n        self,\n        data=data,\n        care_site_relationship=care_site_relationship,\n        start_date=start_date,\n        end_date=end_date,\n        care_site_levels=care_site_levels,\n        stay_types=stay_types,\n        care_site_ids=care_site_ids,\n        care_site_short_names=care_site_short_names,\n        care_site_specialties=care_site_specialties,\n        care_sites_sets=care_sites_sets,\n        specialties_sets=specialties_sets,\n        length_of_stays=length_of_stays,\n        provenance_sources=provenance_sources,\n        stay_sources=stay_sources,\n        age_ranges=age_ranges,\n        **kwargs,\n    )\n</code></pre>"},{"location":"reference/probes/visit/completeness_predictors/","title":"<code>edsteva.probes.visit.completeness_predictors</code>","text":""},{"location":"reference/probes/visit/completeness_predictors/per_visit/","title":"<code>edsteva.probes.visit.completeness_predictors.per_visit</code>","text":""},{"location":"reference/probes/visit/completeness_predictors/per_visit/#edsteva.probes.visit.completeness_predictors.per_visit.compute_completeness_predictor_per_visit","title":"compute_completeness_predictor_per_visit","text":"<pre><code>compute_completeness_predictor_per_visit(\n    self,\n    data: Data,\n    care_site_relationship: pd.DataFrame,\n    start_date: datetime,\n    end_date: datetime,\n    care_site_levels: Union[bool, str, List[str]],\n    stay_types: Union[bool, str, Dict[str, str]],\n    care_site_ids: List[int],\n    care_site_short_names: List[str],\n    care_site_specialties: Union[bool, List[str]],\n    care_sites_sets: Union[str, Dict[str, str]],\n    specialties_sets: Union[str, Dict[str, str]],\n    length_of_stays: List[float],\n    age_ranges: List[int],\n    provenance_sources: Union[bool, str, Dict[str, str]],\n    stay_sources: Union[bool, str, Dict[str, str]],\n    **kwargs\n)\n</code></pre> <p>Script to be used by <code>compute()</code></p> <p>The <code>per_visit</code> algorithm computes \\(c_(t)\\) the availability of administrative data related to visits for each care site according to time:</p> \\[ c(t) = \\frac{n_{visit}(t)}{n_{max}} \\] <p>Where \\(n_{visit}(t)\\) is the number of administrative stays, \\(t\\) is the month and \\(n_{max} = \\max_{t}(n_{visit}(t))\\).</p> Source code in <code>edsteva/probes/visit/completeness_predictors/per_visit.py</code> <pre><code>def compute_completeness_predictor_per_visit(\n    self,\n    data: Data,\n    care_site_relationship: pd.DataFrame,\n    start_date: datetime,\n    end_date: datetime,\n    care_site_levels: Union[bool, str, List[str]],\n    stay_types: Union[bool, str, Dict[str, str]],\n    care_site_ids: List[int],\n    care_site_short_names: List[str],\n    care_site_specialties: Union[bool, List[str]],\n    care_sites_sets: Union[str, Dict[str, str]],\n    specialties_sets: Union[str, Dict[str, str]],\n    length_of_stays: List[float],\n    age_ranges: List[int],\n    provenance_sources: Union[bool, str, Dict[str, str]],\n    stay_sources: Union[bool, str, Dict[str, str]],\n    **kwargs\n):\nr\"\"\"Script to be used by [``compute()``][edsteva.probes.base.BaseProbe.compute]\n\n    The ``per_visit`` algorithm computes $c_(t)$ the availability of administrative data related to visits for each care site according to time:\n\n    $$\n    c(t) = \\frac{n_{visit}(t)}{n_{max}}\n    $$\n\n    Where $n_{visit}(t)$ is the number of administrative stays, $t$ is the month and $n_{max} = \\max_{t}(n_{visit}(t))$.\n    \"\"\"\n    self._metrics = [\"c\", \"n_visit\"]\n\n    person = prepare_person(data)\n\n    visit_occurrence = prepare_visit_occurrence(\n        data=data,\n        start_date=start_date,\n        end_date=end_date,\n        stay_types=stay_types,\n        length_of_stays=length_of_stays,\n        stay_sources=stay_sources,\n        provenance_sources=provenance_sources,\n        person=person,\n        age_ranges=age_ranges,\n    )\n\n    care_site = prepare_care_site(\n        data=data,\n        care_site_ids=care_site_ids,\n        care_site_short_names=care_site_short_names,\n        care_site_specialties=care_site_specialties,\n        care_site_relationship=care_site_relationship,\n        specialties_sets=specialties_sets,\n        care_sites_sets=care_sites_sets,\n    )\n\n    hospital_visit = get_hospital_visit(\n        visit_occurrence,\n        care_site,\n    )\n\n    hospital_name = CARE_SITE_LEVEL_NAMES[\"Hospital\"]\n    visit_predictor_by_level = {hospital_name: hospital_visit}\n    if not hospital_only(care_site_levels=care_site_levels):\n        visit_detail = prepare_visit_detail(data, start_date, end_date)\n\n        uf_name = CARE_SITE_LEVEL_NAMES[\"UF\"]\n        uf_visit = get_uf_visit(\n            visit_occurrence,\n            visit_detail,\n            care_site,\n        )\n        visit_predictor_by_level[uf_name] = uf_visit\n\n        uc_name = CARE_SITE_LEVEL_NAMES[\"UC\"]\n        uc_visit = get_uc_visit(\n            visit_occurrence,\n            visit_detail,\n            care_site,\n        )\n        visit_predictor_by_level[uc_name] = uc_visit\n\n        uh_name = CARE_SITE_LEVEL_NAMES[\"UH\"]\n        uh_visit = get_uh_visit(\n            visit_occurrence,\n            visit_detail,\n            care_site,\n        )\n        visit_predictor_by_level[uh_name] = uh_visit\n\n        pole_name = CARE_SITE_LEVEL_NAMES[\"Pole\"]\n        pole_visit = get_pole_visit(\n            uf_visit,\n            care_site,\n            care_site_relationship,\n        )\n        visit_predictor_by_level[pole_name] = pole_visit\n\n    visit_predictor = concatenate_predictor_by_level(\n        predictor_by_level=visit_predictor_by_level,\n        care_site_levels=care_site_levels,\n    )\n\n    return compute_completeness(self, visit_predictor)\n</code></pre>"},{"location":"reference/probes/visit/viz_configs/","title":"<code>edsteva.probes.visit.viz_configs</code>","text":""},{"location":"reference/probes/visit/viz_configs/n_visit/","title":"<code>edsteva.probes.visit.viz_configs.n_visit</code>","text":""},{"location":"reference/probes/visit/viz_configs/n_visit/defaults/","title":"<code>edsteva.probes.visit.viz_configs.n_visit.defaults</code>","text":""},{"location":"reference/probes/visit/viz_configs/n_visit/estimates_densities_plot/","title":"<code>edsteva.probes.visit.viz_configs.n_visit.estimates_densities_plot</code>","text":""},{"location":"reference/probes/visit/viz_configs/n_visit/normalized_probe_dashboard/","title":"<code>edsteva.probes.visit.viz_configs.n_visit.normalized_probe_dashboard</code>","text":""},{"location":"reference/probes/visit/viz_configs/n_visit/normalized_probe_plot/","title":"<code>edsteva.probes.visit.viz_configs.n_visit.normalized_probe_plot</code>","text":""},{"location":"reference/probes/visit/viz_configs/n_visit/probe_dashboard/","title":"<code>edsteva.probes.visit.viz_configs.n_visit.probe_dashboard</code>","text":""},{"location":"reference/probes/visit/viz_configs/n_visit/probe_plot/","title":"<code>edsteva.probes.visit.viz_configs.n_visit.probe_plot</code>","text":""},{"location":"reference/probes/visit/viz_configs/per_visit/","title":"<code>edsteva.probes.visit.viz_configs.per_visit</code>","text":""},{"location":"reference/probes/visit/viz_configs/per_visit/defaults/","title":"<code>edsteva.probes.visit.viz_configs.per_visit.defaults</code>","text":""},{"location":"reference/probes/visit/viz_configs/per_visit/estimates_densities_plot/","title":"<code>edsteva.probes.visit.viz_configs.per_visit.estimates_densities_plot</code>","text":""},{"location":"reference/probes/visit/viz_configs/per_visit/normalized_probe_dashboard/","title":"<code>edsteva.probes.visit.viz_configs.per_visit.normalized_probe_dashboard</code>","text":""},{"location":"reference/probes/visit/viz_configs/per_visit/normalized_probe_plot/","title":"<code>edsteva.probes.visit.viz_configs.per_visit.normalized_probe_plot</code>","text":""},{"location":"reference/probes/visit/viz_configs/per_visit/probe_dashboard/","title":"<code>edsteva.probes.visit.viz_configs.per_visit.probe_dashboard</code>","text":""},{"location":"reference/probes/visit/viz_configs/per_visit/probe_plot/","title":"<code>edsteva.probes.visit.viz_configs.per_visit.probe_plot</code>","text":""},{"location":"reference/utils/","title":"<code>edsteva.utils</code>","text":""},{"location":"reference/utils/checks/","title":"<code>edsteva.utils.checks</code>","text":""},{"location":"reference/utils/checks/#edsteva.utils.checks.MissingColumnError","title":"MissingColumnError","text":"<p>         Bases: <code>Exception</code></p> <p>Exception raised when a concept is missing</p> Source code in <code>edsteva/utils/checks.py</code> <pre><code>class MissingColumnError(Exception):\n\"\"\"Exception raised when a concept is missing\"\"\"\n\n    def __init__(\n        self,\n        required_columns: List,\n        df_name: str = \"\",\n    ):\n        to_display_per_column = [f\"- {column}\" for column in required_columns]\n        str_to_display = \"\\n\".join(to_display_per_column)\n\n        if df_name:\n            df_name = f\" {df_name} \"\n        message = (\n            f\"The{df_name}DataFrame is missing some columns, \"\n            \"namely:\\n\"\n            f\"{str_to_display}\"\n        )\n\n        super().__init__(message)\n</code></pre>"},{"location":"reference/utils/checks/#edsteva.utils.checks.MissingTableError","title":"MissingTableError","text":"<p>         Bases: <code>Exception</code></p> <p>Exception raised when a table is missing in the Data</p> Source code in <code>edsteva/utils/checks.py</code> <pre><code>class MissingTableError(Exception):\n\"\"\"Exception raised when a table is missing in the Data\"\"\"\n\n    def __init__(\n        self,\n        required_tables: List,\n    ):\n        to_display_per_concept = [f\"- {concept}\" for concept in required_tables]\n        str_to_display = \"\\n\".join(to_display_per_concept)\n\n        message = f\"Data is missing some tables, namely:\\n {str_to_display}\"\n\n        super().__init__(message)\n</code></pre>"},{"location":"reference/utils/file_management/","title":"<code>edsteva.utils.file_management</code>","text":""},{"location":"reference/utils/framework/","title":"<code>edsteva.utils.framework</code>","text":""},{"location":"reference/utils/loss_functions/","title":"<code>edsteva.utils.loss_functions</code>","text":""},{"location":"reference/utils/typing/","title":"<code>edsteva.utils.typing</code>","text":""},{"location":"reference/viz/","title":"<code>edsteva.viz</code>","text":"<p>Top-level package for EDS-TeVa visualization.</p>"},{"location":"reference/viz/utils/","title":"<code>edsteva.viz.utils</code>","text":""},{"location":"reference/viz/utils/#edsteva.viz.utils.save_html","title":"save_html","text":"<pre><code>save_html(obj: alt.Chart, filename: str)\n</code></pre> <p>Save chart in the specified file</p> PARAMETER DESCRIPTION <code>obj</code> <p>Altair chart to be saved</p> <p> TYPE: <code>alt.Chart</code> </p> <code>filename</code> <p>Folder path where to save the chart in HTML format.</p> <p>EXAMPLE: <code>\"my_folder/my_file.html\"</code></p> <p> TYPE: <code>str</code> </p> Source code in <code>edsteva/viz/utils.py</code> <pre><code>def save_html(obj: alt.Chart, filename: str):\n\"\"\"Save chart in the specified file\n\n    Parameters\n    ----------\n    obj : alt.Chart\n        Altair chart to be saved\n    filename : str\n        Folder path where to save the chart in HTML format.\n\n        **EXAMPLE**: `\"my_folder/my_file.html\"`\n    \"\"\"\n    if not isinstance(filename, Path):\n        filename = Path(filename)\n    Path.mkdir(filename.parent, exist_ok=True, parents=True)\n    if hasattr(obj, \"save\"):\n        obj.save(filename)\n    else:\n        with Path.open(filename, \"w\") as f:\n            f.write(obj)\n    logger.info(\"The chart has been saved in {}\", filename)\n</code></pre>"},{"location":"reference/viz/dashboards/","title":"<code>edsteva.viz.dashboards</code>","text":""},{"location":"reference/viz/dashboards/#edsteva.viz.dashboards.probe_dashboard","title":"probe_dashboard","text":"<pre><code>probe_dashboard(\n    probe: BaseProbe,\n    fitted_model: BaseModel = None,\n    care_site_level: List[str] = None,\n    save_path: str = None,\n    legend_predictor: str = \"Predictor c(t)\",\n    legend_model: str = \"Model f(t)\",\n    x_axis_title: str = None,\n    y_axis_title: str = None,\n    main_chart_config: Dict[str, float] = None,\n    model_line_config: Dict[str, str] = None,\n    probe_line_config: Dict[str, str] = None,\n    vertical_bar_charts_config: Dict[str, str] = None,\n    horizontal_bar_charts_config: Dict[str, str] = None,\n    time_line_config: Dict[str, str] = None,\n    chart_style: Dict[str, float] = None,\n    **kwargs\n)\n</code></pre> <p>Displays an interactive chart with:</p> <ul> <li>On the top, the aggregated average completeness predictor \\(c(t)\\) over time \\(t\\) with the fitted model \\(\\hat{c}(t)\\) if specified.</li> <li>On the bottom, interactive filters including all the concepts in the Probe (such as time, care site, number of visits...etc.)</li> </ul> <p>Is is possible to save the chart in HTML with the \"save_path\" optional input.</p> PARAMETER DESCRIPTION <code>probe</code> <p>Class describing the completeness predictor \\(c(t)\\).</p> <p> TYPE: <code>BaseProbe</code> </p> <code>fitted_model</code> <p>Model fitted to the probe.</p> <p> TYPE: <code>BaseModel</code> DEFAULT: <code>None</code> </p> <code>care_site_level</code> <p>EXAMPLE: <code>[\"Hospital\"]</code>, <code>[\"H\u00f4pital\", \"UF\"]</code> or <code>[\"UF\", \"UH\"]</code></p> <p> TYPE: <code>List[str]</code> DEFAULT: <code>None</code> </p> <code>save_path</code> <p>Folder path where to save the chart in HTML format.</p> <p>EXAMPLE: <code>\"my_folder/my_file.html\"</code></p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> <code>legend_predictor</code> <p>Label name for the predictor legend.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'Predictor c(t)'</code> </p> <code>legend_model</code> <p>Label name for the model legend.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'Model f(t)'</code> </p> <code>x_axis_title</code> <p>Label name for the x axis.</p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> <code>y_axis_title</code> <p>Label name for the y axis.</p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> <code>main_chart_config</code> <p>If not None, configuration used to construct the top main chart.</p> <p> TYPE: <code>Dict[str, float]</code> DEFAULT: <code>None</code> </p> <code>model_line_config</code> <p>If not None, configuration used to construct the model line.</p> <p> TYPE: <code>Dict[str, str]</code> DEFAULT: <code>None</code> </p> <code>probe_line_config</code> <p>If not None, configuration used to construct the probe line.</p> <p> TYPE: <code>Dict[str, str]</code> DEFAULT: <code>None</code> </p> <code>vertical_bar_charts_config</code> <p>If not None, configuration used to construct the vertical bar charts.</p> <p> TYPE: <code>Dict[str, str]</code> DEFAULT: <code>None</code> </p> <code>horizontal_bar_charts_config</code> <p>If not None, configuration used to construct the horizontal bar charts.</p> <p> TYPE: <code>Dict[str, str]</code> DEFAULT: <code>None</code> </p> <code>time_line_config</code> <p>If not None, configuration used to construct the time line.</p> <p> TYPE: <code>Dict[str, str]</code> DEFAULT: <code>None</code> </p> <code>chart_style</code> <p>If not None, configuration used to configure the chart style.</p> <p>EXAMPLE: <code>{\"labelFontSize\": 13, \"titleFontSize\": 14}</code></p> <p> TYPE: <code>Dict[str, float]</code> DEFAULT: <code>None</code> </p> Source code in <code>edsteva/viz/dashboards/probe/wrapper.py</code> <pre><code>def probe_dashboard(\n    probe: BaseProbe,\n    fitted_model: BaseModel = None,\n    care_site_level: List[str] = None,\n    save_path: str = None,\n    legend_predictor: str = \"Predictor c(t)\",\n    legend_model: str = \"Model f(t)\",\n    x_axis_title: str = None,\n    y_axis_title: str = None,\n    main_chart_config: Dict[str, float] = None,\n    model_line_config: Dict[str, str] = None,\n    probe_line_config: Dict[str, str] = None,\n    vertical_bar_charts_config: Dict[str, str] = None,\n    horizontal_bar_charts_config: Dict[str, str] = None,\n    time_line_config: Dict[str, str] = None,\n    chart_style: Dict[str, float] = None,\n    **kwargs,\n):\nr\"\"\"Displays an interactive chart with:\n\n    - On the top, the aggregated average completeness predictor $c(t)$ over time $t$ with the fitted model $\\hat{c}(t)$ if specified.\n    - On the bottom, interactive filters including all the concepts in the [Probe][probe] (such as time, care site, number of visits...etc.)\n\n    Is is possible to save the chart in HTML with the \"save_path\" optional input.\n\n    Parameters\n    ----------\n    probe : BaseProbe\n        Class describing the completeness predictor $c(t)$.\n    fitted_model : BaseModel, optional\n        Model fitted to the probe.\n    care_site_level : List[str], optional\n        **EXAMPLE**: `[\"Hospital\"]`, `[\"H\u00f4pital\", \"UF\"]` or `[\"UF\", \"UH\"]`\n    save_path : str, optional\n        Folder path where to save the chart in HTML format.\n\n        **EXAMPLE**: `\"my_folder/my_file.html\"`\n    legend_predictor: str, optional,\n        Label name for the predictor legend.\n    legend_model: str, optional,\n        Label name for the model legend.\n    x_axis_title: str, optional,\n        Label name for the x axis.\n    y_axis_title: str, optional,\n        Label name for the y axis.\n    main_chart_config: Dict[str, str], optional\n        If not None, configuration used to construct the top main chart.\n    model_line_config: Dict[str, str], optional\n        If not None, configuration used to construct the model line.\n    probe_line_config: Dict[str, str], optional\n        If not None, configuration used to construct the probe line.\n    vertical_bar_charts_config: Dict[str, str], optional\n        If not None, configuration used to construct the vertical bar charts.\n    horizontal_bar_charts_config: Dict[str, str], optional\n        If not None, configuration used to construct the horizontal bar charts.\n    time_line_config: Dict[str, str], optional\n        If not None, configuration used to construct the time line.\n    chart_style: Dict[str, float], optional\n        If not None, configuration used to configure the chart style.\n\n        **EXAMPLE**: `{\"labelFontSize\": 13, \"titleFontSize\": 14}`\n    \"\"\"\n\n    alt.data_transformers.enable(\"default\")\n    alt.data_transformers.disable_max_rows()\n\n    probe_config = deepcopy(probe.get_viz_config(\"probe_dashboard\"))\n    if fitted_model:\n        model_config = deepcopy(fitted_model.get_viz_config(\"probe_dashboard\"))\n        if model_line_config is None:\n            model_line_config = model_config[\"model_line\"]\n        if probe_line_config is None:\n            probe_line_config = model_config[\"probe_line\"]\n    if main_chart_config is None:\n        main_chart_config = probe_config[\"main_chart\"]\n    if time_line_config is None:\n        time_line_config = probe_config[\"time_line\"]\n    if vertical_bar_charts_config is None:\n        vertical_bar_charts_config = probe_config[\"vertical_bar_charts\"]\n        if fitted_model:\n            vertical_bar_charts_config[\"y\"] = (\n                vertical_bar_charts_config[\"y\"]\n                + model_config[\"extra_vertical_bar_charts\"]\n            )\n    if horizontal_bar_charts_config is None:\n        horizontal_bar_charts_config = probe_config[\"horizontal_bar_charts\"]\n        if fitted_model:\n            horizontal_bar_charts_config[\"x\"] = (\n                horizontal_bar_charts_config[\"x\"]\n                + model_config[\"extra_horizontal_bar_charts\"]\n            )\n    if chart_style is None:\n        chart_style = probe_config[\"chart_style\"]\n\n    predictor = fitted_model.predict(probe) if fitted_model else probe.predictor.copy()\n    predictor = filter_data(\n        data=predictor,\n        care_site_level=care_site_level,\n        **kwargs,\n    )\n\n    if fitted_model:\n        chart = fitted_probe_dashboard(\n            predictor=predictor,\n            legend_predictor=legend_predictor,\n            legend_model=legend_model,\n            x_axis_title=x_axis_title,\n            y_axis_title=y_axis_title,\n            main_chart_config=main_chart_config,\n            model_line_config=model_line_config,\n            probe_line_config=probe_line_config,\n            vertical_bar_charts_config=vertical_bar_charts_config,\n            horizontal_bar_charts_config=horizontal_bar_charts_config,\n            time_line_config=time_line_config,\n            chart_style=chart_style,\n        )\n    else:\n        chart = probe_only_dashboard(\n            predictor=predictor,\n            x_axis_title=x_axis_title,\n            y_axis_title=y_axis_title,\n            main_chart_config=main_chart_config,\n            vertical_bar_charts_config=vertical_bar_charts_config,\n            horizontal_bar_charts_config=horizontal_bar_charts_config,\n            time_line_config=time_line_config,\n            chart_style=chart_style,\n        )\n\n    vis_probe = \"id\" + uuid.uuid4().hex\n    new_index_probe_id = \"id\" + uuid.uuid4().hex\n    old_index_probe_id = \"id\" + uuid.uuid4().hex\n    left_shift = \"145px\" if fitted_model else \"45px\"\n    html_chart = f\"\"\"\n        &lt;!DOCTYPE html&gt;\n        &lt;html&gt;\n        &lt;head&gt;\n          &lt;script src=\"https://cdn.jsdelivr.net/npm/vega@{alt.VEGA_VERSION}\"&gt;&lt;/script&gt;\n          &lt;script src=\"https://cdn.jsdelivr.net/npm/vega-lite@{alt.VEGALITE_VERSION}\"&gt;&lt;/script&gt;\n          &lt;script src=\"https://cdn.jsdelivr.net/npm/vega-embed@{alt.VEGAEMBED_VERSION}\"&gt;&lt;/script&gt;\n        &lt;/head&gt;\n        &lt;body&gt;\n\n        &lt;div class=\"container\"&gt;\n          &lt;div class=\"row\"&gt;\n            &lt;div&gt;\n            &lt;div id={vis_probe}&gt;&lt;/div&gt;\n            &lt;/div&gt;\n            &lt;div style=\"position:absolute;left:{left_shift};top:380px;width: -webkit-fill-available;\"&gt;\n            &lt;div id={new_index_probe_id}&gt;\n              &lt;div id={old_index_probe_id}&gt;&lt;/div&gt;\n            &lt;/div&gt;\n            &lt;hr/&gt;\n            &lt;h1 style=\"text-align:center\"&gt; Interactive filters &lt;/h1&gt;\n            &lt;/div&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n\n        &lt;script type=\"text/javascript\"&gt;\n        vegaEmbed('#{vis_probe}', {chart.to_json(indent=None)}).then(function(result) {{\n            const sliders = document.getElementsByClassName('vega-bindings');\n            const newparent = document.getElementById('{new_index_probe_id}');\n            const oldchild = document.getElementById('{old_index_probe_id}');\n            for (var i = 0; i &lt; sliders.length; i++) {{\n                if (sliders[i].parentElement.parentElement.id == '{vis_probe}') {{\n                    var index_slider = sliders[i]\n}}\n}}\n            newparent.replaceChild(index_slider, oldchild);\n}}).catch(console.error);\n        &lt;/script&gt;\n        &lt;/body&gt;\n        &lt;/html&gt;\n        \"\"\"\n    if save_path:\n        save_html(\n            obj=html_chart,\n            filename=save_path,\n        )\n    else:\n        display(HTML(html_chart))\n</code></pre>"},{"location":"reference/viz/dashboards/#edsteva.viz.dashboards.normalized_probe_dashboard","title":"normalized_probe_dashboard","text":"<pre><code>normalized_probe_dashboard(\n    probe: BaseProbe,\n    fitted_model: BaseModel,\n    care_site_level: List[str] = None,\n    save_path: str = None,\n    x_axis_title: str = None,\n    y_axis_title: str = None,\n    main_chart_config: Dict[str, str] = None,\n    model_line_config: Dict[str, str] = None,\n    error_line_config: Dict[str, str] = None,\n    probe_line_config: Dict[str, str] = None,\n    estimates_selections: Dict[str, str] = None,\n    estimates_filters: Dict[str, str] = None,\n    vertical_bar_charts_config: Dict[str, str] = None,\n    horizontal_bar_charts_config: Dict[str, str] = None,\n    time_line_config: Dict[str, str] = None,\n    chart_style: Dict[str, float] = None,\n    indexes_to_remove: List[str] = [\n        \"care_site_id\",\n        \"care_site_level\",\n    ],\n    **kwargs\n)\n</code></pre> <p>Displays an interactive chart with:</p> <ul> <li>On the top, the aggregated normalized completeness predictor \\(\\frac{c(\\Delta t)}{c_0}\\) over normalized time \\(\\Delta t = t - t_0\\). It represents the overall deviation from the Model.</li> <li>On the bottom, interactive filters including all the columns in the Probe (such as time, care site, number of visits...etc.) and all the estimates (coefficients and metrics) in the Model.</li> </ul> <p>Is is possible to save the chart in HTML with the \"save_path\" optional input.</p> PARAMETER DESCRIPTION <code>probe</code> <p>Class describing the completeness predictor \\(c(t)\\)</p> <p> TYPE: <code>BaseProbe</code> </p> <code>fitted_model</code> <p>Model fitted to the probe</p> <p> TYPE: <code>BaseModel</code> </p> <code>care_site_level</code> <p>EXAMPLE: <code>[\"Hospital\"]</code>, <code>[\"H\u00f4pital\", \"UF\"]</code> or <code>[\"UF\", \"UH\"]</code></p> <p> TYPE: <code>List[str]</code> DEFAULT: <code>None</code> </p> <code>save_path</code> <p>Folder path where to save the chart in HTML format.</p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> <code>x_axis_title</code> <p>Label name for the x axis.</p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> <code>y_axis_title</code> <p>Label name for the y axis.</p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> <code>main_chart_config</code> <p>If not None, configuration used to construct the top main chart.</p> <p> TYPE: <code>Dict[str, str]</code> DEFAULT: <code>None</code> </p> <code>model_line_config</code> <p>If not None, configuration used to construct the model line.</p> <p> TYPE: <code>Dict[str, str]</code> DEFAULT: <code>None</code> </p> <code>error_line_config</code> <p>If not None, configuration used to construct the error line.</p> <p> TYPE: <code>Dict[str, str]</code> DEFAULT: <code>None</code> </p> <code>probe_line_config</code> <p>If not None, configuration used to construct the probe line.</p> <p> TYPE: <code>Dict[str, str]</code> DEFAULT: <code>None</code> </p> <code>estimates_selections</code> <p>If not None, configuration used to construct the estimates selections.</p> <p> TYPE: <code>Dict[str, str]</code> DEFAULT: <code>None</code> </p> <code>estimates_filters</code> <p>If not None, configuration used to construct the estimates filters.</p> <p> TYPE: <code>Dict[str, str]</code> DEFAULT: <code>None</code> </p> <code>vertical_bar_charts_config</code> <p>If not None, configuration used to construct the vertical bar charts.</p> <p> TYPE: <code>Dict[str, str]</code> DEFAULT: <code>None</code> </p> <code>horizontal_bar_charts_config</code> <p>If not None, configuration used to construct the horizontal bar charts.</p> <p> TYPE: <code>Dict[str, str]</code> DEFAULT: <code>None</code> </p> <code>time_line_config</code> <p>If not None, configuration used to construct the time line.</p> <p> TYPE: <code>Dict[str, str]</code> DEFAULT: <code>None</code> </p> <code>chart_style</code> <p>If not None, configuration used to configure the chart style. EXAMPLE: <code>{\"labelFontSize\": 13, \"titleFontSize\": 14}</code></p> <p> TYPE: <code>Dict[str, float]</code> DEFAULT: <code>None</code> </p> <code>indexes_to_remove</code> <p>indexes to remove from the groupby selection.</p> <p> TYPE: <code>List[str]</code> DEFAULT: <code>['care_site_id', 'care_site_level']</code> </p> Source code in <code>edsteva/viz/dashboards/normalized_probe/normalized_probe.py</code> <pre><code>def normalized_probe_dashboard(\n    probe: BaseProbe,\n    fitted_model: BaseModel,\n    care_site_level: List[str] = None,\n    save_path: str = None,\n    x_axis_title: str = None,\n    y_axis_title: str = None,\n    main_chart_config: Dict[str, str] = None,\n    model_line_config: Dict[str, str] = None,\n    error_line_config: Dict[str, str] = None,\n    probe_line_config: Dict[str, str] = None,\n    estimates_selections: Dict[str, str] = None,\n    estimates_filters: Dict[str, str] = None,\n    vertical_bar_charts_config: Dict[str, str] = None,\n    horizontal_bar_charts_config: Dict[str, str] = None,\n    time_line_config: Dict[str, str] = None,\n    chart_style: Dict[str, float] = None,\n    indexes_to_remove: List[str] = [\"care_site_id\", \"care_site_level\"],\n    **kwargs,\n):\nr\"\"\"Displays an interactive chart with:\n\n    - On the top, the aggregated normalized completeness predictor $\\frac{c(\\Delta t)}{c_0}$ over normalized time $\\Delta t = t - t_0$. It represents the overall deviation from the Model.\n    - On the bottom, interactive filters including all the columns in the [Probe][probe] (such as time, care site, number of visits...etc.) and all the estimates (coefficients and metrics) in the [Model][model].\n\n    Is is possible to save the chart in HTML with the \"save_path\" optional input.\n\n    Parameters\n    ----------\n    probe : BaseProbe\n        Class describing the completeness predictor $c(t)$\n    fitted_model : BaseModel\n        Model fitted to the probe\n    care_site_level : List[str], optional\n        **EXAMPLE**: `[\"Hospital\"]`, `[\"H\u00f4pital\", \"UF\"]` or `[\"UF\", \"UH\"]`\n    save_path : str, optional\n        Folder path where to save the chart in HTML format.\n    x_axis_title: str, optional,\n        Label name for the x axis.\n    y_axis_title: str, optional,\n        Label name for the y axis.\n    main_chart_config: Dict[str, str], optional\n        If not None, configuration used to construct the top main chart.\n    model_line_config: Dict[str, str], optional\n        If not None, configuration used to construct the model line.\n    error_line_config: Dict[str, str], optional\n        If not None, configuration used to construct the error line.\n    probe_line_config: Dict[str, str], optional\n        If not None, configuration used to construct the probe line.\n    estimates_selections: Dict[str, str], optional\n        If not None, configuration used to construct the estimates selections.\n    estimates_filters: Dict[str, str], optional\n        If not None, configuration used to construct the estimates filters.\n    vertical_bar_charts_config: Dict[str, str], optional\n        If not None, configuration used to construct the vertical bar charts.\n    horizontal_bar_charts_config: Dict[str, str], optional\n        If not None, configuration used to construct the horizontal bar charts.\n    time_line_config: Dict[str, str], optional\n        If not None, configuration used to construct the time line.\n    chart_style: Dict[str, float], optional\n        If not None, configuration used to configure the chart style.\n        **EXAMPLE**: `{\"labelFontSize\": 13, \"titleFontSize\": 14}`\n    indexes_to_remove: List[str], optional\n        indexes to remove from the groupby selection.\n    \"\"\"\n    alt.data_transformers.disable_max_rows()\n\n    # Pre-processing\n    predictor = probe.predictor.copy()\n    estimates = fitted_model.estimates.copy()\n    predictor_metrics = probe._metrics.copy()\n    indexes = get_indexes_to_groupby(\n        predictor_columns=predictor.columns,\n        predictor_metrics=predictor_metrics,\n        indexes_to_remove=indexes_to_remove,\n    )\n    predictor = predictor.merge(estimates, on=probe._index)\n    predictor[\"normalized_date\"] = month_diff(\n        predictor[\"date\"], predictor[\"t_0\"]\n    ).astype(int)\n    for estimate in fitted_model._coefs + fitted_model._metrics:\n        if pd.api.types.is_datetime64_any_dtype(predictor[estimate]):\n            predictor[estimate] = predictor[estimate].dt.strftime(\"%Y-%m\")\n    predictor[\"normalized_c\"] = predictor[\"c\"].where(\n        (predictor[\"normalized_date\"] &lt; 0) | (predictor[\"c_0\"] == 0),\n        predictor[\"c\"] / predictor[\"c_0\"],\n    )\n    predictor[\"model\"] = 1\n    predictor[\"model\"] = predictor[\"model\"].where(predictor[\"normalized_date\"] &gt;= 0, 0)\n    predictor = filter_data(data=predictor, care_site_level=care_site_level, **kwargs)\n\n    # Get viz config\n    probe_config = deepcopy(probe.get_viz_config(\"normalized_probe_dashboard\"))\n    model_config = deepcopy(\n        fitted_model.get_viz_config(\"normalized_probe_dashboard\", predictor=predictor)\n    )\n    if main_chart_config is None:\n        main_chart_config = probe_config[\"main_chart\"]\n    if time_line_config is None:\n        time_line_config = probe_config[\"time_line\"]\n    if vertical_bar_charts_config is None:\n        vertical_bar_charts_config = probe_config[\"vertical_bar_charts\"]\n        vertical_bar_charts_config[\"y\"] = (\n            vertical_bar_charts_config[\"y\"] + model_config[\"extra_vertical_bar_charts\"]\n        )\n    if horizontal_bar_charts_config is None:\n        horizontal_bar_charts_config = probe_config[\"horizontal_bar_charts\"]\n        horizontal_bar_charts_config[\"x\"] = (\n            horizontal_bar_charts_config[\"x\"]\n            + model_config[\"extra_horizontal_bar_charts\"]\n        )\n    if chart_style is None:\n        chart_style = probe_config[\"chart_style\"]\n    if probe_line_config is None:\n        probe_line_config = model_config[\"probe_line\"]\n    if model_line_config is None:\n        model_line_config = model_config[\"model_line\"]\n    if error_line_config is None:\n        error_line_config = model_config[\"error_line\"]\n    if estimates_selections is None:\n        estimates_selections = model_config[\"estimates_selections\"]\n    if estimates_filters is None:\n        estimates_filters = model_config[\"estimates_filters\"]\n\n    # Viz\n    predictor[\"legend_model\"] = (\n        model_line_config.get(\"legend_title\")\n        if model_line_config.get(\"legend_title\")\n        else type(fitted_model).__name__\n    )\n    predictor[\"legend_predictor\"] = probe_line_config[\"legend_title\"]\n    predictor[\"legend_error_band\"] = error_line_config[\"legend_title\"]\n    base = alt.Chart(predictor)\n    time_line, time_selection = generate_time_line(\n        base=base,\n        time_line_config=time_line_config,\n    )\n\n    horizontal_bar_charts, y_variables_selections = generate_horizontal_bar_charts(\n        base=base,\n        horizontal_bar_charts_config=horizontal_bar_charts_config,\n        predictor=predictor,\n    )\n    vertical_bar_charts, x_variables_selections = generate_vertical_bar_charts(\n        base=base,\n        vertical_bar_charts_config=vertical_bar_charts_config,\n        predictor=predictor,\n    )\n    selections = dict(\n        date=time_selection,\n        **y_variables_selections,\n        **x_variables_selections,\n    )\n    selection_charts = dict(\n        horizontal_bar_charts,\n        **vertical_bar_charts,\n    )\n    base = add_interactive_selection(\n        base=base,\n        selection_charts=selection_charts,\n        selections=selections,\n    )\n    base = add_estimates_filters(\n        base=base,\n        selection_charts=selection_charts,\n        estimates_filters=estimates_filters,\n    )\n    index_selection, index_fields = create_groupby_selection(\n        indexes=indexes,\n        predictor=predictor,\n    )\n    main_chart = generate_main_chart(\n        base=base,\n        main_chart_config=main_chart_config,\n        index_selection=index_selection,\n        index_fields=index_fields,\n        x_axis_title=x_axis_title,\n        y_axis_title=y_axis_title,\n    )\n    probe_line = generate_probe_line(\n        main_chart=main_chart, probe_line_config=probe_line_config\n    )\n    error_line = generate_error_line(\n        main_chart=main_chart, error_line_config=error_line_config\n    )\n    model_line = generate_model_line(\n        main_chart=main_chart, model_line_config=model_line_config\n    )\n\n    main_chart = probe_line + error_line + model_line\n    if index_selection:\n        main_chart = main_chart.add_params(index_selection)\n    chart = concatenate_charts(\n        main_chart=main_chart,\n        time_line=time_line,\n        horizontal_bar_charts=horizontal_bar_charts,\n        vertical_bar_charts=vertical_bar_charts,\n        spacing=0,\n    )\n    chart = configure_style(chart=chart, chart_style=chart_style)\n    for estimate_selection in estimates_selections:\n        chart = chart.add_params(estimate_selection)\n\n    vis_threshold = \"id\" + uuid.uuid4().hex\n    new_sliders_threshold_id = \"id\" + uuid.uuid4().hex\n    old_sliders_threshold_id = \"id\" + uuid.uuid4().hex\n    new_index_threshold_id = \"id\" + uuid.uuid4().hex\n    old_index_threshold_id = \"id\" + uuid.uuid4().hex\n    html_chart = f\"\"\"\n        &lt;!DOCTYPE html&gt;\n        &lt;html&gt;\n        &lt;head&gt;\n          &lt;script src=\"https://cdn.jsdelivr.net/npm/vega@{alt.VEGA_VERSION}\"&gt;&lt;/script&gt;\n          &lt;script src=\"https://cdn.jsdelivr.net/npm/vega-lite@{alt.VEGALITE_VERSION}\"&gt;&lt;/script&gt;\n          &lt;script src=\"https://cdn.jsdelivr.net/npm/vega-embed@{alt.VEGAEMBED_VERSION}\"&gt;&lt;/script&gt;\n        &lt;/head&gt;\n        &lt;body&gt;\n\n        &lt;div class=\"container\"&gt;\n          &lt;div class=\"row\"&gt;\n            &lt;div&gt;\n            &lt;div id={vis_threshold}&gt;&lt;/div&gt;\n            &lt;/div&gt;\n            &lt;div style=\"position:absolute;left:1000px;top:540px;width: -webkit-fill-available;\"&gt;\n            &lt;div id={new_sliders_threshold_id}&gt;\n              &lt;div id={old_sliders_threshold_id}&gt;&lt;/div&gt;\n            &lt;/div&gt;\n            &lt;/div&gt;\n            &lt;div style=\"position:absolute;left:45px;top:410px;width: -webkit-fill-available;\"&gt;\n            &lt;div id={new_index_threshold_id}&gt;\n              &lt;div id={old_index_threshold_id}&gt;&lt;/div&gt;\n            &lt;/div&gt;\n            &lt;hr/&gt;\n            &lt;h1 style=\"text-align:center\"&gt; Interactive filters &lt;/h1&gt;\n            &lt;/div&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n\n        &lt;script type=\"text/javascript\"&gt;\n        vegaEmbed('#{vis_threshold}', {chart.to_json(indent=None)}).then(function(result) {{\n            const sliders = document.getElementsByClassName('vega-bindings');\n            const newestimate = document.getElementById('{new_sliders_threshold_id}');\n            const oldestimate = document.getElementById('{old_sliders_threshold_id}');\n            const newparent = document.getElementById('{new_index_threshold_id}');\n            const oldchild = document.getElementById('{old_index_threshold_id}');\n            for (var i = 0; i &lt; sliders.length; i++) {{\n                if (sliders[i].parentElement.parentElement.id == '{vis_threshold}') {{\n                    var estimate_slider = sliders[i]\n                    var index_slider = estimate_slider.querySelectorAll(\".vega-bind\")\n}}\n}}\n            newestimate.replaceChild(estimate_slider, oldestimate);\n            for (var i = 0; i &lt; index_slider.length; i++) {{\n                if (index_slider[i].firstChild.innerHTML == \"Group by: \") {{\n                    var index_color = index_slider[i]}}\n}}\n            newparent.replaceChild(index_color, oldchild);\n}}).catch(console.error);\n        &lt;/script&gt;\n        &lt;/body&gt;\n        &lt;/html&gt;\n        \"\"\"\n    display(HTML(html_chart))\n    if save_path:\n        save_html(\n            obj=html_chart,\n            filename=save_path,\n        )\n</code></pre>"},{"location":"reference/viz/dashboards/normalized_probe/","title":"<code>edsteva.viz.dashboards.normalized_probe</code>","text":""},{"location":"reference/viz/dashboards/normalized_probe/normalized_probe/","title":"<code>edsteva.viz.dashboards.normalized_probe.normalized_probe</code>","text":""},{"location":"reference/viz/dashboards/normalized_probe/normalized_probe/#edsteva.viz.dashboards.normalized_probe.normalized_probe.normalized_probe_dashboard","title":"normalized_probe_dashboard","text":"<pre><code>normalized_probe_dashboard(\n    probe: BaseProbe,\n    fitted_model: BaseModel,\n    care_site_level: List[str] = None,\n    save_path: str = None,\n    x_axis_title: str = None,\n    y_axis_title: str = None,\n    main_chart_config: Dict[str, str] = None,\n    model_line_config: Dict[str, str] = None,\n    error_line_config: Dict[str, str] = None,\n    probe_line_config: Dict[str, str] = None,\n    estimates_selections: Dict[str, str] = None,\n    estimates_filters: Dict[str, str] = None,\n    vertical_bar_charts_config: Dict[str, str] = None,\n    horizontal_bar_charts_config: Dict[str, str] = None,\n    time_line_config: Dict[str, str] = None,\n    chart_style: Dict[str, float] = None,\n    indexes_to_remove: List[str] = [\n        \"care_site_id\",\n        \"care_site_level\",\n    ],\n    **kwargs\n)\n</code></pre> <p>Displays an interactive chart with:</p> <ul> <li>On the top, the aggregated normalized completeness predictor \\(\\frac{c(\\Delta t)}{c_0}\\) over normalized time \\(\\Delta t = t - t_0\\). It represents the overall deviation from the Model.</li> <li>On the bottom, interactive filters including all the columns in the Probe (such as time, care site, number of visits...etc.) and all the estimates (coefficients and metrics) in the Model.</li> </ul> <p>Is is possible to save the chart in HTML with the \"save_path\" optional input.</p> PARAMETER DESCRIPTION <code>probe</code> <p>Class describing the completeness predictor \\(c(t)\\)</p> <p> TYPE: <code>BaseProbe</code> </p> <code>fitted_model</code> <p>Model fitted to the probe</p> <p> TYPE: <code>BaseModel</code> </p> <code>care_site_level</code> <p>EXAMPLE: <code>[\"Hospital\"]</code>, <code>[\"H\u00f4pital\", \"UF\"]</code> or <code>[\"UF\", \"UH\"]</code></p> <p> TYPE: <code>List[str]</code> DEFAULT: <code>None</code> </p> <code>save_path</code> <p>Folder path where to save the chart in HTML format.</p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> <code>x_axis_title</code> <p>Label name for the x axis.</p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> <code>y_axis_title</code> <p>Label name for the y axis.</p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> <code>main_chart_config</code> <p>If not None, configuration used to construct the top main chart.</p> <p> TYPE: <code>Dict[str, str]</code> DEFAULT: <code>None</code> </p> <code>model_line_config</code> <p>If not None, configuration used to construct the model line.</p> <p> TYPE: <code>Dict[str, str]</code> DEFAULT: <code>None</code> </p> <code>error_line_config</code> <p>If not None, configuration used to construct the error line.</p> <p> TYPE: <code>Dict[str, str]</code> DEFAULT: <code>None</code> </p> <code>probe_line_config</code> <p>If not None, configuration used to construct the probe line.</p> <p> TYPE: <code>Dict[str, str]</code> DEFAULT: <code>None</code> </p> <code>estimates_selections</code> <p>If not None, configuration used to construct the estimates selections.</p> <p> TYPE: <code>Dict[str, str]</code> DEFAULT: <code>None</code> </p> <code>estimates_filters</code> <p>If not None, configuration used to construct the estimates filters.</p> <p> TYPE: <code>Dict[str, str]</code> DEFAULT: <code>None</code> </p> <code>vertical_bar_charts_config</code> <p>If not None, configuration used to construct the vertical bar charts.</p> <p> TYPE: <code>Dict[str, str]</code> DEFAULT: <code>None</code> </p> <code>horizontal_bar_charts_config</code> <p>If not None, configuration used to construct the horizontal bar charts.</p> <p> TYPE: <code>Dict[str, str]</code> DEFAULT: <code>None</code> </p> <code>time_line_config</code> <p>If not None, configuration used to construct the time line.</p> <p> TYPE: <code>Dict[str, str]</code> DEFAULT: <code>None</code> </p> <code>chart_style</code> <p>If not None, configuration used to configure the chart style. EXAMPLE: <code>{\"labelFontSize\": 13, \"titleFontSize\": 14}</code></p> <p> TYPE: <code>Dict[str, float]</code> DEFAULT: <code>None</code> </p> <code>indexes_to_remove</code> <p>indexes to remove from the groupby selection.</p> <p> TYPE: <code>List[str]</code> DEFAULT: <code>['care_site_id', 'care_site_level']</code> </p> Source code in <code>edsteva/viz/dashboards/normalized_probe/normalized_probe.py</code> <pre><code>def normalized_probe_dashboard(\n    probe: BaseProbe,\n    fitted_model: BaseModel,\n    care_site_level: List[str] = None,\n    save_path: str = None,\n    x_axis_title: str = None,\n    y_axis_title: str = None,\n    main_chart_config: Dict[str, str] = None,\n    model_line_config: Dict[str, str] = None,\n    error_line_config: Dict[str, str] = None,\n    probe_line_config: Dict[str, str] = None,\n    estimates_selections: Dict[str, str] = None,\n    estimates_filters: Dict[str, str] = None,\n    vertical_bar_charts_config: Dict[str, str] = None,\n    horizontal_bar_charts_config: Dict[str, str] = None,\n    time_line_config: Dict[str, str] = None,\n    chart_style: Dict[str, float] = None,\n    indexes_to_remove: List[str] = [\"care_site_id\", \"care_site_level\"],\n    **kwargs,\n):\nr\"\"\"Displays an interactive chart with:\n\n    - On the top, the aggregated normalized completeness predictor $\\frac{c(\\Delta t)}{c_0}$ over normalized time $\\Delta t = t - t_0$. It represents the overall deviation from the Model.\n    - On the bottom, interactive filters including all the columns in the [Probe][probe] (such as time, care site, number of visits...etc.) and all the estimates (coefficients and metrics) in the [Model][model].\n\n    Is is possible to save the chart in HTML with the \"save_path\" optional input.\n\n    Parameters\n    ----------\n    probe : BaseProbe\n        Class describing the completeness predictor $c(t)$\n    fitted_model : BaseModel\n        Model fitted to the probe\n    care_site_level : List[str], optional\n        **EXAMPLE**: `[\"Hospital\"]`, `[\"H\u00f4pital\", \"UF\"]` or `[\"UF\", \"UH\"]`\n    save_path : str, optional\n        Folder path where to save the chart in HTML format.\n    x_axis_title: str, optional,\n        Label name for the x axis.\n    y_axis_title: str, optional,\n        Label name for the y axis.\n    main_chart_config: Dict[str, str], optional\n        If not None, configuration used to construct the top main chart.\n    model_line_config: Dict[str, str], optional\n        If not None, configuration used to construct the model line.\n    error_line_config: Dict[str, str], optional\n        If not None, configuration used to construct the error line.\n    probe_line_config: Dict[str, str], optional\n        If not None, configuration used to construct the probe line.\n    estimates_selections: Dict[str, str], optional\n        If not None, configuration used to construct the estimates selections.\n    estimates_filters: Dict[str, str], optional\n        If not None, configuration used to construct the estimates filters.\n    vertical_bar_charts_config: Dict[str, str], optional\n        If not None, configuration used to construct the vertical bar charts.\n    horizontal_bar_charts_config: Dict[str, str], optional\n        If not None, configuration used to construct the horizontal bar charts.\n    time_line_config: Dict[str, str], optional\n        If not None, configuration used to construct the time line.\n    chart_style: Dict[str, float], optional\n        If not None, configuration used to configure the chart style.\n        **EXAMPLE**: `{\"labelFontSize\": 13, \"titleFontSize\": 14}`\n    indexes_to_remove: List[str], optional\n        indexes to remove from the groupby selection.\n    \"\"\"\n    alt.data_transformers.disable_max_rows()\n\n    # Pre-processing\n    predictor = probe.predictor.copy()\n    estimates = fitted_model.estimates.copy()\n    predictor_metrics = probe._metrics.copy()\n    indexes = get_indexes_to_groupby(\n        predictor_columns=predictor.columns,\n        predictor_metrics=predictor_metrics,\n        indexes_to_remove=indexes_to_remove,\n    )\n    predictor = predictor.merge(estimates, on=probe._index)\n    predictor[\"normalized_date\"] = month_diff(\n        predictor[\"date\"], predictor[\"t_0\"]\n    ).astype(int)\n    for estimate in fitted_model._coefs + fitted_model._metrics:\n        if pd.api.types.is_datetime64_any_dtype(predictor[estimate]):\n            predictor[estimate] = predictor[estimate].dt.strftime(\"%Y-%m\")\n    predictor[\"normalized_c\"] = predictor[\"c\"].where(\n        (predictor[\"normalized_date\"] &lt; 0) | (predictor[\"c_0\"] == 0),\n        predictor[\"c\"] / predictor[\"c_0\"],\n    )\n    predictor[\"model\"] = 1\n    predictor[\"model\"] = predictor[\"model\"].where(predictor[\"normalized_date\"] &gt;= 0, 0)\n    predictor = filter_data(data=predictor, care_site_level=care_site_level, **kwargs)\n\n    # Get viz config\n    probe_config = deepcopy(probe.get_viz_config(\"normalized_probe_dashboard\"))\n    model_config = deepcopy(\n        fitted_model.get_viz_config(\"normalized_probe_dashboard\", predictor=predictor)\n    )\n    if main_chart_config is None:\n        main_chart_config = probe_config[\"main_chart\"]\n    if time_line_config is None:\n        time_line_config = probe_config[\"time_line\"]\n    if vertical_bar_charts_config is None:\n        vertical_bar_charts_config = probe_config[\"vertical_bar_charts\"]\n        vertical_bar_charts_config[\"y\"] = (\n            vertical_bar_charts_config[\"y\"] + model_config[\"extra_vertical_bar_charts\"]\n        )\n    if horizontal_bar_charts_config is None:\n        horizontal_bar_charts_config = probe_config[\"horizontal_bar_charts\"]\n        horizontal_bar_charts_config[\"x\"] = (\n            horizontal_bar_charts_config[\"x\"]\n            + model_config[\"extra_horizontal_bar_charts\"]\n        )\n    if chart_style is None:\n        chart_style = probe_config[\"chart_style\"]\n    if probe_line_config is None:\n        probe_line_config = model_config[\"probe_line\"]\n    if model_line_config is None:\n        model_line_config = model_config[\"model_line\"]\n    if error_line_config is None:\n        error_line_config = model_config[\"error_line\"]\n    if estimates_selections is None:\n        estimates_selections = model_config[\"estimates_selections\"]\n    if estimates_filters is None:\n        estimates_filters = model_config[\"estimates_filters\"]\n\n    # Viz\n    predictor[\"legend_model\"] = (\n        model_line_config.get(\"legend_title\")\n        if model_line_config.get(\"legend_title\")\n        else type(fitted_model).__name__\n    )\n    predictor[\"legend_predictor\"] = probe_line_config[\"legend_title\"]\n    predictor[\"legend_error_band\"] = error_line_config[\"legend_title\"]\n    base = alt.Chart(predictor)\n    time_line, time_selection = generate_time_line(\n        base=base,\n        time_line_config=time_line_config,\n    )\n\n    horizontal_bar_charts, y_variables_selections = generate_horizontal_bar_charts(\n        base=base,\n        horizontal_bar_charts_config=horizontal_bar_charts_config,\n        predictor=predictor,\n    )\n    vertical_bar_charts, x_variables_selections = generate_vertical_bar_charts(\n        base=base,\n        vertical_bar_charts_config=vertical_bar_charts_config,\n        predictor=predictor,\n    )\n    selections = dict(\n        date=time_selection,\n        **y_variables_selections,\n        **x_variables_selections,\n    )\n    selection_charts = dict(\n        horizontal_bar_charts,\n        **vertical_bar_charts,\n    )\n    base = add_interactive_selection(\n        base=base,\n        selection_charts=selection_charts,\n        selections=selections,\n    )\n    base = add_estimates_filters(\n        base=base,\n        selection_charts=selection_charts,\n        estimates_filters=estimates_filters,\n    )\n    index_selection, index_fields = create_groupby_selection(\n        indexes=indexes,\n        predictor=predictor,\n    )\n    main_chart = generate_main_chart(\n        base=base,\n        main_chart_config=main_chart_config,\n        index_selection=index_selection,\n        index_fields=index_fields,\n        x_axis_title=x_axis_title,\n        y_axis_title=y_axis_title,\n    )\n    probe_line = generate_probe_line(\n        main_chart=main_chart, probe_line_config=probe_line_config\n    )\n    error_line = generate_error_line(\n        main_chart=main_chart, error_line_config=error_line_config\n    )\n    model_line = generate_model_line(\n        main_chart=main_chart, model_line_config=model_line_config\n    )\n\n    main_chart = probe_line + error_line + model_line\n    if index_selection:\n        main_chart = main_chart.add_params(index_selection)\n    chart = concatenate_charts(\n        main_chart=main_chart,\n        time_line=time_line,\n        horizontal_bar_charts=horizontal_bar_charts,\n        vertical_bar_charts=vertical_bar_charts,\n        spacing=0,\n    )\n    chart = configure_style(chart=chart, chart_style=chart_style)\n    for estimate_selection in estimates_selections:\n        chart = chart.add_params(estimate_selection)\n\n    vis_threshold = \"id\" + uuid.uuid4().hex\n    new_sliders_threshold_id = \"id\" + uuid.uuid4().hex\n    old_sliders_threshold_id = \"id\" + uuid.uuid4().hex\n    new_index_threshold_id = \"id\" + uuid.uuid4().hex\n    old_index_threshold_id = \"id\" + uuid.uuid4().hex\n    html_chart = f\"\"\"\n        &lt;!DOCTYPE html&gt;\n        &lt;html&gt;\n        &lt;head&gt;\n          &lt;script src=\"https://cdn.jsdelivr.net/npm/vega@{alt.VEGA_VERSION}\"&gt;&lt;/script&gt;\n          &lt;script src=\"https://cdn.jsdelivr.net/npm/vega-lite@{alt.VEGALITE_VERSION}\"&gt;&lt;/script&gt;\n          &lt;script src=\"https://cdn.jsdelivr.net/npm/vega-embed@{alt.VEGAEMBED_VERSION}\"&gt;&lt;/script&gt;\n        &lt;/head&gt;\n        &lt;body&gt;\n\n        &lt;div class=\"container\"&gt;\n          &lt;div class=\"row\"&gt;\n            &lt;div&gt;\n            &lt;div id={vis_threshold}&gt;&lt;/div&gt;\n            &lt;/div&gt;\n            &lt;div style=\"position:absolute;left:1000px;top:540px;width: -webkit-fill-available;\"&gt;\n            &lt;div id={new_sliders_threshold_id}&gt;\n              &lt;div id={old_sliders_threshold_id}&gt;&lt;/div&gt;\n            &lt;/div&gt;\n            &lt;/div&gt;\n            &lt;div style=\"position:absolute;left:45px;top:410px;width: -webkit-fill-available;\"&gt;\n            &lt;div id={new_index_threshold_id}&gt;\n              &lt;div id={old_index_threshold_id}&gt;&lt;/div&gt;\n            &lt;/div&gt;\n            &lt;hr/&gt;\n            &lt;h1 style=\"text-align:center\"&gt; Interactive filters &lt;/h1&gt;\n            &lt;/div&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n\n        &lt;script type=\"text/javascript\"&gt;\n        vegaEmbed('#{vis_threshold}', {chart.to_json(indent=None)}).then(function(result) {{\n            const sliders = document.getElementsByClassName('vega-bindings');\n            const newestimate = document.getElementById('{new_sliders_threshold_id}');\n            const oldestimate = document.getElementById('{old_sliders_threshold_id}');\n            const newparent = document.getElementById('{new_index_threshold_id}');\n            const oldchild = document.getElementById('{old_index_threshold_id}');\n            for (var i = 0; i &lt; sliders.length; i++) {{\n                if (sliders[i].parentElement.parentElement.id == '{vis_threshold}') {{\n                    var estimate_slider = sliders[i]\n                    var index_slider = estimate_slider.querySelectorAll(\".vega-bind\")\n}}\n}}\n            newestimate.replaceChild(estimate_slider, oldestimate);\n            for (var i = 0; i &lt; index_slider.length; i++) {{\n                if (index_slider[i].firstChild.innerHTML == \"Group by: \") {{\n                    var index_color = index_slider[i]}}\n}}\n            newparent.replaceChild(index_color, oldchild);\n}}).catch(console.error);\n        &lt;/script&gt;\n        &lt;/body&gt;\n        &lt;/html&gt;\n        \"\"\"\n    display(HTML(html_chart))\n    if save_path:\n        save_html(\n            obj=html_chart,\n            filename=save_path,\n        )\n</code></pre>"},{"location":"reference/viz/dashboards/probe/","title":"<code>edsteva.viz.dashboards.probe</code>","text":""},{"location":"reference/viz/dashboards/probe/fitted_probe/","title":"<code>edsteva.viz.dashboards.probe.fitted_probe</code>","text":""},{"location":"reference/viz/dashboards/probe/fitted_probe/#edsteva.viz.dashboards.probe.fitted_probe.fitted_probe_dashboard","title":"fitted_probe_dashboard","text":"<pre><code>fitted_probe_dashboard(\n    predictor: pd.DataFrame,\n    legend_predictor: str,\n    legend_model: str,\n    x_axis_title: str,\n    y_axis_title: str,\n    main_chart_config: Dict[str, float],\n    model_line_config: Dict[str, str],\n    probe_line_config: Dict[str, str],\n    vertical_bar_charts_config: Dict[str, str],\n    horizontal_bar_charts_config: Dict[str, str],\n    time_line_config: Dict[str, str],\n    chart_style: Dict[str, float],\n)\n</code></pre> <p>Script to be used by <code>predictor_dashboard()</code></p> PARAMETER DESCRIPTION <code>predictor</code> <p>\\(c(t)\\) computed in the Probe with its prediction \\(\\hat{c}(t)\\)</p> <p> TYPE: <code>pd.DataFrame</code> </p> <code>legend_predictor</code> <p>Label name for the predictor legend.</p> <p> TYPE: <code>str</code> </p> <code>legend_model</code> <p>Label name for the model legend.</p> <p> TYPE: <code>str</code> </p> <code>x_axis_title</code> <p>Label name for the x axis.</p> <p> TYPE: <code>str</code> </p> <code>y_axis_title</code> <p>Label name for the y axis.</p> <p> TYPE: <code>str</code> </p> <code>main_chart_config</code> <p>Configuration used to construct the top main chart.</p> <p> TYPE: <code>Dict[str, float]</code> </p> <code>model_line_config</code> <p>Configuration used to construct the model line.</p> <p> TYPE: <code>Dict[str, str]</code> </p> <code>probe_line_config</code> <p>Configuration used to construct the probe line.</p> <p> TYPE: <code>Dict[str, str]</code> </p> <code>vertical_bar_charts_config</code> <p>Configuration used to construct the vertical bar charts.</p> <p> TYPE: <code>Dict[str, str]</code> </p> <code>horizontal_bar_charts_config</code> <p>Configuration used to construct the horizontal bar charts.</p> <p> TYPE: <code>Dict[str, str]</code> </p> <code>time_line_config</code> <p>Configuration used to construct the time line.</p> <p> TYPE: <code>Dict[str, str]</code> </p> <code>chart_style</code> <p>Configuration used to configure the chart style. EXAMPLE: <code>{\"labelFontSize\": 13, \"titleFontSize\": 14}</code></p> <p> TYPE: <code>Dict[str, float]</code> </p> Source code in <code>edsteva/viz/dashboards/probe/fitted_probe.py</code> <pre><code>def fitted_probe_dashboard(\n    predictor: pd.DataFrame,\n    legend_predictor: str,\n    legend_model: str,\n    x_axis_title: str,\n    y_axis_title: str,\n    main_chart_config: Dict[str, float],\n    model_line_config: Dict[str, str],\n    probe_line_config: Dict[str, str],\n    vertical_bar_charts_config: Dict[str, str],\n    horizontal_bar_charts_config: Dict[str, str],\n    time_line_config: Dict[str, str],\n    chart_style: Dict[str, float],\n):\nr\"\"\"Script to be used by [``predictor_dashboard()``][edsteva.viz.dashboards.probe.wrapper]\n\n    Parameters\n    ----------\n    predictor : pd.DataFrame\n        $c(t)$ computed in the Probe with its prediction $\\hat{c}(t)$\n    legend_predictor: str, optional,\n        Label name for the predictor legend.\n    legend_model: str, optional,\n        Label name for the model legend.\n    x_axis_title: str, optional,\n        Label name for the x axis.\n    y_axis_title: str, optional,\n        Label name for the y axis.\n    main_chart_config: Dict[str, str], optional\n        Configuration used to construct the top main chart.\n    model_line_config: Dict[str, str], optional\n        Configuration used to construct the model line.\n    probe_line_config: Dict[str, str], optional\n        Configuration used to construct the probe line.\n    vertical_bar_charts_config: Dict[str, str], optional\n        Configuration used to construct the vertical bar charts.\n    horizontal_bar_charts_config: Dict[str, str], optional\n        Configuration used to construct the horizontal bar charts.\n    time_line_config: Dict[str, str], optional\n        Configuration used to construct the time line.\n    chart_style: Dict[str, float], optional\n        Configuration used to configure the chart style.\n        **EXAMPLE**: `{\"labelFontSize\": 13, \"titleFontSize\": 14}`\n    \"\"\"\n    predictor[\"legend_predictor\"] = legend_predictor\n    predictor[\"legend_model\"] = legend_model\n\n    base = alt.Chart(predictor)\n    time_line, time_selection = generate_time_line(\n        base=base,\n        time_line_config=time_line_config,\n    )\n    horizontal_bar_charts, y_variables_selections = generate_horizontal_bar_charts(\n        base=base,\n        horizontal_bar_charts_config=horizontal_bar_charts_config,\n        predictor=predictor,\n    )\n    vertical_bar_charts, x_variables_selections = generate_vertical_bar_charts(\n        base=base,\n        vertical_bar_charts_config=vertical_bar_charts_config,\n        predictor=predictor,\n    )\n\n    selections = dict(\n        date=time_selection,\n        **y_variables_selections,\n        **x_variables_selections,\n    )\n    selection_charts = dict(\n        horizontal_bar_charts,\n        **vertical_bar_charts,\n    )\n\n    base = add_interactive_selection(\n        base=base, selection_charts=selection_charts, selections=selections\n    )\n\n    index_selection, index_fields = create_groupby_selection(\n        indexes=vertical_bar_charts_config[\"x\"] + horizontal_bar_charts_config[\"y\"],\n        predictor=predictor,\n    )\n    main_chart = generate_main_chart(\n        base=base,\n        main_chart_config=main_chart_config,\n        index_selection=index_selection,\n        index_fields=index_fields,\n        x_axis_title=x_axis_title,\n        y_axis_title=y_axis_title,\n    )\n\n    probe_line = generate_probe_line(\n        main_chart=main_chart, probe_line_config=probe_line_config\n    )\n\n    model_line = generate_model_line(\n        main_chart=main_chart, model_line_config=model_line_config\n    )\n\n    main_chart = probe_line + model_line\n    if index_selection:\n        main_chart = main_chart.add_params(index_selection)\n    chart = concatenate_charts(\n        main_chart=main_chart,\n        time_line=time_line,\n        horizontal_bar_charts=horizontal_bar_charts,\n        vertical_bar_charts=vertical_bar_charts,\n    )\n    return configure_style(chart=chart, chart_style=chart_style)\n</code></pre>"},{"location":"reference/viz/dashboards/probe/probe/","title":"<code>edsteva.viz.dashboards.probe.probe</code>","text":""},{"location":"reference/viz/dashboards/probe/probe/#edsteva.viz.dashboards.probe.probe.probe_only_dashboard","title":"probe_only_dashboard","text":"<pre><code>probe_only_dashboard(\n    predictor: pd.DataFrame,\n    x_axis_title: str,\n    y_axis_title: str,\n    main_chart_config: Dict[str, float],\n    vertical_bar_charts_config: Dict[str, str],\n    horizontal_bar_charts_config: Dict[str, str],\n    time_line_config: Dict[str, str],\n    chart_style: Dict[str, float],\n)\n</code></pre> <p>Script to be used by <code>predictor_dashboard()</code></p> PARAMETER DESCRIPTION <code>predictor</code> <p>\\(c(t)\\) computed in the Probe.</p> <p> TYPE: <code>pd.DataFrame</code> </p> <code>x_axis_title</code> <p>Label name for the x axis.</p> <p> TYPE: <code>str</code> </p> <code>y_axis_title</code> <p>Label name for the y axis.</p> <p> TYPE: <code>str</code> </p> <code>main_chart_config</code> <p>If not None, configuration used to construct the top main chart.</p> <p> TYPE: <code>Dict[str, float]</code> </p> <code>vertical_bar_charts_config</code> <p>If not None, configuration used to construct the vertical bar charts.</p> <p> TYPE: <code>Dict[str, str]</code> </p> <code>horizontal_bar_charts_config</code> <p>If not None, configuration used to construct the horizontal bar charts.</p> <p> TYPE: <code>Dict[str, str]</code> </p> <code>time_line_config</code> <p>If not None, configuration used to construct the time line.</p> <p> TYPE: <code>Dict[str, str]</code> </p> <code>chart_style</code> <p>If not None, configuration used to configure the chart style. EXAMPLE: <code>{\"labelFontSize\": 13, \"titleFontSize\": 14}</code></p> <p> TYPE: <code>Dict[str, float]</code> </p> Source code in <code>edsteva/viz/dashboards/probe/probe.py</code> <pre><code>def probe_only_dashboard(\n    predictor: pd.DataFrame,\n    x_axis_title: str,\n    y_axis_title: str,\n    main_chart_config: Dict[str, float],\n    vertical_bar_charts_config: Dict[str, str],\n    horizontal_bar_charts_config: Dict[str, str],\n    time_line_config: Dict[str, str],\n    chart_style: Dict[str, float],\n):\n\"\"\"Script to be used by [``predictor_dashboard()``][edsteva.viz.dashboards.probe.wrapper]\n\n    Parameters\n    ----------\n    predictor : pd.DataFrame\n        $c(t)$ computed in the Probe.\n    x_axis_title: str, optional,\n        Label name for the x axis.\n    y_axis_title: str, optional,\n        Label name for the y axis.\n    main_chart_config: Dict[str, str], optional\n        If not None, configuration used to construct the top main chart.\n    vertical_bar_charts_config: Dict[str, str], optional\n        If not None, configuration used to construct the vertical bar charts.\n    horizontal_bar_charts_config: Dict[str, str], optional\n        If not None, configuration used to construct the horizontal bar charts.\n    time_line_config: Dict[str, str], optional\n        If not None, configuration used to construct the time line.\n    chart_style: Dict[str, float], optional\n        If not None, configuration used to configure the chart style.\n        **EXAMPLE**: `{\"labelFontSize\": 13, \"titleFontSize\": 14}`\n    \"\"\"\n\n    base = alt.Chart(predictor)\n    time_line, time_selection = generate_time_line(\n        base=base,\n        time_line_config=time_line_config,\n    )\n    horizontal_bar_charts, y_variables_selections = generate_horizontal_bar_charts(\n        base=base,\n        horizontal_bar_charts_config=horizontal_bar_charts_config,\n        predictor=predictor,\n    )\n    vertical_bar_charts, x_variables_selections = generate_vertical_bar_charts(\n        base=base,\n        vertical_bar_charts_config=vertical_bar_charts_config,\n        predictor=predictor,\n    )\n    selections = dict(\n        date=time_selection,\n        **y_variables_selections,\n        **x_variables_selections,\n    )\n    selection_charts = dict(\n        horizontal_bar_charts,\n        **vertical_bar_charts,\n    )\n    base = add_interactive_selection(\n        base=base, selection_charts=selection_charts, selections=selections\n    )\n\n    index_selection, index_fields = create_groupby_selection(\n        indexes=vertical_bar_charts_config[\"x\"] + horizontal_bar_charts_config[\"y\"],\n        predictor=predictor,\n    )\n    main_chart = generate_main_chart(\n        base=base,\n        main_chart_config=main_chart_config,\n        index_selection=index_selection,\n        index_fields=index_fields,\n        x_axis_title=x_axis_title,\n        y_axis_title=y_axis_title,\n    )\n\n    main_chart = main_chart.mark_line()\n    main_chart = add_selection_on_legend(main_chart)\n    if index_selection:\n        main_chart = main_chart.add_params(index_selection)\n    chart = concatenate_charts(\n        main_chart=main_chart,\n        time_line=time_line,\n        horizontal_bar_charts=horizontal_bar_charts,\n        vertical_bar_charts=vertical_bar_charts,\n    )\n    return configure_style(chart=chart, chart_style=chart_style)\n</code></pre>"},{"location":"reference/viz/dashboards/probe/wrapper/","title":"<code>edsteva.viz.dashboards.probe.wrapper</code>","text":""},{"location":"reference/viz/dashboards/probe/wrapper/#edsteva.viz.dashboards.probe.wrapper.probe_dashboard","title":"probe_dashboard","text":"<pre><code>probe_dashboard(\n    probe: BaseProbe,\n    fitted_model: BaseModel = None,\n    care_site_level: List[str] = None,\n    save_path: str = None,\n    legend_predictor: str = \"Predictor c(t)\",\n    legend_model: str = \"Model f(t)\",\n    x_axis_title: str = None,\n    y_axis_title: str = None,\n    main_chart_config: Dict[str, float] = None,\n    model_line_config: Dict[str, str] = None,\n    probe_line_config: Dict[str, str] = None,\n    vertical_bar_charts_config: Dict[str, str] = None,\n    horizontal_bar_charts_config: Dict[str, str] = None,\n    time_line_config: Dict[str, str] = None,\n    chart_style: Dict[str, float] = None,\n    **kwargs\n)\n</code></pre> <p>Displays an interactive chart with:</p> <ul> <li>On the top, the aggregated average completeness predictor \\(c(t)\\) over time \\(t\\) with the fitted model \\(\\hat{c}(t)\\) if specified.</li> <li>On the bottom, interactive filters including all the concepts in the Probe (such as time, care site, number of visits...etc.)</li> </ul> <p>Is is possible to save the chart in HTML with the \"save_path\" optional input.</p> PARAMETER DESCRIPTION <code>probe</code> <p>Class describing the completeness predictor \\(c(t)\\).</p> <p> TYPE: <code>BaseProbe</code> </p> <code>fitted_model</code> <p>Model fitted to the probe.</p> <p> TYPE: <code>BaseModel</code> DEFAULT: <code>None</code> </p> <code>care_site_level</code> <p>EXAMPLE: <code>[\"Hospital\"]</code>, <code>[\"H\u00f4pital\", \"UF\"]</code> or <code>[\"UF\", \"UH\"]</code></p> <p> TYPE: <code>List[str]</code> DEFAULT: <code>None</code> </p> <code>save_path</code> <p>Folder path where to save the chart in HTML format.</p> <p>EXAMPLE: <code>\"my_folder/my_file.html\"</code></p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> <code>legend_predictor</code> <p>Label name for the predictor legend.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'Predictor c(t)'</code> </p> <code>legend_model</code> <p>Label name for the model legend.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'Model f(t)'</code> </p> <code>x_axis_title</code> <p>Label name for the x axis.</p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> <code>y_axis_title</code> <p>Label name for the y axis.</p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> <code>main_chart_config</code> <p>If not None, configuration used to construct the top main chart.</p> <p> TYPE: <code>Dict[str, float]</code> DEFAULT: <code>None</code> </p> <code>model_line_config</code> <p>If not None, configuration used to construct the model line.</p> <p> TYPE: <code>Dict[str, str]</code> DEFAULT: <code>None</code> </p> <code>probe_line_config</code> <p>If not None, configuration used to construct the probe line.</p> <p> TYPE: <code>Dict[str, str]</code> DEFAULT: <code>None</code> </p> <code>vertical_bar_charts_config</code> <p>If not None, configuration used to construct the vertical bar charts.</p> <p> TYPE: <code>Dict[str, str]</code> DEFAULT: <code>None</code> </p> <code>horizontal_bar_charts_config</code> <p>If not None, configuration used to construct the horizontal bar charts.</p> <p> TYPE: <code>Dict[str, str]</code> DEFAULT: <code>None</code> </p> <code>time_line_config</code> <p>If not None, configuration used to construct the time line.</p> <p> TYPE: <code>Dict[str, str]</code> DEFAULT: <code>None</code> </p> <code>chart_style</code> <p>If not None, configuration used to configure the chart style.</p> <p>EXAMPLE: <code>{\"labelFontSize\": 13, \"titleFontSize\": 14}</code></p> <p> TYPE: <code>Dict[str, float]</code> DEFAULT: <code>None</code> </p> Source code in <code>edsteva/viz/dashboards/probe/wrapper.py</code> <pre><code>def probe_dashboard(\n    probe: BaseProbe,\n    fitted_model: BaseModel = None,\n    care_site_level: List[str] = None,\n    save_path: str = None,\n    legend_predictor: str = \"Predictor c(t)\",\n    legend_model: str = \"Model f(t)\",\n    x_axis_title: str = None,\n    y_axis_title: str = None,\n    main_chart_config: Dict[str, float] = None,\n    model_line_config: Dict[str, str] = None,\n    probe_line_config: Dict[str, str] = None,\n    vertical_bar_charts_config: Dict[str, str] = None,\n    horizontal_bar_charts_config: Dict[str, str] = None,\n    time_line_config: Dict[str, str] = None,\n    chart_style: Dict[str, float] = None,\n    **kwargs,\n):\nr\"\"\"Displays an interactive chart with:\n\n    - On the top, the aggregated average completeness predictor $c(t)$ over time $t$ with the fitted model $\\hat{c}(t)$ if specified.\n    - On the bottom, interactive filters including all the concepts in the [Probe][probe] (such as time, care site, number of visits...etc.)\n\n    Is is possible to save the chart in HTML with the \"save_path\" optional input.\n\n    Parameters\n    ----------\n    probe : BaseProbe\n        Class describing the completeness predictor $c(t)$.\n    fitted_model : BaseModel, optional\n        Model fitted to the probe.\n    care_site_level : List[str], optional\n        **EXAMPLE**: `[\"Hospital\"]`, `[\"H\u00f4pital\", \"UF\"]` or `[\"UF\", \"UH\"]`\n    save_path : str, optional\n        Folder path where to save the chart in HTML format.\n\n        **EXAMPLE**: `\"my_folder/my_file.html\"`\n    legend_predictor: str, optional,\n        Label name for the predictor legend.\n    legend_model: str, optional,\n        Label name for the model legend.\n    x_axis_title: str, optional,\n        Label name for the x axis.\n    y_axis_title: str, optional,\n        Label name for the y axis.\n    main_chart_config: Dict[str, str], optional\n        If not None, configuration used to construct the top main chart.\n    model_line_config: Dict[str, str], optional\n        If not None, configuration used to construct the model line.\n    probe_line_config: Dict[str, str], optional\n        If not None, configuration used to construct the probe line.\n    vertical_bar_charts_config: Dict[str, str], optional\n        If not None, configuration used to construct the vertical bar charts.\n    horizontal_bar_charts_config: Dict[str, str], optional\n        If not None, configuration used to construct the horizontal bar charts.\n    time_line_config: Dict[str, str], optional\n        If not None, configuration used to construct the time line.\n    chart_style: Dict[str, float], optional\n        If not None, configuration used to configure the chart style.\n\n        **EXAMPLE**: `{\"labelFontSize\": 13, \"titleFontSize\": 14}`\n    \"\"\"\n\n    alt.data_transformers.enable(\"default\")\n    alt.data_transformers.disable_max_rows()\n\n    probe_config = deepcopy(probe.get_viz_config(\"probe_dashboard\"))\n    if fitted_model:\n        model_config = deepcopy(fitted_model.get_viz_config(\"probe_dashboard\"))\n        if model_line_config is None:\n            model_line_config = model_config[\"model_line\"]\n        if probe_line_config is None:\n            probe_line_config = model_config[\"probe_line\"]\n    if main_chart_config is None:\n        main_chart_config = probe_config[\"main_chart\"]\n    if time_line_config is None:\n        time_line_config = probe_config[\"time_line\"]\n    if vertical_bar_charts_config is None:\n        vertical_bar_charts_config = probe_config[\"vertical_bar_charts\"]\n        if fitted_model:\n            vertical_bar_charts_config[\"y\"] = (\n                vertical_bar_charts_config[\"y\"]\n                + model_config[\"extra_vertical_bar_charts\"]\n            )\n    if horizontal_bar_charts_config is None:\n        horizontal_bar_charts_config = probe_config[\"horizontal_bar_charts\"]\n        if fitted_model:\n            horizontal_bar_charts_config[\"x\"] = (\n                horizontal_bar_charts_config[\"x\"]\n                + model_config[\"extra_horizontal_bar_charts\"]\n            )\n    if chart_style is None:\n        chart_style = probe_config[\"chart_style\"]\n\n    predictor = fitted_model.predict(probe) if fitted_model else probe.predictor.copy()\n    predictor = filter_data(\n        data=predictor,\n        care_site_level=care_site_level,\n        **kwargs,\n    )\n\n    if fitted_model:\n        chart = fitted_probe_dashboard(\n            predictor=predictor,\n            legend_predictor=legend_predictor,\n            legend_model=legend_model,\n            x_axis_title=x_axis_title,\n            y_axis_title=y_axis_title,\n            main_chart_config=main_chart_config,\n            model_line_config=model_line_config,\n            probe_line_config=probe_line_config,\n            vertical_bar_charts_config=vertical_bar_charts_config,\n            horizontal_bar_charts_config=horizontal_bar_charts_config,\n            time_line_config=time_line_config,\n            chart_style=chart_style,\n        )\n    else:\n        chart = probe_only_dashboard(\n            predictor=predictor,\n            x_axis_title=x_axis_title,\n            y_axis_title=y_axis_title,\n            main_chart_config=main_chart_config,\n            vertical_bar_charts_config=vertical_bar_charts_config,\n            horizontal_bar_charts_config=horizontal_bar_charts_config,\n            time_line_config=time_line_config,\n            chart_style=chart_style,\n        )\n\n    vis_probe = \"id\" + uuid.uuid4().hex\n    new_index_probe_id = \"id\" + uuid.uuid4().hex\n    old_index_probe_id = \"id\" + uuid.uuid4().hex\n    left_shift = \"145px\" if fitted_model else \"45px\"\n    html_chart = f\"\"\"\n        &lt;!DOCTYPE html&gt;\n        &lt;html&gt;\n        &lt;head&gt;\n          &lt;script src=\"https://cdn.jsdelivr.net/npm/vega@{alt.VEGA_VERSION}\"&gt;&lt;/script&gt;\n          &lt;script src=\"https://cdn.jsdelivr.net/npm/vega-lite@{alt.VEGALITE_VERSION}\"&gt;&lt;/script&gt;\n          &lt;script src=\"https://cdn.jsdelivr.net/npm/vega-embed@{alt.VEGAEMBED_VERSION}\"&gt;&lt;/script&gt;\n        &lt;/head&gt;\n        &lt;body&gt;\n\n        &lt;div class=\"container\"&gt;\n          &lt;div class=\"row\"&gt;\n            &lt;div&gt;\n            &lt;div id={vis_probe}&gt;&lt;/div&gt;\n            &lt;/div&gt;\n            &lt;div style=\"position:absolute;left:{left_shift};top:380px;width: -webkit-fill-available;\"&gt;\n            &lt;div id={new_index_probe_id}&gt;\n              &lt;div id={old_index_probe_id}&gt;&lt;/div&gt;\n            &lt;/div&gt;\n            &lt;hr/&gt;\n            &lt;h1 style=\"text-align:center\"&gt; Interactive filters &lt;/h1&gt;\n            &lt;/div&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n\n        &lt;script type=\"text/javascript\"&gt;\n        vegaEmbed('#{vis_probe}', {chart.to_json(indent=None)}).then(function(result) {{\n            const sliders = document.getElementsByClassName('vega-bindings');\n            const newparent = document.getElementById('{new_index_probe_id}');\n            const oldchild = document.getElementById('{old_index_probe_id}');\n            for (var i = 0; i &lt; sliders.length; i++) {{\n                if (sliders[i].parentElement.parentElement.id == '{vis_probe}') {{\n                    var index_slider = sliders[i]\n}}\n}}\n            newparent.replaceChild(index_slider, oldchild);\n}}).catch(console.error);\n        &lt;/script&gt;\n        &lt;/body&gt;\n        &lt;/html&gt;\n        \"\"\"\n    if save_path:\n        save_html(\n            obj=html_chart,\n            filename=save_path,\n        )\n    else:\n        display(HTML(html_chart))\n</code></pre>"},{"location":"reference/viz/plots/","title":"<code>edsteva.viz.plots</code>","text":""},{"location":"reference/viz/plots/#edsteva.viz.plots.probe_plot","title":"probe_plot","text":"<pre><code>probe_plot(\n    probe: BaseProbe,\n    fitted_model: BaseModel = None,\n    care_site_level: List[str] = None,\n    start_date: datetime = None,\n    end_date: datetime = None,\n    save_path: str = None,\n    legend_predictor: str = \"Predictor c(t)\",\n    legend_model: str = \"Model f(t)\",\n    x_axis_title: str = None,\n    y_axis_title: str = None,\n    main_chart_config: Dict[str, float] = None,\n    model_line_config: Dict[str, str] = None,\n    probe_line_config: Dict[str, str] = None,\n    chart_style: Dict[str, float] = None,\n    indexes_to_remove: List[str] = [\"care_site_id\"],\n    **kwargs\n)\n</code></pre> <p>Displays a chart with the average completeness predictor \\(c(t)\\) over time \\(t\\) with the fitted model \\(\\hat{c}(t)\\) if specified. The chart is exportable in png or svg format and easy to integrate into a report. Is also possible to save the chart in HTML with the \"save_path\" optional input.</p> PARAMETER DESCRIPTION <code>probe</code> <p>Class describing the completeness predictor \\(c(t)\\).</p> <p> TYPE: <code>BaseProbe</code> </p> <code>fitted_model</code> <p>Model fitted to the probe</p> <p> TYPE: <code>BaseModel</code> DEFAULT: <code>None</code> </p> <code>care_site_level</code> <p>EXAMPLE: <code>[\"Hospital\"]</code>, <code>[\"H\u00f4pital\", \"UF\"]</code> or <code>[\"UF\", \"UH\"]</code></p> <p> TYPE: <code>List[str]</code> DEFAULT: <code>None</code> </p> <code>start_date</code> <p>EXAMPLE: <code>\"2019-05-01\"</code></p> <p> TYPE: <code>datetime</code> DEFAULT: <code>None</code> </p> <code>end_date</code> <p>EXAMPLE: <code>\"2021-07-01\"</code></p> <p> TYPE: <code>datetime</code> DEFAULT: <code>None</code> </p> <code>save_path</code> <p>Folder path where to save the chart in HTML format.</p> <p>EXAMPLE: <code>\"my_folder/my_file.html\"</code></p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> <code>legend_predictor</code> <p>Label name for the predictor legend.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'Predictor c(t)'</code> </p> <code>legend_model</code> <p>Label name for the model legend.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'Model f(t)'</code> </p> <code>x_axis_title</code> <p>Label name for the x axis.</p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> <code>y_axis_title</code> <p>Label name for the y axis.</p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> <code>main_chart_config</code> <p>If not None, configuration used to construct the top main chart.</p> <p> TYPE: <code>Dict[str, float]</code> DEFAULT: <code>None</code> </p> <code>model_line_config</code> <p>If not None, configuration used to construct the model line.</p> <p> TYPE: <code>Dict[str, str]</code> DEFAULT: <code>None</code> </p> <code>probe_line_config</code> <p>If not None, configuration used to construct the probe line.</p> <p> TYPE: <code>Dict[str, str]</code> DEFAULT: <code>None</code> </p> <code>chart_style</code> <p>If not None, configuration used to configure the chart style.</p> <p>EXAMPLE: <code>{\"labelFontSize\": 13, \"titleFontSize\": 14}</code></p> <p> TYPE: <code>Dict[str, float]</code> DEFAULT: <code>None</code> </p> <code>indexes_to_remove</code> <p>indexes to remove from the groupby selection.</p> <p> TYPE: <code>List[str]</code> DEFAULT: <code>['care_site_id']</code> </p> Source code in <code>edsteva/viz/plots/probe/wrapper.py</code> <pre><code>def probe_plot(\n    probe: BaseProbe,\n    fitted_model: BaseModel = None,\n    care_site_level: List[str] = None,\n    start_date: datetime = None,\n    end_date: datetime = None,\n    save_path: str = None,\n    legend_predictor: str = \"Predictor c(t)\",\n    legend_model: str = \"Model f(t)\",\n    x_axis_title: str = None,\n    y_axis_title: str = None,\n    main_chart_config: Dict[str, float] = None,\n    model_line_config: Dict[str, str] = None,\n    probe_line_config: Dict[str, str] = None,\n    chart_style: Dict[str, float] = None,\n    indexes_to_remove: List[str] = [\"care_site_id\"],\n    **kwargs,\n):\nr\"\"\"\n    Displays a chart with the average completeness predictor $c(t)$ over time $t$ with the fitted model $\\hat{c}(t)$ if specified.\n    The chart is exportable in png or svg format and easy to integrate into a report. Is also possible to save the chart in HTML with the \"save_path\" optional input.\n\n    Parameters\n    ----------\n    probe : BaseProbe\n        Class describing the completeness predictor $c(t)$.\n    fitted_model : BaseModel, optional\n        Model fitted to the probe\n    care_site_level : List[str], optional\n        **EXAMPLE**: `[\"Hospital\"]`, `[\"H\u00f4pital\", \"UF\"]` or `[\"UF\", \"UH\"]`\n    start_date : datetime, optional\n        **EXAMPLE**: `\"2019-05-01\"`\n    end_date : datetime, optional\n        **EXAMPLE**: `\"2021-07-01\"`\n    save_path : str, optional\n        Folder path where to save the chart in HTML format.\n\n        **EXAMPLE**: `\"my_folder/my_file.html\"`\n    legend_predictor: str, optional,\n        Label name for the predictor legend.\n    legend_model: str, optional,\n        Label name for the model legend.\n    x_axis_title: str, optional,\n        Label name for the x axis.\n    y_axis_title: str, optional,\n        Label name for the y axis.\n    main_chart_config: Dict[str, str], optional\n        If not None, configuration used to construct the top main chart.\n    model_line_config: Dict[str, str], optional\n        If not None, configuration used to construct the model line.\n    probe_line_config: Dict[str, str], optional\n        If not None, configuration used to construct the probe line.\n    chart_style: Dict[str, float], optional\n        If not None, configuration used to configure the chart style.\n\n        **EXAMPLE**: `{\"labelFontSize\": 13, \"titleFontSize\": 14}`\n    indexes_to_remove: List[str], optional\n        indexes to remove from the groupby selection.\n    \"\"\"\n    alt.data_transformers.enable(\"default\")\n    alt.data_transformers.disable_max_rows()\n\n    probe_config = deepcopy(probe.get_viz_config(\"probe_plot\"))\n    if main_chart_config is None:\n        main_chart_config = probe_config[\"main_chart\"]\n    if chart_style is None:\n        chart_style = probe_config[\"chart_style\"]\n    predictor = probe.predictor.copy()\n    cols_to_remove = [\"date\", *probe._metrics]\n    if indexes_to_remove:\n        cols_to_remove.extend(indexes_to_remove)\n    indexes = list(set(predictor.columns).difference(cols_to_remove))\n\n    if fitted_model:\n        predictor = fitted_model.predict(probe).copy()\n    else:\n        predictor = probe.predictor.copy()\n\n    predictor = filter_data(\n        data=predictor,\n        care_site_level=care_site_level,\n        start_date=start_date,\n        end_date=end_date,\n        **kwargs,\n    )\n\n    indexes = [\n        {\"field\": variable, \"title\": variable.replace(\"_\", \" \").capitalize()}\n        for variable in indexes\n        if variable in predictor.columns and len(predictor[variable].unique()) &gt;= 2\n    ]\n\n    if fitted_model:\n        model_config = deepcopy(fitted_model.get_viz_config(\"probe_plot\"))\n        if model_line_config is None:\n            model_line_config = model_config[\"model_line\"]\n        if probe_line_config is None:\n            probe_line_config = model_config[\"probe_line\"]\n        chart = fitted_probe_line(\n            predictor=predictor,\n            indexes=indexes,\n            legend_predictor=legend_predictor,\n            legend_model=legend_model,\n            x_axis_title=x_axis_title,\n            y_axis_title=y_axis_title,\n            main_chart_config=main_chart_config,\n            model_line_config=model_line_config,\n            probe_line_config=probe_line_config,\n        )\n    else:\n        chart = probe_line(\n            predictor=predictor,\n            indexes=indexes,\n            x_axis_title=x_axis_title,\n            y_axis_title=y_axis_title,\n            main_chart_config=main_chart_config,\n        )\n\n    if save_path:\n        save_html(\n            obj=configure_style(chart=chart, chart_style=chart_style),\n            filename=save_path,\n        )\n\n    return chart\n</code></pre>"},{"location":"reference/viz/plots/#edsteva.viz.plots.estimates_densities_plot","title":"estimates_densities_plot","text":"<pre><code>estimates_densities_plot(\n    fitted_model: BaseModel,\n    probe: BaseProbe = None,\n    care_site_level: List[str] = None,\n    start_date: Union[datetime, str] = None,\n    end_date: Union[datetime, str] = None,\n    save_path: str = None,\n    vertical_bar_charts_config: Dict[str, str] = None,\n    horizontal_bar_charts_config: Dict[str, str] = None,\n    chart_style: Dict[str, float] = None,\n    y_axis_title: str = None,\n    **kwargs\n)\n</code></pre> <p>Displays the density plot with the associated box plot of each estimate and metric computed in the input model. It can help you to set the thresholds.</p> PARAMETER DESCRIPTION <code>probe</code> <p>Class describing the completeness predictor \\(c(t)\\)</p> <p> TYPE: <code>BaseProbe</code> DEFAULT: <code>None</code> </p> <code>fitted_model</code> <p>Model with estimates of interest.</p> <p>EXAMPLE: StepFunction Model with \\((\\hat{t_0}, \\hat{c_0})\\)</p> <p> TYPE: <code>BaseModel</code> </p> <code>care_site_level</code> <p>EXAMPLE: <code>[\"Hospital\"]</code>, <code>[\"H\u00f4pital\", \"UF\"]</code> or <code>[\"UF\", \"UH\"]</code></p> <p> TYPE: <code>List[str]</code> DEFAULT: <code>None</code> </p> <code>start_date</code> <p>EXAMPLE: <code>\"2019-05-01\"</code></p> <p> TYPE: <code>datetime</code> DEFAULT: <code>None</code> </p> <code>end_date</code> <p>EXAMPLE: <code>\"2021-07-01\"</code></p> <p> TYPE: <code>datetime</code> DEFAULT: <code>None</code> </p> <code>save_path</code> <p>Folder path where to save the chart in HTML format.</p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> <code>vertical_bar_charts_config</code> <p>Configuration used to construct the vertical bar charts.</p> <p> TYPE: <code>Dict[str, str]</code> DEFAULT: <code>None</code> </p> <code>horizontal_bar_charts_config</code> <p>Configuration used to construct the horizontal bar charts.</p> <p> TYPE: <code>Dict[str, str]</code> DEFAULT: <code>None</code> </p> <code>chart_style</code> <p>Configuration used to configure the chart style.</p> <p>EXAMPLE: <code>{\"labelFontSize\": 13, \"titleFontSize\": 14}</code></p> <p> TYPE: <code>Dict[str, float]</code> DEFAULT: <code>None</code> </p> <code>y_axis_title</code> <p>Label name for the y axis.</p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> Source code in <code>edsteva/viz/plots/estimates_densities/estimates_densities.py</code> <pre><code>def estimates_densities_plot(\n    fitted_model: BaseModel,\n    probe: BaseProbe = None,\n    care_site_level: List[str] = None,\n    start_date: Union[datetime, str] = None,\n    end_date: Union[datetime, str] = None,\n    save_path: str = None,\n    vertical_bar_charts_config: Dict[str, str] = None,\n    horizontal_bar_charts_config: Dict[str, str] = None,\n    chart_style: Dict[str, float] = None,\n    y_axis_title: str = None,\n    **kwargs,\n):\nr\"\"\"Displays the density plot with the associated box plot of each estimate and metric computed in the input model. It can help you to set the thresholds.\n\n\n    Parameters\n    ----------\n    probe : BaseProbe\n        Class describing the completeness predictor $c(t)$\n    fitted_model : BaseModel\n        Model with estimates of interest.\n\n        **EXAMPLE**: StepFunction Model with $(\\hat{t_0}, \\hat{c_0})$\n    care_site_level : List[str], optional\n        **EXAMPLE**: `[\"Hospital\"]`, `[\"H\u00f4pital\", \"UF\"]` or `[\"UF\", \"UH\"]`\n    start_date : datetime, optional\n        **EXAMPLE**: `\"2019-05-01\"`\n    end_date : datetime, optional\n        **EXAMPLE**: `\"2021-07-01\"`\n    save_path : str, optional\n        Folder path where to save the chart in HTML format.\n    vertical_bar_charts_config: Dict[str, str], optional\n        Configuration used to construct the vertical bar charts.\n    horizontal_bar_charts_config: Dict[str, str], optional\n        Configuration used to construct the horizontal bar charts.\n    chart_style: Dict[str, float], optional\n        Configuration used to configure the chart style.\n\n        **EXAMPLE**: `{\"labelFontSize\": 13, \"titleFontSize\": 14}`\n    y_axis_title: str, optional,\n        Label name for the y axis.\n    \"\"\"\n    alt.data_transformers.disable_max_rows()\n\n    estimates = fitted_model.estimates.copy()\n    estimates = filter_data(\n        data=estimates,\n        table_name=\"estimates\",\n        care_site_level=care_site_level,\n        **kwargs,\n    )\n    if probe is not None:\n        predictor = probe.predictor.copy()\n        # Filter data in predictor not in estimates\n        predictor = predictor.merge(\n            estimates[list(estimates.columns.intersection(set(predictor.columns)))],\n            on=list(estimates.columns.intersection(set(predictor.columns))),\n        )\n        predictor = filter_data(\n            data=predictor,\n            start_date=start_date,\n            end_date=end_date,\n        )\n        estimates = probe.add_names_columns(estimates)\n        probe_config = deepcopy(probe.get_viz_config(\"estimates_densities_plot\"))\n        if vertical_bar_charts_config is None:\n            vertical_bar_charts_config = probe_config[\"vertical_bar_charts\"]\n        if horizontal_bar_charts_config is None:\n            horizontal_bar_charts_config = probe_config[\"horizontal_bar_charts\"]\n        if chart_style is None:\n            chart_style = probe_config[\"chart_style\"]\n\n    quantitative_estimates = []\n    time_estimates = []\n\n    base_estimate = alt.Chart(estimates)\n    for estimate in fitted_model._coefs + fitted_model._metrics:\n        if estimates[estimate].dtype == float or estimates[estimate].dtype == int:\n            max_value = estimates[estimate].max()\n            min_value = estimates[estimate].min()\n            estimates[estimate] = round(estimates[estimate], 3)\n\n            estimate_density = (\n                alt.vconcat(\n                    (\n                        (\n                            base_estimate.transform_density(\n                                estimate,\n                                as_=[estimate, \"Density\"],\n                                extent=[min_value, max_value],\n                            )\n                            .mark_area()\n                            .encode(\n                                x=alt.X(\"{}:Q\".format(estimate), title=None),\n                                y=alt.Y(\"Density:Q\", title=y_axis_title),\n                            )\n                        )\n                        + base_estimate.mark_rule(color=\"red\").encode(\n                            x=\"median({}):Q\".format(estimate),\n                            tooltip=alt.Tooltip(\"median({}):Q\".format(estimate)),\n                        )\n                    ).properties(width=800, height=300),\n                    (\n                        base_estimate.mark_tick().encode(\n                            x=alt.X(\"{}:Q\".format(estimate), axis=None)\n                        )\n                    ),\n                    spacing=0,\n                )\n                &amp; (\n                    base_estimate.mark_boxplot().encode(\n                        x=\"{}:Q\".format(estimate),\n                    )\n                )\n            ).resolve_scale(x=\"shared\")\n            quantitative_estimates.append(estimate_density)\n\n        else:\n            estimates[estimate] = estimates[estimate].astype(\"datetime64[ns]\")\n            estimate_density = (\n                (\n                    base_estimate.transform_timeunit(\n                        estimate=\"yearmonth({})\".format(estimate)\n                    )\n                    .mark_bar(size=10)\n                    .encode(\n                        x=alt.X(\n                            \"{}:T\".format(estimate),\n                            axis=alt.Axis(\n                                tickCount=\"month\",\n                                format=\"%Y, %b\",\n                                labelAngle=-90,\n                            ),\n                            title=estimate,\n                        ),\n                        y=alt.Y(\n                            \"count({}):Q\".format(estimate),\n                            axis=alt.Axis(tickMinStep=1),\n                            title=y_axis_title,\n                        ),\n                    )\n                )\n                + base_estimate.mark_rule(color=\"red\").encode(\n                    x=\"median({}):T\".format(estimate),\n                    tooltip=alt.Tooltip(\"median({}):T\".format(estimate)),\n                )\n            ).properties(width=800, height=300)\n            time_estimates.append(estimate_density)\n\n    estimates_densities = time_estimates + quantitative_estimates\n\n    chart = reduce(\n        lambda estimate_density_1, estimate_density_2: estimate_density_1\n        &amp; estimate_density_2,\n        estimates_densities,\n    )\n    if probe is not None:\n        base = alt.Chart(predictor)\n\n        horizontal_bar_charts, y_variables_selections = generate_horizontal_bar_charts(\n            base=base,\n            horizontal_bar_charts_config=horizontal_bar_charts_config,\n            predictor=predictor,\n        )\n        vertical_bar_charts, x_variables_selections = generate_vertical_bar_charts(\n            base=base,\n            vertical_bar_charts_config=vertical_bar_charts_config,\n            predictor=predictor,\n        )\n\n        selections = dict(\n            y_variables_selections,\n            **x_variables_selections,\n        )\n        selection_charts = dict(\n            horizontal_bar_charts,\n            **vertical_bar_charts,\n        )\n        chart = add_interactive_selection(\n            base=chart, selection_charts=selection_charts, selections=selections\n        )\n\n        chart = concatenate_charts(\n            main_chart=chart,\n            horizontal_bar_charts=horizontal_bar_charts,\n            vertical_bar_charts=vertical_bar_charts,\n            spacing=0,\n        )\n    elif \"care_site_level\" in estimates.columns:\n        care_site_level_dropdwon = alt.binding_select(\n            options=estimates[\"care_site_level\"].unique(), name=\"Care site level : \"\n        )\n        care_site_level_selection = alt.selection_point(\n            fields=[\"care_site_level\"],\n            bind=care_site_level_dropdwon,\n            value=estimates[\"care_site_level\"].unique()[0],\n        )\n        chart = chart.add_params(care_site_level_selection).transform_filter(\n            care_site_level_selection\n        )\n    if chart_style:\n        chart = configure_style(chart=chart, chart_style=chart_style)\n    if save_path:\n        save_html(\n            obj=chart,\n            filename=save_path,\n        )\n\n    return chart\n</code></pre>"},{"location":"reference/viz/plots/#edsteva.viz.plots.normalized_probe_plot","title":"normalized_probe_plot","text":"<pre><code>normalized_probe_plot(\n    probe: BaseProbe,\n    fitted_model: BaseModel,\n    care_site_level: List[str] = None,\n    start_date: Union[datetime, str] = None,\n    end_date: Union[datetime, str] = None,\n    t_min: int = None,\n    t_max: int = None,\n    save_path: str = None,\n    x_axis_title: str = None,\n    y_axis_title: str = None,\n    main_chart_config: Dict[str, float] = None,\n    model_line_config: Dict[str, str] = None,\n    probe_line_config: Dict[str, str] = None,\n    error_line_config: Dict[str, str] = None,\n    estimates_selections: Dict[str, str] = None,\n    estimates_filters: Dict[str, str] = None,\n    chart_style: Dict[str, float] = None,\n    indexes_to_remove: List[str] = [\"care_site_id\"],\n    **kwargs\n)\n</code></pre> <p>Displays a chart with the aggregated normalized completeness predictor \\(\\frac{c(\\Delta t)}{c_0}\\) over normalized time \\(\\Delta t = t - t_0\\). It represents the overall deviation from the Model.</p> <p>Is is possible to save the chart in HTML with the \"save_path\" optional input.</p> PARAMETER DESCRIPTION <code>probe</code> <p>Class describing the completeness predictor \\(c(t)\\)</p> <p> TYPE: <code>BaseProbe</code> </p> <code>fitted_model</code> <p>Model fitted to the probe</p> <p> TYPE: <code>BaseModel</code> </p> <code>care_site_level</code> <p>EXAMPLE: <code>[\"Hospital\"]</code>, <code>[\"H\u00f4pital\", \"UF\"]</code> or <code>[\"UF\", \"UH\"]</code></p> <p> TYPE: <code>List[str]</code> DEFAULT: <code>None</code> </p> <code>start_date</code> <p>EXAMPLE: <code>\"2019-05-01\"</code></p> <p> TYPE: <code>datetime</code> DEFAULT: <code>None</code> </p> <code>end_date</code> <p>EXAMPLE: <code>\"2021-07-01\"</code></p> <p> TYPE: <code>datetime</code> DEFAULT: <code>None</code> </p> <code>t_min</code> <p>Minimal difference with \\(t_0\\) in month \\(\\Delta t_{min}\\).</p> <p>EXAMPLE: <code>-24</code></p> <p> TYPE: <code>int</code> DEFAULT: <code>None</code> </p> <code>t_max</code> <p>Maximal difference with \\(t_0\\) in month \\(\\Delta t_{max}\\).</p> <p>EXAMPLE: <code>24</code></p> <p> TYPE: <code>int</code> DEFAULT: <code>None</code> </p> <code>save_path</code> <p>Folder path where to save the chart in HTML format.</p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> <code>x_axis_title</code> <p>Label name for the x axis.</p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> <code>y_axis_title</code> <p>Label name for the y axis.</p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> <code>main_chart_config</code> <p>If not None, configuration used to construct the top main chart.</p> <p> TYPE: <code>Dict[str, float]</code> DEFAULT: <code>None</code> </p> <code>model_line_config</code> <p>If not None, configuration used to construct the model line.</p> <p> TYPE: <code>Dict[str, str]</code> DEFAULT: <code>None</code> </p> <code>error_line_config</code> <p>If not None, configuration used to construct the error line.</p> <p> TYPE: <code>Dict[str, str]</code> DEFAULT: <code>None</code> </p> <code>probe_line_config</code> <p>If not None, configuration used to construct the probe line.</p> <p> TYPE: <code>Dict[str, str]</code> DEFAULT: <code>None</code> </p> <code>estimates_selections</code> <p>If not None, configuration used to construct the estimates selections.</p> <p> TYPE: <code>Dict[str, str]</code> DEFAULT: <code>None</code> </p> <code>estimates_filters</code> <p>If not None, configuration used to construct the estimates filters.</p> <p> TYPE: <code>Dict[str, str]</code> DEFAULT: <code>None</code> </p> <code>chart_style</code> <p>If not None, configuration used to configure the chart style.</p> <p>EXAMPLE: <code>{\"labelFontSize\": 13, \"titleFontSize\": 14}</code></p> <p> TYPE: <code>Dict[str, float]</code> DEFAULT: <code>None</code> </p> <code>indexes_to_remove</code> <p>indexes to remove from the groupby selection.</p> <p> TYPE: <code>List[str]</code> DEFAULT: <code>['care_site_id']</code> </p> Source code in <code>edsteva/viz/plots/normalized_probe/normalized_probe.py</code> <pre><code>def normalized_probe_plot(\n    probe: BaseProbe,\n    fitted_model: BaseModel,\n    care_site_level: List[str] = None,\n    start_date: Union[datetime, str] = None,\n    end_date: Union[datetime, str] = None,\n    t_min: int = None,\n    t_max: int = None,\n    save_path: str = None,\n    x_axis_title: str = None,\n    y_axis_title: str = None,\n    main_chart_config: Dict[str, float] = None,\n    model_line_config: Dict[str, str] = None,\n    probe_line_config: Dict[str, str] = None,\n    error_line_config: Dict[str, str] = None,\n    estimates_selections: Dict[str, str] = None,\n    estimates_filters: Dict[str, str] = None,\n    chart_style: Dict[str, float] = None,\n    indexes_to_remove: List[str] = [\"care_site_id\"],\n    **kwargs,\n):\nr\"\"\"Displays a chart with the aggregated normalized completeness predictor $\\frac{c(\\Delta t)}{c_0}$ over normalized time $\\Delta t = t - t_0$. It represents the overall deviation from the Model.\n\n    Is is possible to save the chart in HTML with the \"save_path\" optional input.\n\n    Parameters\n    ----------\n    probe : BaseProbe\n        Class describing the completeness predictor $c(t)$\n    fitted_model : BaseModel\n        Model fitted to the probe\n    care_site_level : List[str], optional\n        **EXAMPLE**: `[\"Hospital\"]`, `[\"H\u00f4pital\", \"UF\"]` or `[\"UF\", \"UH\"]`\n    start_date : datetime, optional\n        **EXAMPLE**: `\"2019-05-01\"`\n    end_date : datetime, optional\n        **EXAMPLE**: `\"2021-07-01\"`\n    t_min : int, optional\n        Minimal difference with $t_0$ in month $\\Delta t_{min}$.\n\n        **EXAMPLE**: `-24`\n    t_max : int, optional\n        Maximal difference with $t_0$ in month $\\Delta t_{max}$.\n\n        **EXAMPLE**: `24`\n    save_path : str, optional\n        Folder path where to save the chart in HTML format.\n    x_axis_title: str, optional,\n        Label name for the x axis.\n    y_axis_title: str, optional,\n        Label name for the y axis.\n    main_chart_config: Dict[str, str], optional\n        If not None, configuration used to construct the top main chart.\n    model_line_config: Dict[str, str], optional\n        If not None, configuration used to construct the model line.\n    error_line_config: Dict[str, str], optional\n        If not None, configuration used to construct the error line.\n    probe_line_config: Dict[str, str], optional\n        If not None, configuration used to construct the probe line.\n    estimates_selections: Dict[str, str], optional\n        If not None, configuration used to construct the estimates selections.\n    estimates_filters: Dict[str, str], optional\n        If not None, configuration used to construct the estimates filters.\n    chart_style: Dict[str, float], optional\n        If not None, configuration used to configure the chart style.\n\n        **EXAMPLE**: `{\"labelFontSize\": 13, \"titleFontSize\": 14}`\n    indexes_to_remove: List[str], optional\n        indexes to remove from the groupby selection.\n    \"\"\"\n\n    alt.data_transformers.disable_max_rows()\n\n    # Pre-processing\n    predictor = probe.predictor.copy()\n    predictor_metrics = probe._metrics.copy()\n    estimates = fitted_model.estimates.copy()\n    indexes = get_indexes_to_groupby(\n        predictor_columns=predictor.columns,\n        predictor_metrics=predictor_metrics,\n        indexes_to_remove=indexes_to_remove,\n    )\n    predictor = predictor.merge(estimates, on=probe._index)\n    predictor[\"normalized_date\"] = month_diff(\n        predictor[\"date\"], predictor[\"t_0\"]\n    ).astype(int)\n    for estimate in fitted_model._coefs + fitted_model._metrics:\n        if pd.api.types.is_datetime64_any_dtype(predictor[estimate]):\n            predictor[estimate] = predictor[estimate].dt.strftime(\"%Y-%m\")\n    predictor[\"normalized_c\"] = predictor[\"c\"].where(\n        (predictor[\"normalized_date\"] &lt; 0) | (predictor[\"c_0\"] == 0),\n        predictor[\"c\"] / predictor[\"c_0\"],\n    )\n    predictor[\"model\"] = 1\n    predictor[\"model\"] = predictor[\"model\"].where(predictor[\"normalized_date\"] &gt;= 0, 0)\n    predictor = filter_data(\n        data=predictor,\n        care_site_level=care_site_level,\n        start_date=start_date,\n        end_date=end_date,\n        **kwargs,\n    )\n    if t_min:\n        predictor = predictor[predictor.normalized_date &gt;= t_min]\n    if t_max:\n        predictor = predictor[predictor.normalized_date &lt;= t_max]\n\n    # Get viz config\n    probe_config = deepcopy(probe.get_viz_config(\"normalized_probe_plot\"))\n    model_config = deepcopy(\n        fitted_model.get_viz_config(\"normalized_probe_plot\", predictor=predictor)\n    )\n    if probe_line_config is None:\n        probe_line_config = model_config[\"probe_line\"]\n    if model_line_config is None:\n        model_line_config = model_config[\"model_line\"]\n    if error_line_config is None:\n        error_line_config = model_config[\"error_line\"]\n    if estimates_selections is None:\n        estimates_selections = model_config[\"estimates_selections\"]\n    if estimates_filters is None:\n        estimates_filters = model_config[\"estimates_filters\"]\n    if main_chart_config is None:\n        main_chart_config = probe_config[\"main_chart\"]\n    if chart_style is None:\n        chart_style = probe_config[\"chart_style\"]\n\n    # Viz\n    predictor[\"legend_model\"] = (\n        model_line_config.get(\"legend_title\")\n        if model_line_config.get(\"legend_title\")\n        else type(fitted_model).__name__\n    )\n    predictor[\"legend_predictor\"] = probe_line_config[\"legend_title\"]\n    predictor[\"legend_error_band\"] = error_line_config[\"legend_title\"]\n    index_selection, index_fields = create_groupby_selection(\n        indexes=indexes,\n        predictor=predictor,\n    )\n    base = alt.Chart(predictor)\n    base = add_estimates_filters(\n        base=base,\n        estimates_filters=estimates_filters,\n    )\n    main_chart = generate_main_chart(\n        base=base,\n        main_chart_config=main_chart_config,\n        index_selection=index_selection,\n        index_fields=index_fields,\n        x_axis_title=x_axis_title,\n        y_axis_title=y_axis_title,\n    )\n    probe_line = generate_probe_line(\n        main_chart=main_chart, probe_line_config=probe_line_config\n    )\n    error_line = generate_error_line(\n        main_chart=main_chart, error_line_config=error_line_config\n    )\n    model_line = generate_model_line(\n        main_chart=main_chart, model_line_config=model_line_config\n    )\n    main_chart = probe_line + error_line + model_line\n    if index_selection:\n        main_chart = main_chart.add_params(index_selection)\n\n    for estimate_selection in estimates_selections:\n        main_chart = main_chart.add_params(estimate_selection)\n\n    main_chart = configure_style(chart=main_chart, chart_style=chart_style)\n\n    if save_path:\n        save_html(\n            obj=main_chart,\n            filename=save_path,\n        )\n\n    return main_chart\n</code></pre>"},{"location":"reference/viz/plots/estimates_densities/","title":"<code>edsteva.viz.plots.estimates_densities</code>","text":""},{"location":"reference/viz/plots/estimates_densities/estimates_densities/","title":"<code>edsteva.viz.plots.estimates_densities.estimates_densities</code>","text":""},{"location":"reference/viz/plots/estimates_densities/estimates_densities/#edsteva.viz.plots.estimates_densities.estimates_densities.estimates_densities_plot","title":"estimates_densities_plot","text":"<pre><code>estimates_densities_plot(\n    fitted_model: BaseModel,\n    probe: BaseProbe = None,\n    care_site_level: List[str] = None,\n    start_date: Union[datetime, str] = None,\n    end_date: Union[datetime, str] = None,\n    save_path: str = None,\n    vertical_bar_charts_config: Dict[str, str] = None,\n    horizontal_bar_charts_config: Dict[str, str] = None,\n    chart_style: Dict[str, float] = None,\n    y_axis_title: str = None,\n    **kwargs\n)\n</code></pre> <p>Displays the density plot with the associated box plot of each estimate and metric computed in the input model. It can help you to set the thresholds.</p> PARAMETER DESCRIPTION <code>probe</code> <p>Class describing the completeness predictor \\(c(t)\\)</p> <p> TYPE: <code>BaseProbe</code> DEFAULT: <code>None</code> </p> <code>fitted_model</code> <p>Model with estimates of interest.</p> <p>EXAMPLE: StepFunction Model with \\((\\hat{t_0}, \\hat{c_0})\\)</p> <p> TYPE: <code>BaseModel</code> </p> <code>care_site_level</code> <p>EXAMPLE: <code>[\"Hospital\"]</code>, <code>[\"H\u00f4pital\", \"UF\"]</code> or <code>[\"UF\", \"UH\"]</code></p> <p> TYPE: <code>List[str]</code> DEFAULT: <code>None</code> </p> <code>start_date</code> <p>EXAMPLE: <code>\"2019-05-01\"</code></p> <p> TYPE: <code>datetime</code> DEFAULT: <code>None</code> </p> <code>end_date</code> <p>EXAMPLE: <code>\"2021-07-01\"</code></p> <p> TYPE: <code>datetime</code> DEFAULT: <code>None</code> </p> <code>save_path</code> <p>Folder path where to save the chart in HTML format.</p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> <code>vertical_bar_charts_config</code> <p>Configuration used to construct the vertical bar charts.</p> <p> TYPE: <code>Dict[str, str]</code> DEFAULT: <code>None</code> </p> <code>horizontal_bar_charts_config</code> <p>Configuration used to construct the horizontal bar charts.</p> <p> TYPE: <code>Dict[str, str]</code> DEFAULT: <code>None</code> </p> <code>chart_style</code> <p>Configuration used to configure the chart style.</p> <p>EXAMPLE: <code>{\"labelFontSize\": 13, \"titleFontSize\": 14}</code></p> <p> TYPE: <code>Dict[str, float]</code> DEFAULT: <code>None</code> </p> <code>y_axis_title</code> <p>Label name for the y axis.</p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> Source code in <code>edsteva/viz/plots/estimates_densities/estimates_densities.py</code> <pre><code>def estimates_densities_plot(\n    fitted_model: BaseModel,\n    probe: BaseProbe = None,\n    care_site_level: List[str] = None,\n    start_date: Union[datetime, str] = None,\n    end_date: Union[datetime, str] = None,\n    save_path: str = None,\n    vertical_bar_charts_config: Dict[str, str] = None,\n    horizontal_bar_charts_config: Dict[str, str] = None,\n    chart_style: Dict[str, float] = None,\n    y_axis_title: str = None,\n    **kwargs,\n):\nr\"\"\"Displays the density plot with the associated box plot of each estimate and metric computed in the input model. It can help you to set the thresholds.\n\n\n    Parameters\n    ----------\n    probe : BaseProbe\n        Class describing the completeness predictor $c(t)$\n    fitted_model : BaseModel\n        Model with estimates of interest.\n\n        **EXAMPLE**: StepFunction Model with $(\\hat{t_0}, \\hat{c_0})$\n    care_site_level : List[str], optional\n        **EXAMPLE**: `[\"Hospital\"]`, `[\"H\u00f4pital\", \"UF\"]` or `[\"UF\", \"UH\"]`\n    start_date : datetime, optional\n        **EXAMPLE**: `\"2019-05-01\"`\n    end_date : datetime, optional\n        **EXAMPLE**: `\"2021-07-01\"`\n    save_path : str, optional\n        Folder path where to save the chart in HTML format.\n    vertical_bar_charts_config: Dict[str, str], optional\n        Configuration used to construct the vertical bar charts.\n    horizontal_bar_charts_config: Dict[str, str], optional\n        Configuration used to construct the horizontal bar charts.\n    chart_style: Dict[str, float], optional\n        Configuration used to configure the chart style.\n\n        **EXAMPLE**: `{\"labelFontSize\": 13, \"titleFontSize\": 14}`\n    y_axis_title: str, optional,\n        Label name for the y axis.\n    \"\"\"\n    alt.data_transformers.disable_max_rows()\n\n    estimates = fitted_model.estimates.copy()\n    estimates = filter_data(\n        data=estimates,\n        table_name=\"estimates\",\n        care_site_level=care_site_level,\n        **kwargs,\n    )\n    if probe is not None:\n        predictor = probe.predictor.copy()\n        # Filter data in predictor not in estimates\n        predictor = predictor.merge(\n            estimates[list(estimates.columns.intersection(set(predictor.columns)))],\n            on=list(estimates.columns.intersection(set(predictor.columns))),\n        )\n        predictor = filter_data(\n            data=predictor,\n            start_date=start_date,\n            end_date=end_date,\n        )\n        estimates = probe.add_names_columns(estimates)\n        probe_config = deepcopy(probe.get_viz_config(\"estimates_densities_plot\"))\n        if vertical_bar_charts_config is None:\n            vertical_bar_charts_config = probe_config[\"vertical_bar_charts\"]\n        if horizontal_bar_charts_config is None:\n            horizontal_bar_charts_config = probe_config[\"horizontal_bar_charts\"]\n        if chart_style is None:\n            chart_style = probe_config[\"chart_style\"]\n\n    quantitative_estimates = []\n    time_estimates = []\n\n    base_estimate = alt.Chart(estimates)\n    for estimate in fitted_model._coefs + fitted_model._metrics:\n        if estimates[estimate].dtype == float or estimates[estimate].dtype == int:\n            max_value = estimates[estimate].max()\n            min_value = estimates[estimate].min()\n            estimates[estimate] = round(estimates[estimate], 3)\n\n            estimate_density = (\n                alt.vconcat(\n                    (\n                        (\n                            base_estimate.transform_density(\n                                estimate,\n                                as_=[estimate, \"Density\"],\n                                extent=[min_value, max_value],\n                            )\n                            .mark_area()\n                            .encode(\n                                x=alt.X(\"{}:Q\".format(estimate), title=None),\n                                y=alt.Y(\"Density:Q\", title=y_axis_title),\n                            )\n                        )\n                        + base_estimate.mark_rule(color=\"red\").encode(\n                            x=\"median({}):Q\".format(estimate),\n                            tooltip=alt.Tooltip(\"median({}):Q\".format(estimate)),\n                        )\n                    ).properties(width=800, height=300),\n                    (\n                        base_estimate.mark_tick().encode(\n                            x=alt.X(\"{}:Q\".format(estimate), axis=None)\n                        )\n                    ),\n                    spacing=0,\n                )\n                &amp; (\n                    base_estimate.mark_boxplot().encode(\n                        x=\"{}:Q\".format(estimate),\n                    )\n                )\n            ).resolve_scale(x=\"shared\")\n            quantitative_estimates.append(estimate_density)\n\n        else:\n            estimates[estimate] = estimates[estimate].astype(\"datetime64[ns]\")\n            estimate_density = (\n                (\n                    base_estimate.transform_timeunit(\n                        estimate=\"yearmonth({})\".format(estimate)\n                    )\n                    .mark_bar(size=10)\n                    .encode(\n                        x=alt.X(\n                            \"{}:T\".format(estimate),\n                            axis=alt.Axis(\n                                tickCount=\"month\",\n                                format=\"%Y, %b\",\n                                labelAngle=-90,\n                            ),\n                            title=estimate,\n                        ),\n                        y=alt.Y(\n                            \"count({}):Q\".format(estimate),\n                            axis=alt.Axis(tickMinStep=1),\n                            title=y_axis_title,\n                        ),\n                    )\n                )\n                + base_estimate.mark_rule(color=\"red\").encode(\n                    x=\"median({}):T\".format(estimate),\n                    tooltip=alt.Tooltip(\"median({}):T\".format(estimate)),\n                )\n            ).properties(width=800, height=300)\n            time_estimates.append(estimate_density)\n\n    estimates_densities = time_estimates + quantitative_estimates\n\n    chart = reduce(\n        lambda estimate_density_1, estimate_density_2: estimate_density_1\n        &amp; estimate_density_2,\n        estimates_densities,\n    )\n    if probe is not None:\n        base = alt.Chart(predictor)\n\n        horizontal_bar_charts, y_variables_selections = generate_horizontal_bar_charts(\n            base=base,\n            horizontal_bar_charts_config=horizontal_bar_charts_config,\n            predictor=predictor,\n        )\n        vertical_bar_charts, x_variables_selections = generate_vertical_bar_charts(\n            base=base,\n            vertical_bar_charts_config=vertical_bar_charts_config,\n            predictor=predictor,\n        )\n\n        selections = dict(\n            y_variables_selections,\n            **x_variables_selections,\n        )\n        selection_charts = dict(\n            horizontal_bar_charts,\n            **vertical_bar_charts,\n        )\n        chart = add_interactive_selection(\n            base=chart, selection_charts=selection_charts, selections=selections\n        )\n\n        chart = concatenate_charts(\n            main_chart=chart,\n            horizontal_bar_charts=horizontal_bar_charts,\n            vertical_bar_charts=vertical_bar_charts,\n            spacing=0,\n        )\n    elif \"care_site_level\" in estimates.columns:\n        care_site_level_dropdwon = alt.binding_select(\n            options=estimates[\"care_site_level\"].unique(), name=\"Care site level : \"\n        )\n        care_site_level_selection = alt.selection_point(\n            fields=[\"care_site_level\"],\n            bind=care_site_level_dropdwon,\n            value=estimates[\"care_site_level\"].unique()[0],\n        )\n        chart = chart.add_params(care_site_level_selection).transform_filter(\n            care_site_level_selection\n        )\n    if chart_style:\n        chart = configure_style(chart=chart, chart_style=chart_style)\n    if save_path:\n        save_html(\n            obj=chart,\n            filename=save_path,\n        )\n\n    return chart\n</code></pre>"},{"location":"reference/viz/plots/normalized_probe/","title":"<code>edsteva.viz.plots.normalized_probe</code>","text":""},{"location":"reference/viz/plots/normalized_probe/normalized_probe/","title":"<code>edsteva.viz.plots.normalized_probe.normalized_probe</code>","text":""},{"location":"reference/viz/plots/normalized_probe/normalized_probe/#edsteva.viz.plots.normalized_probe.normalized_probe.normalized_probe_plot","title":"normalized_probe_plot","text":"<pre><code>normalized_probe_plot(\n    probe: BaseProbe,\n    fitted_model: BaseModel,\n    care_site_level: List[str] = None,\n    start_date: Union[datetime, str] = None,\n    end_date: Union[datetime, str] = None,\n    t_min: int = None,\n    t_max: int = None,\n    save_path: str = None,\n    x_axis_title: str = None,\n    y_axis_title: str = None,\n    main_chart_config: Dict[str, float] = None,\n    model_line_config: Dict[str, str] = None,\n    probe_line_config: Dict[str, str] = None,\n    error_line_config: Dict[str, str] = None,\n    estimates_selections: Dict[str, str] = None,\n    estimates_filters: Dict[str, str] = None,\n    chart_style: Dict[str, float] = None,\n    indexes_to_remove: List[str] = [\"care_site_id\"],\n    **kwargs\n)\n</code></pre> <p>Displays a chart with the aggregated normalized completeness predictor \\(\\frac{c(\\Delta t)}{c_0}\\) over normalized time \\(\\Delta t = t - t_0\\). It represents the overall deviation from the Model.</p> <p>Is is possible to save the chart in HTML with the \"save_path\" optional input.</p> PARAMETER DESCRIPTION <code>probe</code> <p>Class describing the completeness predictor \\(c(t)\\)</p> <p> TYPE: <code>BaseProbe</code> </p> <code>fitted_model</code> <p>Model fitted to the probe</p> <p> TYPE: <code>BaseModel</code> </p> <code>care_site_level</code> <p>EXAMPLE: <code>[\"Hospital\"]</code>, <code>[\"H\u00f4pital\", \"UF\"]</code> or <code>[\"UF\", \"UH\"]</code></p> <p> TYPE: <code>List[str]</code> DEFAULT: <code>None</code> </p> <code>start_date</code> <p>EXAMPLE: <code>\"2019-05-01\"</code></p> <p> TYPE: <code>datetime</code> DEFAULT: <code>None</code> </p> <code>end_date</code> <p>EXAMPLE: <code>\"2021-07-01\"</code></p> <p> TYPE: <code>datetime</code> DEFAULT: <code>None</code> </p> <code>t_min</code> <p>Minimal difference with \\(t_0\\) in month \\(\\Delta t_{min}\\).</p> <p>EXAMPLE: <code>-24</code></p> <p> TYPE: <code>int</code> DEFAULT: <code>None</code> </p> <code>t_max</code> <p>Maximal difference with \\(t_0\\) in month \\(\\Delta t_{max}\\).</p> <p>EXAMPLE: <code>24</code></p> <p> TYPE: <code>int</code> DEFAULT: <code>None</code> </p> <code>save_path</code> <p>Folder path where to save the chart in HTML format.</p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> <code>x_axis_title</code> <p>Label name for the x axis.</p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> <code>y_axis_title</code> <p>Label name for the y axis.</p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> <code>main_chart_config</code> <p>If not None, configuration used to construct the top main chart.</p> <p> TYPE: <code>Dict[str, float]</code> DEFAULT: <code>None</code> </p> <code>model_line_config</code> <p>If not None, configuration used to construct the model line.</p> <p> TYPE: <code>Dict[str, str]</code> DEFAULT: <code>None</code> </p> <code>error_line_config</code> <p>If not None, configuration used to construct the error line.</p> <p> TYPE: <code>Dict[str, str]</code> DEFAULT: <code>None</code> </p> <code>probe_line_config</code> <p>If not None, configuration used to construct the probe line.</p> <p> TYPE: <code>Dict[str, str]</code> DEFAULT: <code>None</code> </p> <code>estimates_selections</code> <p>If not None, configuration used to construct the estimates selections.</p> <p> TYPE: <code>Dict[str, str]</code> DEFAULT: <code>None</code> </p> <code>estimates_filters</code> <p>If not None, configuration used to construct the estimates filters.</p> <p> TYPE: <code>Dict[str, str]</code> DEFAULT: <code>None</code> </p> <code>chart_style</code> <p>If not None, configuration used to configure the chart style.</p> <p>EXAMPLE: <code>{\"labelFontSize\": 13, \"titleFontSize\": 14}</code></p> <p> TYPE: <code>Dict[str, float]</code> DEFAULT: <code>None</code> </p> <code>indexes_to_remove</code> <p>indexes to remove from the groupby selection.</p> <p> TYPE: <code>List[str]</code> DEFAULT: <code>['care_site_id']</code> </p> Source code in <code>edsteva/viz/plots/normalized_probe/normalized_probe.py</code> <pre><code>def normalized_probe_plot(\n    probe: BaseProbe,\n    fitted_model: BaseModel,\n    care_site_level: List[str] = None,\n    start_date: Union[datetime, str] = None,\n    end_date: Union[datetime, str] = None,\n    t_min: int = None,\n    t_max: int = None,\n    save_path: str = None,\n    x_axis_title: str = None,\n    y_axis_title: str = None,\n    main_chart_config: Dict[str, float] = None,\n    model_line_config: Dict[str, str] = None,\n    probe_line_config: Dict[str, str] = None,\n    error_line_config: Dict[str, str] = None,\n    estimates_selections: Dict[str, str] = None,\n    estimates_filters: Dict[str, str] = None,\n    chart_style: Dict[str, float] = None,\n    indexes_to_remove: List[str] = [\"care_site_id\"],\n    **kwargs,\n):\nr\"\"\"Displays a chart with the aggregated normalized completeness predictor $\\frac{c(\\Delta t)}{c_0}$ over normalized time $\\Delta t = t - t_0$. It represents the overall deviation from the Model.\n\n    Is is possible to save the chart in HTML with the \"save_path\" optional input.\n\n    Parameters\n    ----------\n    probe : BaseProbe\n        Class describing the completeness predictor $c(t)$\n    fitted_model : BaseModel\n        Model fitted to the probe\n    care_site_level : List[str], optional\n        **EXAMPLE**: `[\"Hospital\"]`, `[\"H\u00f4pital\", \"UF\"]` or `[\"UF\", \"UH\"]`\n    start_date : datetime, optional\n        **EXAMPLE**: `\"2019-05-01\"`\n    end_date : datetime, optional\n        **EXAMPLE**: `\"2021-07-01\"`\n    t_min : int, optional\n        Minimal difference with $t_0$ in month $\\Delta t_{min}$.\n\n        **EXAMPLE**: `-24`\n    t_max : int, optional\n        Maximal difference with $t_0$ in month $\\Delta t_{max}$.\n\n        **EXAMPLE**: `24`\n    save_path : str, optional\n        Folder path where to save the chart in HTML format.\n    x_axis_title: str, optional,\n        Label name for the x axis.\n    y_axis_title: str, optional,\n        Label name for the y axis.\n    main_chart_config: Dict[str, str], optional\n        If not None, configuration used to construct the top main chart.\n    model_line_config: Dict[str, str], optional\n        If not None, configuration used to construct the model line.\n    error_line_config: Dict[str, str], optional\n        If not None, configuration used to construct the error line.\n    probe_line_config: Dict[str, str], optional\n        If not None, configuration used to construct the probe line.\n    estimates_selections: Dict[str, str], optional\n        If not None, configuration used to construct the estimates selections.\n    estimates_filters: Dict[str, str], optional\n        If not None, configuration used to construct the estimates filters.\n    chart_style: Dict[str, float], optional\n        If not None, configuration used to configure the chart style.\n\n        **EXAMPLE**: `{\"labelFontSize\": 13, \"titleFontSize\": 14}`\n    indexes_to_remove: List[str], optional\n        indexes to remove from the groupby selection.\n    \"\"\"\n\n    alt.data_transformers.disable_max_rows()\n\n    # Pre-processing\n    predictor = probe.predictor.copy()\n    predictor_metrics = probe._metrics.copy()\n    estimates = fitted_model.estimates.copy()\n    indexes = get_indexes_to_groupby(\n        predictor_columns=predictor.columns,\n        predictor_metrics=predictor_metrics,\n        indexes_to_remove=indexes_to_remove,\n    )\n    predictor = predictor.merge(estimates, on=probe._index)\n    predictor[\"normalized_date\"] = month_diff(\n        predictor[\"date\"], predictor[\"t_0\"]\n    ).astype(int)\n    for estimate in fitted_model._coefs + fitted_model._metrics:\n        if pd.api.types.is_datetime64_any_dtype(predictor[estimate]):\n            predictor[estimate] = predictor[estimate].dt.strftime(\"%Y-%m\")\n    predictor[\"normalized_c\"] = predictor[\"c\"].where(\n        (predictor[\"normalized_date\"] &lt; 0) | (predictor[\"c_0\"] == 0),\n        predictor[\"c\"] / predictor[\"c_0\"],\n    )\n    predictor[\"model\"] = 1\n    predictor[\"model\"] = predictor[\"model\"].where(predictor[\"normalized_date\"] &gt;= 0, 0)\n    predictor = filter_data(\n        data=predictor,\n        care_site_level=care_site_level,\n        start_date=start_date,\n        end_date=end_date,\n        **kwargs,\n    )\n    if t_min:\n        predictor = predictor[predictor.normalized_date &gt;= t_min]\n    if t_max:\n        predictor = predictor[predictor.normalized_date &lt;= t_max]\n\n    # Get viz config\n    probe_config = deepcopy(probe.get_viz_config(\"normalized_probe_plot\"))\n    model_config = deepcopy(\n        fitted_model.get_viz_config(\"normalized_probe_plot\", predictor=predictor)\n    )\n    if probe_line_config is None:\n        probe_line_config = model_config[\"probe_line\"]\n    if model_line_config is None:\n        model_line_config = model_config[\"model_line\"]\n    if error_line_config is None:\n        error_line_config = model_config[\"error_line\"]\n    if estimates_selections is None:\n        estimates_selections = model_config[\"estimates_selections\"]\n    if estimates_filters is None:\n        estimates_filters = model_config[\"estimates_filters\"]\n    if main_chart_config is None:\n        main_chart_config = probe_config[\"main_chart\"]\n    if chart_style is None:\n        chart_style = probe_config[\"chart_style\"]\n\n    # Viz\n    predictor[\"legend_model\"] = (\n        model_line_config.get(\"legend_title\")\n        if model_line_config.get(\"legend_title\")\n        else type(fitted_model).__name__\n    )\n    predictor[\"legend_predictor\"] = probe_line_config[\"legend_title\"]\n    predictor[\"legend_error_band\"] = error_line_config[\"legend_title\"]\n    index_selection, index_fields = create_groupby_selection(\n        indexes=indexes,\n        predictor=predictor,\n    )\n    base = alt.Chart(predictor)\n    base = add_estimates_filters(\n        base=base,\n        estimates_filters=estimates_filters,\n    )\n    main_chart = generate_main_chart(\n        base=base,\n        main_chart_config=main_chart_config,\n        index_selection=index_selection,\n        index_fields=index_fields,\n        x_axis_title=x_axis_title,\n        y_axis_title=y_axis_title,\n    )\n    probe_line = generate_probe_line(\n        main_chart=main_chart, probe_line_config=probe_line_config\n    )\n    error_line = generate_error_line(\n        main_chart=main_chart, error_line_config=error_line_config\n    )\n    model_line = generate_model_line(\n        main_chart=main_chart, model_line_config=model_line_config\n    )\n    main_chart = probe_line + error_line + model_line\n    if index_selection:\n        main_chart = main_chart.add_params(index_selection)\n\n    for estimate_selection in estimates_selections:\n        main_chart = main_chart.add_params(estimate_selection)\n\n    main_chart = configure_style(chart=main_chart, chart_style=chart_style)\n\n    if save_path:\n        save_html(\n            obj=main_chart,\n            filename=save_path,\n        )\n\n    return main_chart\n</code></pre>"},{"location":"reference/viz/plots/probe/","title":"<code>edsteva.viz.plots.probe</code>","text":""},{"location":"reference/viz/plots/probe/fitted_probe/","title":"<code>edsteva.viz.plots.probe.fitted_probe</code>","text":""},{"location":"reference/viz/plots/probe/fitted_probe/#edsteva.viz.plots.probe.fitted_probe.fitted_probe_line","title":"fitted_probe_line","text":"<pre><code>fitted_probe_line(\n    predictor: pd.DataFrame,\n    indexes: List[Dict[str, str]],\n    legend_predictor: str,\n    legend_model: str,\n    x_axis_title: str,\n    y_axis_title: str,\n    main_chart_config: Dict[str, float],\n    model_line_config: Dict[str, str],\n    probe_line_config: Dict[str, str],\n)\n</code></pre> <p>Script to be used by <code>plot_probe()</code></p> PARAMETER DESCRIPTION <code>predictor</code> <p>\\(c(t)\\) computed in the Probe with its prediction \\(\\hat{c}(t)\\)</p> <p> TYPE: <code>pd.DataFrame</code> </p> <code>indexes</code> <p>Variable from which data is grouped</p> <p> TYPE: <code>List[str]</code> </p> <code>legend_predictor</code> <p>Label name for the predictor legend.</p> <p> TYPE: <code>str</code> </p> <code>legend_model</code> <p>Label name for the model legend.</p> <p> TYPE: <code>str</code> </p> <code>x_axis_title</code> <p>Label name for the x axis.</p> <p> TYPE: <code>str</code> </p> <code>y_axis_title</code> <p>Label name for the y axis.</p> <p> TYPE: <code>str</code> </p> <code>main_chart_config</code> <p>If not None, configuration used to construct the top main chart.</p> <p> TYPE: <code>Dict[str, float]</code> </p> <code>model_line_config</code> <p>If not None, configuration used to construct the model line.</p> <p> TYPE: <code>Dict[str, str]</code> </p> <code>probe_line_config</code> <p>If not None, configuration used to construct the probe line.</p> <p> TYPE: <code>Dict[str, str]</code> </p> Source code in <code>edsteva/viz/plots/probe/fitted_probe.py</code> <pre><code>def fitted_probe_line(\n    predictor: pd.DataFrame,\n    indexes: List[Dict[str, str]],\n    legend_predictor: str,\n    legend_model: str,\n    x_axis_title: str,\n    y_axis_title: str,\n    main_chart_config: Dict[str, float],\n    model_line_config: Dict[str, str],\n    probe_line_config: Dict[str, str],\n):\nr\"\"\"Script to be used by [``plot_probe()``][edsteva.viz.plots.probe.wrapper]\n\n    Parameters\n    ----------\n    predictor : pd.DataFrame\n        $c(t)$ computed in the Probe with its prediction $\\hat{c}(t)$\n    indexes : List[str]\n        Variable from which data is grouped\n    legend_predictor: str, optional,\n        Label name for the predictor legend.\n    legend_model: str, optional,\n        Label name for the model legend.\n    x_axis_title: str, optional,\n        Label name for the x axis.\n    y_axis_title: str, optional,\n        Label name for the y axis.\n    main_chart_config: Dict[str, str], optional\n        If not None, configuration used to construct the top main chart.\n    model_line_config: Dict[str, str], optional\n        If not None, configuration used to construct the model line.\n    probe_line_config: Dict[str, str], optional\n        If not None, configuration used to construct the probe line.\n    \"\"\"\n    predictor[\"legend_predictor\"] = legend_predictor\n    predictor[\"legend_model\"] = legend_model\n\n    base = alt.Chart(predictor)\n\n    index_selection, index_fields = create_groupby_selection(\n        indexes=indexes,\n        predictor=predictor,\n    )\n    main_chart = generate_main_chart(\n        base=base,\n        main_chart_config=main_chart_config,\n        index_selection=index_selection,\n        index_fields=index_fields,\n        x_axis_title=x_axis_title,\n        y_axis_title=y_axis_title,\n    )\n\n    probe_line = generate_probe_line(\n        main_chart=main_chart, probe_line_config=probe_line_config\n    )\n\n    model_line = generate_model_line(\n        main_chart=main_chart, model_line_config=model_line_config\n    )\n\n    main_chart = probe_line + model_line\n    if index_selection:\n        main_chart = main_chart.add_params(index_selection)\n\n    return main_chart\n</code></pre>"},{"location":"reference/viz/plots/probe/probe/","title":"<code>edsteva.viz.plots.probe.probe</code>","text":""},{"location":"reference/viz/plots/probe/probe/#edsteva.viz.plots.probe.probe.probe_line","title":"probe_line","text":"<pre><code>probe_line(\n    predictor: pd.DataFrame,\n    indexes: List[Dict[str, str]],\n    x_axis_title: str,\n    y_axis_title: str,\n    main_chart_config: Dict[str, float],\n)\n</code></pre> <p>Script to be used by <code>plot_probe()</code></p> PARAMETER DESCRIPTION <code>predictor</code> <p>\\(c(t)\\) computed in the Probe</p> <p> TYPE: <code>pd.DataFrame</code> </p> <code>indexes</code> <p>Variable from which data is grouped</p> <p> TYPE: <code>List[str]</code> </p> <code>x_axis_title</code> <p>Label name for the x axis.</p> <p> TYPE: <code>str</code> </p> <code>y_axis_title</code> <p>Label name for the y axis.</p> <p> TYPE: <code>str</code> </p> <code>main_chart_config</code> <p>If not None, configuration used to construct the top main chart.</p> <p> TYPE: <code>Dict[str, float]</code> </p> Source code in <code>edsteva/viz/plots/probe/probe.py</code> <pre><code>def probe_line(\n    predictor: pd.DataFrame,\n    indexes: List[Dict[str, str]],\n    x_axis_title: str,\n    y_axis_title: str,\n    main_chart_config: Dict[str, float],\n):\n\"\"\"Script to be used by [``plot_probe()``][edsteva.viz.plots.probe.wrapper]\n\n    Parameters\n    ----------\n    predictor : pd.DataFrame\n        $c(t)$ computed in the Probe\n    indexes : List[str]\n        Variable from which data is grouped\n    x_axis_title: str, optional,\n        Label name for the x axis.\n    y_axis_title: str, optional,\n        Label name for the y axis.\n    main_chart_config: Dict[str, str], optional\n        If not None, configuration used to construct the top main chart.\n    \"\"\"\n    base = alt.Chart(predictor)\n\n    index_selection, index_fields = create_groupby_selection(\n        indexes=indexes,\n        predictor=predictor,\n    )\n    main_chart = generate_main_chart(\n        base=base,\n        main_chart_config=main_chart_config,\n        index_selection=index_selection,\n        index_fields=index_fields,\n        x_axis_title=x_axis_title,\n        y_axis_title=y_axis_title,\n    )\n    main_chart = main_chart.mark_line()\n    main_chart = add_selection_on_legend(main_chart)\n\n    if index_selection:\n        main_chart = main_chart.add_params(index_selection)\n\n    return main_chart\n</code></pre>"},{"location":"reference/viz/plots/probe/wrapper/","title":"<code>edsteva.viz.plots.probe.wrapper</code>","text":""},{"location":"reference/viz/plots/probe/wrapper/#edsteva.viz.plots.probe.wrapper.probe_plot","title":"probe_plot","text":"<pre><code>probe_plot(\n    probe: BaseProbe,\n    fitted_model: BaseModel = None,\n    care_site_level: List[str] = None,\n    start_date: datetime = None,\n    end_date: datetime = None,\n    save_path: str = None,\n    legend_predictor: str = \"Predictor c(t)\",\n    legend_model: str = \"Model f(t)\",\n    x_axis_title: str = None,\n    y_axis_title: str = None,\n    main_chart_config: Dict[str, float] = None,\n    model_line_config: Dict[str, str] = None,\n    probe_line_config: Dict[str, str] = None,\n    chart_style: Dict[str, float] = None,\n    indexes_to_remove: List[str] = [\"care_site_id\"],\n    **kwargs\n)\n</code></pre> <p>Displays a chart with the average completeness predictor \\(c(t)\\) over time \\(t\\) with the fitted model \\(\\hat{c}(t)\\) if specified. The chart is exportable in png or svg format and easy to integrate into a report. Is also possible to save the chart in HTML with the \"save_path\" optional input.</p> PARAMETER DESCRIPTION <code>probe</code> <p>Class describing the completeness predictor \\(c(t)\\).</p> <p> TYPE: <code>BaseProbe</code> </p> <code>fitted_model</code> <p>Model fitted to the probe</p> <p> TYPE: <code>BaseModel</code> DEFAULT: <code>None</code> </p> <code>care_site_level</code> <p>EXAMPLE: <code>[\"Hospital\"]</code>, <code>[\"H\u00f4pital\", \"UF\"]</code> or <code>[\"UF\", \"UH\"]</code></p> <p> TYPE: <code>List[str]</code> DEFAULT: <code>None</code> </p> <code>start_date</code> <p>EXAMPLE: <code>\"2019-05-01\"</code></p> <p> TYPE: <code>datetime</code> DEFAULT: <code>None</code> </p> <code>end_date</code> <p>EXAMPLE: <code>\"2021-07-01\"</code></p> <p> TYPE: <code>datetime</code> DEFAULT: <code>None</code> </p> <code>save_path</code> <p>Folder path where to save the chart in HTML format.</p> <p>EXAMPLE: <code>\"my_folder/my_file.html\"</code></p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> <code>legend_predictor</code> <p>Label name for the predictor legend.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'Predictor c(t)'</code> </p> <code>legend_model</code> <p>Label name for the model legend.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'Model f(t)'</code> </p> <code>x_axis_title</code> <p>Label name for the x axis.</p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> <code>y_axis_title</code> <p>Label name for the y axis.</p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> <code>main_chart_config</code> <p>If not None, configuration used to construct the top main chart.</p> <p> TYPE: <code>Dict[str, float]</code> DEFAULT: <code>None</code> </p> <code>model_line_config</code> <p>If not None, configuration used to construct the model line.</p> <p> TYPE: <code>Dict[str, str]</code> DEFAULT: <code>None</code> </p> <code>probe_line_config</code> <p>If not None, configuration used to construct the probe line.</p> <p> TYPE: <code>Dict[str, str]</code> DEFAULT: <code>None</code> </p> <code>chart_style</code> <p>If not None, configuration used to configure the chart style.</p> <p>EXAMPLE: <code>{\"labelFontSize\": 13, \"titleFontSize\": 14}</code></p> <p> TYPE: <code>Dict[str, float]</code> DEFAULT: <code>None</code> </p> <code>indexes_to_remove</code> <p>indexes to remove from the groupby selection.</p> <p> TYPE: <code>List[str]</code> DEFAULT: <code>['care_site_id']</code> </p> Source code in <code>edsteva/viz/plots/probe/wrapper.py</code> <pre><code>def probe_plot(\n    probe: BaseProbe,\n    fitted_model: BaseModel = None,\n    care_site_level: List[str] = None,\n    start_date: datetime = None,\n    end_date: datetime = None,\n    save_path: str = None,\n    legend_predictor: str = \"Predictor c(t)\",\n    legend_model: str = \"Model f(t)\",\n    x_axis_title: str = None,\n    y_axis_title: str = None,\n    main_chart_config: Dict[str, float] = None,\n    model_line_config: Dict[str, str] = None,\n    probe_line_config: Dict[str, str] = None,\n    chart_style: Dict[str, float] = None,\n    indexes_to_remove: List[str] = [\"care_site_id\"],\n    **kwargs,\n):\nr\"\"\"\n    Displays a chart with the average completeness predictor $c(t)$ over time $t$ with the fitted model $\\hat{c}(t)$ if specified.\n    The chart is exportable in png or svg format and easy to integrate into a report. Is also possible to save the chart in HTML with the \"save_path\" optional input.\n\n    Parameters\n    ----------\n    probe : BaseProbe\n        Class describing the completeness predictor $c(t)$.\n    fitted_model : BaseModel, optional\n        Model fitted to the probe\n    care_site_level : List[str], optional\n        **EXAMPLE**: `[\"Hospital\"]`, `[\"H\u00f4pital\", \"UF\"]` or `[\"UF\", \"UH\"]`\n    start_date : datetime, optional\n        **EXAMPLE**: `\"2019-05-01\"`\n    end_date : datetime, optional\n        **EXAMPLE**: `\"2021-07-01\"`\n    save_path : str, optional\n        Folder path where to save the chart in HTML format.\n\n        **EXAMPLE**: `\"my_folder/my_file.html\"`\n    legend_predictor: str, optional,\n        Label name for the predictor legend.\n    legend_model: str, optional,\n        Label name for the model legend.\n    x_axis_title: str, optional,\n        Label name for the x axis.\n    y_axis_title: str, optional,\n        Label name for the y axis.\n    main_chart_config: Dict[str, str], optional\n        If not None, configuration used to construct the top main chart.\n    model_line_config: Dict[str, str], optional\n        If not None, configuration used to construct the model line.\n    probe_line_config: Dict[str, str], optional\n        If not None, configuration used to construct the probe line.\n    chart_style: Dict[str, float], optional\n        If not None, configuration used to configure the chart style.\n\n        **EXAMPLE**: `{\"labelFontSize\": 13, \"titleFontSize\": 14}`\n    indexes_to_remove: List[str], optional\n        indexes to remove from the groupby selection.\n    \"\"\"\n    alt.data_transformers.enable(\"default\")\n    alt.data_transformers.disable_max_rows()\n\n    probe_config = deepcopy(probe.get_viz_config(\"probe_plot\"))\n    if main_chart_config is None:\n        main_chart_config = probe_config[\"main_chart\"]\n    if chart_style is None:\n        chart_style = probe_config[\"chart_style\"]\n    predictor = probe.predictor.copy()\n    cols_to_remove = [\"date\", *probe._metrics]\n    if indexes_to_remove:\n        cols_to_remove.extend(indexes_to_remove)\n    indexes = list(set(predictor.columns).difference(cols_to_remove))\n\n    if fitted_model:\n        predictor = fitted_model.predict(probe).copy()\n    else:\n        predictor = probe.predictor.copy()\n\n    predictor = filter_data(\n        data=predictor,\n        care_site_level=care_site_level,\n        start_date=start_date,\n        end_date=end_date,\n        **kwargs,\n    )\n\n    indexes = [\n        {\"field\": variable, \"title\": variable.replace(\"_\", \" \").capitalize()}\n        for variable in indexes\n        if variable in predictor.columns and len(predictor[variable].unique()) &gt;= 2\n    ]\n\n    if fitted_model:\n        model_config = deepcopy(fitted_model.get_viz_config(\"probe_plot\"))\n        if model_line_config is None:\n            model_line_config = model_config[\"model_line\"]\n        if probe_line_config is None:\n            probe_line_config = model_config[\"probe_line\"]\n        chart = fitted_probe_line(\n            predictor=predictor,\n            indexes=indexes,\n            legend_predictor=legend_predictor,\n            legend_model=legend_model,\n            x_axis_title=x_axis_title,\n            y_axis_title=y_axis_title,\n            main_chart_config=main_chart_config,\n            model_line_config=model_line_config,\n            probe_line_config=probe_line_config,\n        )\n    else:\n        chart = probe_line(\n            predictor=predictor,\n            indexes=indexes,\n            x_axis_title=x_axis_title,\n            y_axis_title=y_axis_title,\n            main_chart_config=main_chart_config,\n        )\n\n    if save_path:\n        save_html(\n            obj=configure_style(chart=chart, chart_style=chart_style),\n            filename=save_path,\n        )\n\n    return chart\n</code></pre>"}]}